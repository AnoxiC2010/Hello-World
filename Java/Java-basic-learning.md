Java语法基础





## 1. 关键字和保留字

> 学习Java的第一步是要认识关键字和保留字



### 1.1 关键字（KeyWord）

> 什么是关键字？关键字有什么特点？

- 关键字是被Java语法赋予特定含义的单词

- 关键字都是合法的单词，必须全部小写



> 关键字有什么作用？

- 关键字对编译器有特殊意义（影响编译）
- 他们用来表示一种数据类型或者表示程序的结构



### 1.2 保留字（ReserveWord）

> 什么是保留字？保留字有什么作用

- 保留字是对当前版本的Java，并没有特殊含义的单词

- 但是以后的版本中，Java官方可能会将其变成具有特殊含义的单词，升级为关键字

- 即便以后也不打算升级为关键字，但是Java官方认为你不应该在Java代码中使用的单词，也会变成保留字

  

> 有哪些保留字？
>
> Java目前有且仅有两个保留字

- const
- goto



### 1.3 关键字和保留字的语法意义

> 关键字和保留字对Java程序有显著影响

- 关键字和保留字均不能用作变量名、方法名、类名、包名和参数
- 由于大家使用比较高级的集成开发环境，关键字是有特殊颜色标记的



> 课堂抽奖

以下哪些是关键字（保留字）？

class，HelloWorld，public，static，Const，void，main，String，System，goto





### 1.4 Java关键字大全

| 关键字       | 含义                                                         |
| ------------ | ------------------------------------------------------------ |
| abstract     | 表明类或者成员方法具有抽象属性                               |
| assert       | 用来进行程序调试                                             |
| boolean      | 基本数据类型之一，布尔类型                                   |
| break        | 提前跳出一个块                                               |
| byte         | 基本数据类型之一，字节类型                                   |
| case         | 用在switch语句之中，表示其中的一个分支                       |
| catch        | 用在异常处理中，用来捕捉异常                                 |
| char         | 基本数据类型之一，字符类型                                   |
| class        | 类                                                           |
| const        | 保留关键字，没有具体含义                                     |
| continue     | 回到一个块的开始处                                           |
| default      | 默认，例如，用在switch语句中，表明一个默认的分支             |
| do           | 用在do-while循环结构中                                       |
| double       | 基本数据类型之一，双精度浮点数类型                           |
| else         | 用在条件语句中，表明当条件不成立时的分支                     |
| enum         | 枚举                                                         |
| extends      | 表明一个类型是另一个类型的子类型，这里常见的类型有类和接口   |
| final        | 用来说明最终属性，表明一个类不能派生出子类，或者成员方法不能被覆盖，或者成员域的值不能被改变，用来定义常量 |
| finally      | 用于处理异常情况，用来声明一个基本肯定会被执行到的语句块     |
| float        | 基本数据类型之一，单精度浮点数类型                           |
| for          | 一种循环结构的引导词                                         |
| goto         | 保留关键字，没有具体含义                                     |
| if           | 条件语句的引导词                                             |
| implements   | 表明一个类实现了给定的接口                                   |
| import       | 表明要访问指定的类或包                                       |
| instanceof   | 用来测试一个对象是否是指定类型的实例对象                     |
| int          | 基本数据类型之一，整数类型                                   |
| interface    | 接口                                                         |
| long         | 基本数据类型之一，长整数类型                                 |
| native       | 用来声明一个方法是由与计算机相关的语言(如C/C++/FORTRAN语言)实现的 |
| new          | 用来创建新实例对象                                           |
| package      | 包                                                           |
| private      | 一种访问控制方式：私用模式                                   |
| protected    | 一种访问控制方式：保护模式                                   |
| public       | 一种访问控制方式：共用模式                                   |
| return       | 从成员方法中返回数据                                         |
| short        | 基本数据类型之一，短整数类型                                 |
| static       | 表明具有静态属性                                             |
| strictfp     | 用来声明FP_strict(单精度或双精度浮点数)表达式遵循IEEE 754算术规范 |
| super        | 表明当前对象的父类型的引用或者父类型的构造方法               |
| switch       | 分支语句结构的引导词                                         |
| synchronized | 表明一段代码需要同步执行                                     |
| this         | 指向当前实例对象的引用                                       |
| throw        | 抛出一个异常                                                 |
| throws       | 声明在当前定义的成员方法中所有需要抛出的异常                 |
| transient    | 声明不用序列化的成员域                                       |
| try          | 尝试一个可能抛出异常的程序块                                 |
| void         | 声明当前成员方法没有返回值                                   |
| volatile     | 表明两个或者多个变量必须同步地发生变化                       |
| while        | 用在循环结构中                                               |



## 2. 标识符（Identifier）

> 什么是标识符？标识符有什么用？

- 标识符是给包，类，接口，方法，变量等起名字时使用的字符序列
- 标识符就是起名字时用的字符串



### 2.1 虚假的标识符命名规则（语法）

> 语法上要求的标识符的规则是什么？

- 标识符的组成
  - 数字（0~9）
  - 字母（A~Z 和 a~z）
  - 美元符号（$）
  - 下划线（_）
  - Unicode 字符集中符号大于0xC0的所有符号
- 标识符的开头
  - 字母（A~Z 和 a~z）
  - 下划线（_）
  - 美元符号（$）
  - Unicode 字符集中符号大于 0xC0 的所有符号
- 注意事项
  - 标识符不能以数字开头
  - 不能是Java中的关键字和保留字
  - 标识符区分大小写



> 课堂抽奖

以下标识符命名合法的有哪些？

HelloWorld，_985，$bS5_c7，class，长风，Class ，DataClass#，98.3，Hello  World，好きだ





### 2.2 真实的标识符组成规则（基于语法的约定）

以上只是语法范畴的标识符规则，但就像人可以起名叫“张三，李四”，但几乎没人这么做一样

在符合语法的前提下，标识符还有一套约定俗成的命名规则，详见《阿里巴巴Java开发规范》

> 真实的标识符组成规则

- 符合语法
- 只能用英文字母、数字（下划线特殊场景使用并且不能作为开头，美元符号几乎不使用）
- 包命名标识符
  - Java中的包类似操作系统中的文件夹
    - 包用来区分同名Java文件
    - 包用来区分访问权限
  - 包的命名，以反转公司域名为规范
  - 包名应该全部小写
  - 多级包名以点（.）分隔
- 类、接口等命名标识符
  - 大驼峰命名法
- 变量、方法的命名标识符
  - 小驼峰命名法
- 常量的命名标识符
  - 全部大写（建议）
  - 多个单词之间用下划线（_）隔开



> 为了方便大家后续看代码，我会给包名前加序号表示我们上课的顺序，但是大家开发中不要这么做



> 给人起名字也追求好听吉祥，标识符起名也有自己的追求

- 核心追求是“见名知意”，应该赋予标识符一个有意义、有用途的名字
- 标识符的命名规范，可以从源码、大神的代码中学习，也是一个逐渐积累的过程





> 课堂抽奖
>
> 以下哪些标识符的命名规则符合规范

```java 
public class student{}
public class TestDemo{}
int Num;
String name;
public class Persondemo{}
包名 Test.Demo
包名 com.baidu
int nianling; 
String 名字;
```





### 2.3 驼峰命名法

#### 2.3.1 小驼峰式命名法（lower camel case）

- 多个单词组合成一个字符串
  - 第一个单词的首字母小写
  - 从第二个单词开始，首字母都要大写
- 例如：myName，myFirstJavaProgram



#### 2.3.2 大驼峰式命名法（upper camel case）

- 多个单词组合成一个字符串
  - 第一个单词的首字母大写
  - 从第二个单词开始，首字母都要大写
- 例如：MyName，MyFirstJavaProgram





## 3. 注释（comment）

> 什么是注释？

- 注释是可以嵌入到Java代码的任何位置的，一种解释说明性的文字

> 注释有什么作用？

- 方便自己写代码的时候，记录程序的信息
- 增加代码的可读性
  - 过段时间后，自己也能很快想起来，自己写的代码是干什么的
  - 最重要的，方便别人能看懂自己的代码
- 写注释可以增加自己写代码的逻辑性
  - 编码之前先用注释，标注好需要做的事情，先搞明白思路，再写代码
  - 编码实际上就是思想的体现
- 注释也可以作为一种比较简单但十分好用有效的，debug的方式
  - 将可能出错的代码注释掉，再运行程序，直到找出bug
  - 这种方式虽然看起来很笨，实际上用途很大，不要忘记它

> 注释的语法

Java支持三种注释的语法格式

- 单行注释

  ```Java
  //注释的文字
  ```

- 多行注释

  ```java 
  /*
  注释的文字
  */
  ```

- 文档注释

  ```java 
  /**
  注释的文字
  */
  ```

> 注释的使用注意事项

- 多行注释和文档注释不要嵌套使用
- 注释不参与编译，编译器会自动丢掉代码中的注释部分
- JDK中提供了javadoc.exe工具，用于将文档注释输出到一个HTML文件中





## 4. 常量与变量

> 程序运行中，内存中有很多数据参与运算
>
> - Java使用变量来存储这些数据
> - 程序运行中，值不变的变量就是常量



### 4.1 常量（constant）

>什么是常量？

- 在程序运行过程中，其值不会发生改变的量

>常量有哪些分类？

- 字面值常量（literal）
  - 字符串常量：双引号引起来的内容
    - “Hello World！”
  - 整数常量：所有的整数
    - 1，2，3
  - 小数常量：所有的小数
    - 1.1，1.2
  - 字符常量：单引号引起来的内容
    - 'W'，'E'，
  - 布尔常量
    - 只有true和false
  - 空常量，针对引用数据类型
    - 只有null
- 自定义常量（custom，面向对象详细讲）



### 4.2 变量（variable）

> 什么是变量？

- 程序运行期间，其值在某个范围内，可能会发生改变的量
- 需要强调的是，变量指的是该数据的值可能会发生变化的可能性，只要有可能改变，这个量就是变量

> 怎么定义一个能够使用的变量

- 两步走：先声明变量，再初始化变量（赋值）



#### 4.2.1 声明（declaration）变量

> 什么是声明变量？

- 告诉编译器，变量的数据类型，变量的名字

> 声明变量的语法

```Java
数据类型 变量名;
```

- 声明后的变量能够直接使用吗？

  不能，使用前需要初始化。

 



#### 4.2.2 初始化（initialization）变量

> 什么是初始化变量

- 就是给变量赋值，声明一个变量后，必须由程序员显式的进行赋值操作，这个变量才能够使用

> 初始化变量的语法

```Java
变量名 = 变量值;
```

声明和初始化可以合起来

```
数据类型 变量名 = 变量名;
```



#### 4.2.3 使用变量的注意事项

- 注意：Java当中的整数字面值常量，默认当作int处理
  - 如果你想要一个整数字面值常量数据类型为long，需要在后缀上加l或L，推荐L
- 注意：Java当中的浮点数，默认当作double处理
  - 如果你想要一个浮点数字面值常量数据类型为float，需要在后缀上加f或F，推荐
- 变量有效的范围，这个范围通常用{}来界定，同样一个{}不能有同名变量
- 变量必须显式初始化，只有声明的变量无法使用它
- 一行一个语句可以定义多个同数据类型的变量，用逗号隔开
  - 但是一行定义多个变量会影响代码的阅读性，一般不要一行定义多个变量
- 浮点型有精度问题，需要特别注意
  - 一般来说，开发中不会使用浮点类型进行计算，尤其是财务系统等对数值敏感的地方



## 5. 基本数据类型和引用数据类型

>  Java是强类型语言，每一个变量都必须有它的数据类型，并且变量之间不能随便转换数据类型

- 主流的语言大多都是强类型 C、C++、Java、Python

> 弱类型语言，变量之间转换类型比较方便

- PHP



> 什么是数据类型？

- 数据类型，表示的是一个数据集合和基于该数据集合的一组合法操作

> 数据类型怎么分类？

- 基本数据类型：JDK默认提供
- 引用数据类型
  - 类
  - 接口
  - ....



### 5.1 基本数据类型（base date type）

> 有哪些基本数据类型？

> 四类八种

- 整型
  - byte：字节，1个字节空间
  - short：短整型，占2个字节空间
  - int：整型，占4个字节空间
  - long：长整型，占8个字节空间
- 浮点型
  - float：单精度浮点型，占4个字节
  - double：双精度浮点型，占8个字节
- 字符类型
  - char：占2个字节，表示单个字符
- 布尔类型
  - boolean：具体占多少内存，了解即可
    - 根据JVM规范，在内存中boolean当作int处理，占4个字节
    - boolean数组当成byte数组处理，一个boolean元素占1个字节



#### 5.1.1 基本数值类型的取值范围

| 基本数据类型 | 字节长度 | 大小（位） | 最小值 | 最大值 | 取值范围                                                  |
| ------------ | -------- | ---------- | ------ | ------ | --------------------------------------------------------- |
| byte         | 1字节    | 8bit       | -2^7   | 2^7-1  | -128 ~ 127                                                |
| short        | 2字节    | 16bit      | -2^15  | 2^15-1 | -32768 ~ 32767                                            |
| int          | 4字节    | 32bit      | -2^31  | 2^31-1 | -2147483648 ~ 2147483647（21亿出头）                      |
| long         | 8字节    | 64bit      | -2^63  | 2^63-1 | -9223372036854774808 ~ 9223372036854774807（大概922亿亿） |
| float        | 4字节    | 32bit      | -      | -      | -3.403E38~3.404E38（有效位数7~8位）                       |
| double       | 8字节    | 64bit      | -      | -      | -1.798E308~1.798E308（有效数字16~17位）                   |



####  5.1.2 浮点型的精度问题（precision problem）

> 什么是精度问题？
>
> 计算的结果的数据类型，或者新的数据类型无法容纳全部的数据，导致部分信息被截断丢失，数据失真
>
> 专业名词就叫做“精度丢失”



> 经典的案例

- 计算10/3.0
- 计算1-0.9
- 二进制表示0.1

> - 正数十进制转换成二进制，除2直到商为0，取余数倒过来
>
> - 负数十进制转换成二进制，先算出正数的二进制数,取反+1
>
> - 正小数转换成二进制，用小数部分乘以2，取结果的整数部分(必然是1或者0)，
>   - 然后小数部分继续乘2
>   - 直到小数部分为0,或者已经达到了最大的位数
>   - 最终的结果（0.开头）正序排列

- 结论：

> float和double类型主要是为了科学计算和工程计算而设计的
>
> 它们执行的二进制浮点运算，是在广泛的数字范围上较为精确而快速的近似计算
>
> 所以直接使用float和double类型做浮点运算很容易出现误差，也就是精度损失
>
> 我们不应该把它们用于精确计算的场合，尤其不适合用于货币运算

- 最好的解决办法是用BigDecimal 替代float和double进行浮点数计算







### 5.2 引用数据类型（reference）

> 碍于知识点的限制，目前只要知道字符串（String）是一种引用数据类型即可
>
> String属于引用数据类型中的类





### 5.3 基本数据类型的数据类型转换（conversion）

> 什么是数据类型转换呢？

- Java是强类型语言，变量一旦声明后，数据类型不会轻易改变，但也并非完全不可能改变
- 我们将Java中变量的数据类型由某一种转换为另一种，这个过程叫做数据类型转换

> 数据类型转换的分类

- 自动类型转换，也叫向上转型
  - 向上转型只是自动类型转换的一种说法，这种说法只针对引用数据类型
- 强制类型转换，也叫向下转型
  - 向下转型只是自动类型转换的一种说法，这种说法只针对引用数据类型



#### 5.3.1 基本数据类型的自动类型转换（automatic）

> 什么是自动类型转换？

- 数据类型无需程序员操作，由编译器自动转换

> 基本数据类型的自动类型转换的规则
>
> “小取值范围”转换为“大取值范围”发生自动类型转换（浮点数都比long取值范围大）

- byte、short、char之间不互相转换，一旦之间发生运算，一律自动转换为int进行运算，结果是int
- byte、short、char任一数据类型与int进行计算，一律自动转换为int进行计算，结果是int
- byte、short、char、int任一数据类型与long进行计算，一律自动转换为long进行计算，结果是long
- byte、short、char、int、long任一数据类型与float进行计算，一律自动转换为float进行计算，结果是float
- byte、short、char、int、long、float任一数据类型与double进行计算，一律自动转换为double进行计算，结果是double

> 精度问题
>
> “小容量”不一定是“小取值范围”——所有浮点类型都比long取值范围大
>
> 但是由于浮点数本身的问题，整型的内存表示方式也和浮点型完全不同，很容易产生精度丢失

- 当int、long（4字节，8字节）自动转换成float（4字节）时，可能会有精度损失
- 当long自动转换成double（8字节）时，也可能产生精度损失
- 不要用浮点型计算小数，除非对精度十分不敏感



> 以下会产生精度丢失
>
> ```
> int(4B)->float(4B)
> long(8B)->double(8B)
> long(8B)->float(4B)
> ```



#### 5.3.2 基本数据类型的强制类型转换（cast）

> 什么是强制类型转换

- 数据类型的转换需要程序员显式操作，否则编译器报错

> 什么时候需要强制类型转换

- 在特别有必要的情况下，把一个“大取值范围”的数据类型，转换成“小取值范围”的数据类型，比如int---->byte
- 如果不是特别必要，不要做这种操作，因为很容易丢失精度

> 语法

```java
目标数据类型 变量名 = (目标数据类型)(被转换的变量变量名);
```

> 精度问题

- 强制类型转换，大变小，精度损失是很常见的
- 强烈建议：除非是非强转不可，不要使用强制类型转换，稍有不慎会导致bug
- 进行强制类型转换，要严格考量，数据类型的取值范围，像(byte)200这种行为是很滑稽的

> 补充

- boolean类型和其他数据类型之间不能通过强制类型转换语法直接转换
  - 0 = false ，1 = true



> 基本数据类型的类型转换，可以总结出以下规律：

- 八种基本数据类型中，只有boolean类型不能直接进行类型转换，其他七种都可以互相转换
- byte、short、char使用的时候尤其注意取值范围，若参与运算都会自动提升到int
- ”小取值范围“--->“大取值范围”称之为自动类型转换，不需要写代码处理，排序是
  - byte < short（char） < int < long < float < double
- “大取值范围”--->“小取值范围”称之为强制类型转换，必须要显式处理，否则报错
  - 需要注意强制类型转换，很容易丢失精度，慎用
- 多种数据类型混合在一起进行运算，先全部提升为“最大取值范围”的数据类型，再进行计算



>哪句是编译失败的呢？为什么呢？

```Java
byte b1 = 1, b2 = 2, b;
b = b1+ b2;
b= 1 + 2;
```



>这句代码有没有问题？
>

```Java
 byte b = 130;
```



> 思考下列程序结果
>

```Java
    System.out.println('a');
    System.out.println('a'+1);
    System.out.println("hello"+'a'+1);
    System.out.println('a'+1+"hello");
    System.out.println("5+5"+5+5);
    System.out.println(5+5+"=5+5");
    System.out.println(5 + 5.0);
    System.out.println(5+"5"+5.0);
```



> 几个启示

- 语句中1或者2都是字面值常量，字面值常量互相做运算仍然是常量。我们常说的1默认是int类型，是说可以用int类型的变量来接收它
- 强转会有精度损失，不要轻易做强转
- 运算式中会发生数据类型的自动转型，称之为“表达式的类型提升”
  - 结果必然是自动提升后的那个数据类型
  - String（字符串）在表达式中是最高的类型



## 6. 原码，反码与补码

> 有符号的数据表示法——原码，反码，补码

计算机中的数据是二进制的，不像生活中用符号表示负数一样那么简单，在计算机中，有符号数的表示分为三种

注意：所有的数据运算都是采用补码形式进行

- 原码
  - 有效数字是其绝对值的二进制表示
  - 最高位负数是0，正数是1
  - 有效数字和最高位之间用0补充
  - 除了最高位符号位外，其余位置都是数值位
- 反码
  - 正数的反码与原码相同
  - 负数的反码是对其原码逐位取反，符号位除外
- 补码
  - 正数的补码与原码相同
  - 负数的补码是在其反码上加1
  - 反码+1=补码
  - 反码=补码-1



## 7. ASCII码表

> ASCII （（American Standard Code for Information Interchange）：美国信息交换标准代码）
>
> 是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他西欧语言

| ASCII值 | 控制字符 | ASCII值 | 控制字符 | ASCII值 | 控制字符 | ASCII值 | 控制字符 |
| :------ | :------- | :------ | :------- | :------ | :------- | :------ | :------- |
| 0       | NUT      | 32      | (space)  | 64      | @        | 96      | 、       |
| 1       | SOH      | 33      | !        | 65      | A        | 97      | a        |
| 2       | STX      | 34      | "        | 66      | B        | 98      | b        |
| 3       | ETX      | 35      | #        | 67      | C        | 99      | c        |
| 4       | EOT      | 36      | $        | 68      | D        | 100     | d        |
| 5       | ENQ      | 37      | %        | 69      | E        | 101     | e        |
| 6       | ACK      | 38      | &        | 70      | F        | 102     | f        |
| 7       | BEL      | 39      | ,        | 71      | G        | 103     | g        |
| 8       | BS       | 40      | (        | 72      | H        | 104     | h        |
| 9       | HT       | 41      | )        | 73      | I        | 105     | i        |
| 10      | LF       | 42      | *        | 74      | J        | 106     | j        |
| 11      | VT       | 43      | +        | 75      | K        | 107     | k        |
| 12      | FF       | 44      | ,        | 76      | L        | 108     | l        |
| 13      | CR       | 45      | -        | 77      | M        | 109     | m        |
| 14      | SO       | 46      | .        | 78      | N        | 110     | n        |
| 15      | SI       | 47      | /        | 79      | O        | 111     | o        |
| 16      | DLE      | 48      | 0        | 80      | P        | 112     | p        |
| 17      | DCI      | 49      | 1        | 81      | Q        | 113     | q        |
| 18      | DC2      | 50      | 2        | 82      | R        | 114     | r        |
| 19      | DC3      | 51      | 3        | 83      | S        | 115     | s        |
| 20      | DC4      | 52      | 4        | 84      | T        | 116     | t        |
| 21      | NAK      | 53      | 5        | 85      | U        | 117     | u        |
| 22      | SYN      | 54      | 6        | 86      | V        | 118     | v        |
| 23      | TB       | 55      | 7        | 87      | W        | 119     | w        |
| 24      | CAN      | 56      | 8        | 88      | X        | 120     | x        |
| 25      | EM       | 57      | 9        | 89      | Y        | 121     | y        |
| 26      | SUB      | 58      | :        | 90      | Z        | 122     | z        |
| 27      | ESC      | 59      | ;        | 91      | [        | 123     | {        |
| 28      | FS       | 60      | <        | 92      | /        | 124     | \|       |
| 29      | GS       | 61      | =        | 93      | ]        | 125     | }        |
| 30      | RS       | 62      | >        | 94      | ^        | 126     | `        |
| 31      | US       | 63      | ?        | 95      | _        | 127     | DEL      |



# 文件输入与输出 Scanner&PrintWriter

```java
package com.test;
import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Scanner;

public class Test {
    public static void main(String[] args) throws IOException {
        File file = new File("C:\\Users\\AnoxiC2010\\Desktop\\Test.txt");
        Path path = Paths.get("C:\\Users\\AnoxiC2010\\Desktop\\Test.txt");
        //文件输入的两种方式
        Scanner in = new Scanner(file, "UTF-8");
//      Scanner in = new Scanner(path, "UTF-8");
        String s = "";
        while (in.hasNextLine()) {
            s = in.nextLine();
            System.out.println(s);
        }
        //文件输出
        PrintWriter out = new PrintWriter("C:\\Users\\AnoxiC2010\\Desktop\\Test.txt", "UTF-8");
        out.println("第一行");
        out.println("第二行");
        out.close();//不close的话不会写入
        //查看是否写入
        in = new Scanner(path, "UTF-8");//不新建对象的话不读取新内容
        while (in.hasNextLine()) {
            s = in.nextLine();
            System.out.println(s);
        }
        in.close();//关不关到都能输出
    }
}
```

> java.util.Scanner 5.0
>
> * Scanner(File f)
>
>   构造一个从给定文件读取数据的Scanner
>
> * Scanner(String data)
>
>   构造一个从给定字符串读取数据的Scanner
>
> java.io.PrintWriter 1.1
>
> * PrintWriter(String fileName)
>
>   构造一个将数据写入文件的PrintWriter。文件名由参数指定
>
> java.nio.file.Paths 7
>
> * static Path get(String pathname)
>
>   根据给定的路径名构造一个Path

# 循环相关break lable

除了循环也可以将标签应用到任何语句中，甚至可以应用到if语句或者块语句中，像goto，但只能跳出语句块，不能跳入语句块，不提倡。

循环中continue也可以配合lable使用

```java
lable:{
    ...
    if(condition) break lable; //exit block
    ...
}
//jumps here when the break statement executes
```

# 大数值 BigInteger & Decimal

```java
//将普通数值转换为大数值，使用静态valueOf方法
BigInteger a = BigInteger.valueOf(100);
```

> java.math.BigInteger 1.1
>
> * BigInteger add(BigInter other)
>
> * BigInteger subtract(BigInteger other)
>
> * BigInteger multiply(BigInteger other)
>
> * BigInteger divide(BigInteger other)
>
> * BigInteger mod(BigInteger other)
>
>   返回这个大整数和另一个大整数other的和、差、积、商、余数。
>
> * int compareTo(BigInteger other)
>
>   如果此大整数与另一个大整数other相等，返回0；此大整数小于另一个大整数other，返回负数；否则返回正数。
>
> * static BigInteger valueOf(long x)
>
>   返回值等于x的大整数。
>
> java.math.BigInteger 1.1
>
> * BigDecimal add(BigDecimal other)
>
> * BigDecimal subtract(BigDecimal other)
>
> * BigDecimal multiply(BigDecimal other)
>
> * BigDecimal divide(BigDecimal other RoundingMode mode) 5.0
>
>   返回这个大实数与另一个大实数other的和、差、积、商。要想计算商，必须给出舍入方式（rounding mode）。RoundingMode.HALF_UP是在学校中学习的四舍五入方式。它适用于常规的计算。有关于其他的舍入方式可查看API文档。
>
> * int compareTo(BigDecimal other)
>
>   如果这个大实数与另一个大实数相等，返回0；小于另一个大实数，返回负数；否则，返回正数。
>
> * static BigDecimal valueOf(long x)
>
> * static BigDecimal valueOf(long x, int scale)
>
>   返回值为x或x/10(scale 上标)的一个大实数。

# 数组

```java
//无论哪种创建方式，都不会跳过默认初始化的过程
//for each增强循环
//定义一个变量variable用于暂存集合collection中的每一个元素
//这个变量相当于是拷贝的元素，fori循环中拿到的直接就是集合的元素
//collection必须是数组或者实现了Iterable接口的类对象
for(variable : collection) statement

//利用Arrays类的toString方法简单打印数组中的所有值
Arrays.tostring(collection)返回形如[xx,xx,xx]的字符串
 
//利用匿名数组再不创建新变量的情况下重新初始化一个数组
int smallPrimes = {2, 3, 5, 7};
smallPrimes = new int[]{17, 19, 23, 29};

//数组拷贝
//用Arrays类的copyOf方法把一个数组中的所有值拷贝到新的数组中去
int[] numbers = {1, 2, 3, 4, 5};
int[] copiedNumbers = Arrays.copyOf(numbers, numbers.length());
//第二个参数是新数组长度，通常可利用它来增加数组长度
//多余元素被赋初始值，相反长度小于原来，则只拷贝最前面的元素
int[] copiedNumbers = Arrays.copyOf(numbers, 2 * numbers.length());

//命令行参数
//main方法的参数args可以通过在命令行执行命令语句后加入参数以String数组形式传入
//如命令行执行Hello.class：java Hello xxx xxx xxx 后面几个为args数组的元素

//数组排序
int a = new int[1000];
...
Arrays.sort(a);//升序，优化的快速排序算法
//快速打印二维数组的数据元素列表[[...],[...],...]
System.out.println(Arrays.deepToString(arrs));
```

# 生成随机数

```java
//生成随机数
//Math.random()方法返回[0,1)的随机浮点数。
int r = (int)(Math.random() * n);//返回[0,n-1)之间的随机数
//Random类生成随机数
Random randomGenerator = new Random();
int r = randomGenerator.nextInt(1000);//[0,1000)随机
```

//Math.random()方法返回[0,1)的随机浮点数。
int r = (int)(Math.random() * n);//返回[0,n-1)之间的随机数

> java.util.Arrays 1.2
>
> * static String toString(type[] a) 5.0
>
>   返回包含a中数据元素的字符串，这些数据元素被放在括号内，并用逗号分隔。
>
>   参数：a 类型为int、long、short、char、byte、boolean、float或double的数组。
>
> * static type copyOf(type[] a, int length) 6
>
> * static type copyOfRange(type[] a, int start, int end) 6
>
>   返回与a类型相同的一个数组，其长度为length或者end-start，数组元素为a的值。
>
>   参数：a 类型为int、long、short、char、byte、boolean、float或double的数组。
>
>   start 起始下标（包含这个值）
>
>   end 终止下标（不包含这个值）。这个值可能大于a.length。在这种情况下，结果为0或false。
>
>   length 拷贝的数据元素长度。如果length值大于a.length，结果为0或false；否则，数组中只有前面length个数据元素的拷贝值
>
> * static void sort(type[] a)
>
>   采用优化的快速排序算法对数组进行排序。
>
>   参数：a 类型为int、long、short、char、byte、boolean、float或double的数组。
>
> * static int binarySearch(type[] a, type v)
>
> * static int binarySearch(type[] a, int start, int end, type v) 6
>
>   采用二分搜索算法查找值v。如果查找成功，则返回相应的下标值；否则，返回一个负数值r。-r-1是为了保持a有序v应插入的位置。
>
>   参数：a 类型为int、long、short、char、byte、boolean、float或double的有序数组。
>
>   start 起始下标（包含这个值）。
>
>   end 终止下标（不包含这个值）。
>
>   v 同a的数据元素类型相同的值。
>
> * static void fill(type[] a, type v)
>
>   将数组的所有数据元素值设置为v。
>
>   参数：a 类型为int、long、short、char、byte、boolean、float或double的数组。
>
>   v 与a数据元素类型相同的一个值。
>
> * static boolean equals(type[] a, type[] b)
>
>   如果两个数组大小相同，并且下标相同的元素都对应相等，返回true。
>
>   参数：a、b 类型为int、long、short、char、byte、boolean、float或double的两个数组。

# 对象与类

## 时间对象

```java
//Date类对象描述的是一个时间点，使用距离一个固定的时间点的毫秒数（可正可负）表示的，这个点就是纪元（epoch），是UTC时间1970年1月1日00:00:00。Date类提供的日期处理是Gregorian阳历表示法。
Date now = new Date();//构造对象时的日期
//LocalDate类用来表示大家熟悉的日历表示法，不能new，要用静态工厂方法调用构造器
LocalDate now = LocalDate.now();//构造对象时的日期
//LocalDate构造特定日期的对象
LocalDate oneday = LocalDate.of(1991, 1, 1);
//LocalDate对象分别获取年月日的方法
int year = oneday.getYear();//1991
int monthValue = oneday.getMonthValue();//1
int dayOfMonth = oneday.getDayOfMonth();//1
//获取指定天数之后的新日期
LocalDate aThousandDaysLater = oneday.plusDays(1000);
year = aThousandDaysLater.getYear();//1993
monthValue = aThousandDaysLater.getMonthValue();//09
dayOfMonth = aThousandDaysLater.getDayOfMonth();//27
//Date的getDate、getMonth、getYear已被标记为不推荐使用，Date类已被标记为废弃不用
```

> java.time.LocalDate 8
>
> * static LocalTime now()
>
>   构造一个表示当前日期的对象。
>
> * static LocalTime of(int year, int month, int day)
>
>   构造一个表示给定日期的对象
>
> * int getYear()
>
> * int getMonthValue()
>
> * int getDayOfMonth()
>
>   得到当前日期的年、月、日
>
> * DayOfWeek getDayOfWeek
>
>   得到当前日期是星期几，作为DayOfWeek类的一个实例返回。电泳getValue来得到1~7之间的一个数，表示这是星期几，1表示星期一，7表示星期日
>
> * LocalDate plusDays(int n)
>
> * LocalDate minusDays(int n)
>
>   生成当前日期之后或之前n天的日期

请不要在构造器中定义与实例域同名的变量

隐式参数与显示参数：

每个方法中，关键字this表示隐式参数，在方法中直接声明的叫做显式参数。某些程序员会偏好this.xxx的风格将实例域与局部变量明显的区分开

封装

需要获得或设置实例域的值，需要提供三项内容：

* 一个私有的数据域
* 一个公有的域访问器方法
* 一个公有的域更改器方法

这样做的好处是可以更改内部实现，除了该类的内部方法之外，不会影响其他代码。

注意不要编写返回引用可变对象的访问器方法。例如Date类是有一个更改器方法setTime，结果是返回的Date对象是可变的，就破坏了封装性。如果需要返回一个可变对象的引用，应该首先对它进行克隆（clone），这样我们将返回一个可变数据的拷贝。

> 一个方法可以访问所属类的所有对象的私有域

```java
class Employee {
   ...
    public boolean isSameAge(Employee anotherEmployee) {
        return this.age == anotherEmployee.age;
    }
}
```

## 默认域的初始化

> 如果在构造器中没有显示地给域赋初值，那么就会被自动地赋为默认值（数值为0、布尔值为false、对象引用为null）。如果不明确的对域进行初始化，就会影响程序代码的可读性,这不是良好的编程习惯。如通常我们不想的到一个null的引用。

## 关闭钩 & close方法

详见API文档

# 继承

## 子类对象的初始化（initialization）

> 子类继承了父类，子类中就包含了父类的成员
>
> 那么在创建初始化子类对象时，和之前相比也会有较大的不同



> 子类创建对象过程

- JVM仍然是创建谁的对象，就加载谁，先加载子类
- 但是很快，在子类还没有加载的时候，JVM发现子类有父类
  - 父类如果不存在，子类肯定也不可能存在
- 于是JVM调转枪头，开始加载父类
- 加载完父类，再加载子类
- 类加载都结束后，开始创建堆上的对象
- 堆上的对象中，会有一片空间，用来存放父类的成员
  - 子类对象就由两部分组成
  - 一部分是子类自己独特的成员
  - 另一部分是从父类继承过来的成员
- 现在堆上就真实存在了一个子类对象
  - 子类对象中存放父类成员的内存区域，可以近似的看成是一个父类对象
  - 所以子类的内存图，近似看成子类对象“装着”父类对象
  - 注意，这个父类对象只是近似看作，不会真的创建了父类对象
    - 创建子类对象，只会类加载父类，不会真的创建父类

> 仍然有一个棘手的问题

- 子类对象中的，父类成员变量和子类自身成员变量，谁先初始化默认初始值？
  - 答：先给父类成员变量默认初始化，再默认初始化子类
  - 为什么？答：先父后子，没毛病，首先要有父亲，才有儿子
  - 其次，子类成员变量的初始化，可以依赖父类成员变量
    - 这个时候如果子类先初始化，显然是要报错的



> 问题仍然没有结束

- 子父类的类加载顺序是由JVM去保证的，但是子父类的初始化先后顺序又是怎么保证的呢？
- 它的原理是什么呢？

> 我们已经知道了构造器是可以用来初始化成员变量，会由JVM自动调用
>
> 用构造器去保障这种先后顺序，怎么做呢？

- 答：只需要在子类的构造器的第一行，调用父类构造器就可以了

​	 

> 我们没有自己手动在子类构造器的第一行，调用父类构造器，但是仍然达成了先初始化父类
>
> 再初始化子类的效果，是什么原因呢？
>
> 显然这里存在了一个隐式调用，于是子类对象的初始化就有了两种方式

- 隐式的调用了父类构造方法（JVM保证）
- 程序员显式的调用父类构造方法（代码保证）

## 显隐式子类初始化

> 重点学习一下两种方式

### 子类对象的隐式初始化（implicit）

> 隐式初始化，JVM自动调用，无需我们手动操作
>
> 条件为

- 父类中有默认的构造方法
  - 子类的构造器中没有显式调用父类的构造方法
- 达成上述两个条件，则JVM在初始化子类对象时进行隐式初始化

  - 永远先执行父类的构造方法，顺序为
    - 最上层的父类（Object）
    - 其他父类（继承链中越处于上流越先执行）
  - 所有父类的构造方法都执行完毕，开始执行子类构造方法

> 需要注意的是
>
> - 隐式初始化，JVM总是调用父类的无参构造，如果父类没有，就要报错
> - Object类也有默认无参
> - 隐式初始化总是不传参数，如果我们想要对参数进行赋值，就必须使用显式的子类初始化

### 子类对象的显式初始化（Explicit ）

> 显式初始化，需要程序员手动写代码，告诉JVM调用哪个父类构造器
>
> 如何使用？

- 必须在子类构造器的第一行，显式的调用父类构造方法，那么如何调用父类构造器？

  - 使用super关键字调用

  - 语法

    ```Java
    super(父类构造器参数);
    ```

> 什么是super关键字？

- super代表当前类的父类"对象"的引用
- this代表当前类的对象
- 两者的使用没有明显差别，只是
  - this在当前类中不受访问权限控制，super访问父类成员，受访问权限控制
  - 因为当前类中即便是private仍然可以访问，但是super就不在当前类中了

```
this VS super  

this关键字：表示当前对象的引用         super关键字：super代表父类对象的引用

this调用当前类中定义的构造方法：this(实参列表)          
super调用父类中定义的构造方法：super(实参列表)

this访问当前对象的成员变量值          super访问父类对象中，成员变量的值

this访问当前对象的成员方法            super访问父类对象，成员方法                            
```



super与this关键字

this关键字概念：

this代表所在类的对象引用。

记住： 方法被哪个对象调用，this就代表哪个对象。

1.super可以在子类中 调用父类中名称相同的 成员方法和成员变量

2.this可以在方法中调用 类中的与方法内局部变量名称相同 的成员方法和成员变量

3.super和this的区别

(a).this 代表当前类的对象

代表对象的内存空间标识（用来存储当前类定义的内容，成员变量、方法）

(b).super （代表父类对象） 可以这么理解，实际并不代表父类对象

代表对象的内存空间的标识（用来存储父类定义的内容，成员变量、方法）

使用场景：

当局部变量和成员变量名字相同时用this，子类变量和父类变量名字相同时用super

super用法：（this和super均适用）

1.访问成员变量

this.成员变量  super.成员变量    （局部变量直接调用不需要修饰符）

2.访问构造方法

 this(…)           super(…)        如果是有参方法，()里面写参数

3.访问成员方法

this.成员方法()  super.成员方法()



隐式子类对象创建：

​	条件： 

​		a. 当父类提供了默认的构造函数(无参构造方法)

​        b. 子类的构造方法中, 没有显式调用父类的其它构造方法

​	结果：

​		JVM自动在子类构造方法第一句加上  “ super() “

​		在执行子类的构造方法之前，JVM会自动执行父类

​	

显式子类对象创建：

​	程序员写代码告诉JVM在调用子类构造器之前调用父类构造方法

​	可以在子类构造器的第一行使用super关键字，调用父类的构造方法

​		

总结：

​	1，无论是隐式还是显式，最终都是为了保证父类构造器先于子类执行

​	2，若父类中不存在默认构造方法，则必须在子类构造方法中使用super关键字调用父类构造器

​	3，在子类构造方法中，super语句必须在第一行

​	4，在子类构造方法中，也可以用this调用自身构造，也必须在第一行

​	5，this和super不能共存

​	6，构造代码块和静态代码块也是“先父后子”



为什么this和super都必须在第一行？

​	因为子类构造器第一行永远都有一个super关键字调用，如果你自己的super和this不在第一行，会形成循环

## 子类的属性隐藏（field hidden）

> 子父类中能否拥有同名的属性呢？
>
> 如果可以，请尝试

- 创建子类对象，使用对象名点的形式访问同名变量，结果是什么？
- 创建子类对象，在子类中，编写方法，返回该属性
  - 用子类对象调用该方法，返回的结果是？
  - 方法的就近原则
- 创建子类对象，在父类中，编写方法，返回该属性
  - 用子类对象调用该方法，返回的结果是？
  - 方法的就近原则
- 最终我们发现，子类可以访问到父类的成员变量
  - 但是由于编译器检索机制的限制，好像父类的属性被隐藏了一样
  - 称之为子类的属性隐藏





> 如果我就想在子类方法中，访问父类的同名成员变量，怎么办？

- super关键字





> 对象名点成员变量名的，编译器检索机制

- 先从子类本身中去找---->子类中找不到再去父类中找----->再找不到就报错
- 但是一般来说，我们都是通过方法访问成员变量



> 注意事项

- 静态成员变量也可以被继承，但是静态成员变量如果是同名的，是一个全新的，会覆盖掉原先的静态成员
- 子类父类的同名静态成员各自独立属于自己的类，如果子类没有便完全继承父类的静态成员

## 子类的方法覆盖（override）

> 子父类中能否拥有同名的方法？
>

- 在父子类中声明两个个一模一样的方法，但是方法体输出不同
  - 创建子类对象，直接调用该方法，结果是什么？
- 再在父子类中定义两个方法，分别在方法体中调用自身方法名一样的方法
  - 创建子类对象，分别调用两个方法，结果是什么？
- 我们发现无论怎么操作，都只能访问子类中的同名方法，这就是方法的覆盖



> 如果想在子类的方法中，访问父类方法，应该怎么办？

- super关键字



> 对象名点方法访问的方式，编译器的检索机制

- 先从子类本身中去找---->子类中找不到再去父类中找----->再找不到就报错



> 什么时候使用方法的覆盖？

- 当我们需要在子类中，修改父类方法的实现的时候
- 使用方法的覆盖时，添加@Override注解来标记
- 例如：比如对于动物的叫，人类的吃



> 方法覆盖的注意事项

- 父类中私有方法不能被重写
- 子类重写父类方法时，访问权限不能更低
- 静态方法在使用现象上，很像是被重写了，但实际上静态方法不能被重写，而是直接是一个新的静态成员



- 重写 VS 重载

|              | 重载（overload） |                      重写（override）                       |
| :----------: | :--------------: | :---------------------------------------------------------: |
| 发生的类不同 |   发生在同类中   |               发生在子父类之间,肯定不是一个类               |
|    方法名    |     必须相同     |                          必须相同                           |
|   参数列表   |     必须不同     |                          必须相同                           |
|  权限修饰符  |      不影响      |            重写的方法访问权限必须大于等于原方法             |
|     异常     |      不影响      |                重写的方法不能抛出更多的异常                 |
|  返回值类型  |      不影响      | 重写的方法的返回值类型必须和原方法兼容,代表可以不是完全一致 |

- 被static、final、private修饰的父类方法无法被重写

## final和限制继承

> final是一个修饰符，可以用来修饰类、方法和变量（包括成员变量和局部变量）

### final修饰类

> 表示”最终的类“
>
> 当用final修饰一个类时，表明这个类不能被继承

- 除了这一点外，这个类照常使用，比如创建对象，比如访问方法，比如继承别的类
- 从设计角度来讲，一个final修饰的类应该是
  - 不需要复用成员
  - 功能已经特别强大，足够满足需求
  - 需要绝对的保证安全，以致于不让它被继承
- 常见的final类
  - String
  - System
  - Math
  - 所有基本数据类型的包装类和一个Void
    - Boolean，Character，Short，Integer，Long，Float，Double，Byte，Void
- 除非你十分确定这个类以后不会被用来继承 ，为了保证安全，可以设置一个类为final类
  - 不然一般情况下，尽量不要把一个类设置成final

### final修饰方法

> 表示”最终的方法“
>
> 当一个方法被final修饰后，可以被继承，但是无法被重写

- final修饰方法，就把方法锁住了，任何继承这个方法的类都无法覆盖该方法
- 如果一个方法已经能够满足需求，并且明确知道它不应该被修改，修改会产生问题
  - 可以将方法设置成final方法
  - 否则，正常情况下，不要随便使用final修饰方法

### final修饰变量

> 表示”最终的变量“，是一种自定义常量，普遍来说，命名应该采用全大写，下划线连接的方式
>
> 修饰变量是final用得最多的地方，也是可能混淆的地方
>
> 总体来说，final修饰变量后
>
> - 如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改
> - 如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象
>   - 因为final修饰的是引用，而引用中装的是地址
>   - 但是其引用的对象的状态是可以改变的

#### final修饰普通成员变量

- final修饰普通成员变量，表示常量，在整个创建对象过程中它们的值，只能修改一次也必须显式赋值一次
- 总结给普通成员变量赋值的方式
  - 显式初始化语句
  - 构造代码块
  - 构造器
  - 创建对象后，调set方法，或者直接赋值
  - 对于final修饰的普通成员变量，前三种必然要有一种
- 对于同一个类的同一个final修饰的变量，不同对象可能会有不同的值

#### final修饰静态成员变量（常用）

- final修饰静态成员变量，表示全局常量，在整个静态成员赋值过程中，只能修改一次也必须显式赋值一次
  - 访问一个类的基本数据类型和String类型的final静态全局常量不触发类加载
  - 被所有对象共享，每个对象都必须有同一个值，且不可改变
- 给final静态成员变量赋值
  - 显式赋值语句
  - 静态代码块
- final static 还是static final？
  - 建议用static final
- 静态常量一般全部大写，用下划线隔开

#### final修饰局部变量

- 在方法体和方法参数列表中定义final常量，表示该常量不可更改
- 必须显式的赋值初始化，不然也没别的方式初始化了
- 在形参列表中声明final常量，表示该参数是一个常量，在接收后无法修改

#### 特别的final修饰引用数据类型

- 表示引用指向的对象不可变，但对象的状态可变
- 例如final修饰Student类型的变量s，则s的地址值不能改变，
- 也就是说s要始终指向同一个对象。  但是所指对象的属性值可以改变，只要对象的地址不变即可



final修饰匿名对象 会咋样？

final new Student() 语法不允许



```
final修饰普通成员变量，表示常量，创建对象的时候，也只能初始化它的值一次，这个过程中也不能改了。创建对象以后，它们的值就不可改变了
```



- 对于一个final变量
  - 构建对象之后，它们的值就不可以被修改了
  - 如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改
  - 如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象
- 使用final修饰一个基本数据类型变量，该变量就变成了常量，只能被赋值初始的一次
  - 自定义常量，无法在程序执行时改变
  - 对于常量，我们最好static final一起使用
- 对于基本数据类型而言，final修饰后，值就不可变了
- 对于引用数据类型而言，final修饰后，引用的地址就不可变了，但引用对象的状态可以改变



> 注意：

- 常量必须显示初始化，即必须赋值一次，不用能默认值。
- 只能赋值一次，即使之后的赋值和原来的值一样也不行
- 在静态常量在常量池中，使用不需要类加载，静态常量需要创建对象赋初值的，使用需要类加载

# 多肽

## 多态的引入（polymorphism）

> 什么是多态？

- 某同一个事物，在不同的时刻表现出不同的状态

  - 对于Java而言，指的是同一个类型引用，在指向不同的具体对象时，运行时表现不同的行为

  - 其实就是父类引用指向了不同的子类对象

  - 例如

    - ```Java
      Animal a = new Cat();
      Animal a = new Dog();
      ```

- 多态的前提条件

  - 要有继承关系
  - 继承后发生子父类的方法重写
  - 父类的引用指向子类的对象

- 不能发生多态的情况

  - 不能够被继承，final类
  - 不能被方法覆盖
    - final方法
    - static方法
    - private方法
    - 构造方法无法被继承

- 当父类的引用，指向不同的实际对象时，调用方法，结果不同

- 写一个方法，参数列表为父类引用，可以传入具体的对象

  - 多态对程序的扩展性

## 多态的访问特征

> 发生多态后，通过引用调用成员的方式发生了改变
>
> 父类 引用 = new 子类();

- 对于成员变量而言
  - 编译时看左边，运行时看左边
  - 也就是说成员变量是没有“多态”的（因为多态的前提就是发生方法重写）
  - 多态现象是发生在方法之间，和成员变量没有关系
- 对于成员方法而言
  - 编译时看左边，运行时看右边

> 解释
>
> 父类 引用 = new 子类();

- 编译看左边
  - 编译看左边是说通过引用变量可以访问到的子类成员的范围
    - 是由引用类型来决定的，也就是说由父类中定义的成员决定
  - 我们只能通过引用去访问，堆上的对象，引用中必然装有该类型对象的成员信息
  - 只有通过引用变量，我才能访问到堆上的对象
    - 也就是说，对象的访问受限于引用变量本身的类型



> 解释方法的多态性，一个很贴切的例子

- 我家中的一台电视机，贼贵，功能很丰富
- 对于电视机而言，我们只能使用，遥控器去操作电视机
- 这也就是说，只有遥控器上提供的功能我们才能使用
  - 即便电视机本身功能多么强大，如果遥控器上只有音量键，那我们也毫无办法
  - 遥控器有啥功能，决定了我们能使用的功能
- 即使电视机本身功能再丰富，没有遥控器的支持，我们啥也用不了

> 把这个例子转换到Java程序中

- 电视机就相当于对象本身，而遥控器就是引用变量
- 实际对象的功能再强大，如果引用中没有这个功能，那也无法调用该功能
- 对象的行为，受限于引用变量，和对象本身没有直接关系
- 对象的引用类型决定了可以访问对象的成员范围
- 编译时看左边，运行时看右边



> 解释成员变量不具有多态性，一个例子

- 成员变量描述的是对象的“外貌特征”
- 把子类对象赋值给父类类型的引用，就相当于给子类对象披上了一个父类类型马甲
- 外貌特征上来看，这时候的子类就变成了父类
- 编译时看左边，运行时看左边

​	

## 多态的优缺点

- 多态的优点：
  - 要实现多态，必须要继承，提高了程序的可维护性（继承保证）
  - 发生多态后，同一个引用调用方法产生不同的行为
    - 提高了程序的简洁性和扩展性（多态保证）

- 多态的缺点：
  - 不能访问子类特有的功能

## 引用类型的类型转换

> 基本数据类型之间是可以发生数据类型转换的，引用数据类型也是可以的
>
> 但是引用数据类型发生转换的条件比较苛刻，出错后的问题也更严重
>
> 做引用数据类型的转换 小心小心再小心



引用数据类型要发生类型转换

- 前提：具有父子关系的两个类型之间
- 没有父子关系的两个类型之间不能发生类型转换，通过不了编译

### 自动类型转换

- 子类的引用转换成父类的引用，在继承链中属于向上，编译器默认允许

  - 称之为自动类型转换或者向上转型

  - 语法

  - ```java 
    父类 引用名 = new 子类();
    ```

  - 子类一定可以看成父类，所以能够自动转型

  - 向上转型是安全，可以放心使用

### 强制类型转换

- 父类的引用转换成子类的引用，在继承链中属于向下，编译器默认不允许，需要显式强行转换

  - 称之为强制类型转换或者向下转型

  - 语法

  - ```java
    子类 引用名 = (子类)父类引用;
    ```

  - 子类继承和扩展了父类，父类大多数情况下都不能看成子类，所以需要强制类型转换

  - 重要前提：强制类型转换若想成功，必须是该父类引用指向的对象本身就是一个要强转的子类对象



- 强制类型转换是不安全的，要想转型成功，必须真实的对象和要转型的类型一致

  - 父类引用指向的不一定就是那个你要强转的子类的对象
  - 比如动物类的引用指向了一个猫对象，现在把引用强转成一个狗引用，能成功吗？

- 为了保障安全，向下转型推荐使用instanceof关键字校验

  - 语法

  - ```Java
    引用名 instanceof 类名
    ```

  - 这个表达式返回一个布尔类型的值

    - true代表该引用指向的对象，是一个后面类名的对象
    - null instanceof 任何类 结果都是false



### ClassCastException

> 强制类型转换一旦失败，就会抛出ClassCastException，程序报错终止

- 没有人会故意给自己找麻烦
- 不到万不得已，不要使用强制类型转换

## 子类实例化和多态案例

```java
public class Demo {
    public static void main(String[] args) {
        Father f1 = new Son(1000);//0
        Father f2 = new Father();//10
        Son s = new Son(1000);//0
    }
}

class Father {
static int f = 2;//父类静态成员
static {
    f = 3;//父类静态代码块
}
    int i = 10;//父类成员
    {
        i = 11;
    }
    public Father(int i) {

    }

    public Father() {

        System.out.println(getI());
    }

    public int getI() {
        return i;
    }
}

class Son extends Father {
    static int s = 5;//子类静态成员
    static {
        s = 6;//子类静态代码块
    }

    int i = 100;
    {
        i = 101;
    }
    public Son(int a) {
        this.i = a;
    }

    public int getI() {
        return i;
    }
    public Son() {

    }
}

```

# 抽象类（abstract）

> 抽象类定义
>
> 在继承体系中，从祖先类开始，随着一个个子类的定义，子类变得越来越具体
>
> 而祖先类则更具有一般性和抽象性
>
> 在这种情况下，为了体现祖先类在设计上的抽象性
>
> 我们只将该类作为派生其他类的父类，而不能创建对象实例
>
> 这个时候，这样的类，我们称之为抽象类

- 抽象类使用abstract关键字标记

  - ```Java
    [访问权限修饰符] abstract class 类名{
    }
    ```

- 表示该类是一个抽象类

- 抽象类无法被实例化，抽象类不能实例化，但是开发中会提供子类，可以用多态的方式访问

- 抽象方法使用abstract关键字标记

  - ```Java
    [权限修饰符] abstract 返回值类型 方法名();
    ```

  - 表示该方法是一个抽象方法

  - 抽象方法必须在一个抽象类中

  - 抽象方法没有方法体，只有方法声明，不要忘记写分号



> 接下来，我们重点来研究一个抽象类的特点和使用
>
> 我们从下面两个角度分析

- 抽象类的成员
  - 成员变量
  - 成员方法
  - 构造方法
- 抽象类的子类



> 抽象类的成员特点：

- 抽象类具有普通构造方法，成员变量和成员方法

- 抽象类具体普通类都可以有的成员变量，静态成员变量，常量
- 抽象类可以有抽象方法，也可以有普通方法
  - 抽象方法起着占位的作用，该方法必须在子类中实现
  - 抽象方法不能是private、static、final修饰的
  - 普通方法可以作为一个默认实现，子类可以使用这个方法，也可以自行重写
  - 抽象类中可以没有抽象方法，这样做的目的是不让创建对象
    - 但是一般不要这么做，抽象类是一个设计上的概念，应该从设计上正确的使用它
    - 如果仅仅是为了不让外界创建对象，私有化构造方法即可
    - 普遍来说，既然是抽象类就应该有抽象方法，不然没啥意义
- 抽象类虽然不能实例化，但仍然有构造方法
  - 抽象类中的构造方法是留给子类初始化时调用的
  - Java当中，只要是类都具有构造方法
- 总结抽象类成员
  - 构造方法：同普通类
  - 成员变量：同普通类
  - 成员方法：可以是抽象方法，也可以是非抽象方法



>  抽象类的子类的特点：

- 抽象类的子类可以是抽象类，也可以是具体类
- 只有当子类重写了，所有的继承自抽象类的方法，该子类才能被定义为具体类
- 反之，若任一抽象方法没有被重写，该类都必须定义为抽象类



> abstract关键字使用上的注意点（notice）

- 不能用来修饰构造器、属性、代码块等结构
- 不能用来修饰final类
  - 无法被继承的类
- 不能用来修饰私有方法、静态方法 、final方法
  - 无法被重写的方法
- 一个抽象类中可以没有抽象方法，但是意义不是很大

# 接口



- 一方面，我们有时需要从多个类中派生出一个类，继承它们所有的成员，Java语法不适用
  - Java不支持多继承
- 另一方面，我们有时候需要从几个类中抽取出共同的行为特征
  - 而它们之间并没有“is-a”关系，继承思想显得不适用

> 于是：

- 为了复用这些“特殊行为”，我们迫切需要一种新的数据格式
  - 和类相似，可以抽取出共性，定义成员
  - 不受Java多继承限制
- 这种新的数据格式就是接口



> 接口的定义

- 语法

  ```java 
  [访问权限修饰符] interface 接口名{}
  ```

- 接口不是类，而是一种独立的数据类型，和class并列

  - 一个类实现的接口，也称之为接口的子类

- 一个类继承接口，称之为实现接口，使用关键字implements

  - 语法

    ```Java
    class 类名 implements 接口名 {}
    ```

  - 当一个类继承另一个类的同时，又实现接口

    - 必须要将实现接口放在继承类后面



> 接口概述

- interface表示一种数据类型，和class同级别
  - 是一种引用数据类型
  - 区别是：
    -  类定义的是一个数据集合基于这个数据集的一组操作(行为)
       - 类所描述的这一组行为，它们是有关系的（间接），都可以访问同一个数据集合
    -  接口表示数据类型，侧重于描述一组具有特殊功能的行为，这些行为
       - 可以完全没有任何关系。接口中的方法，它们的关系比较的松散
  - 类实现接口本质上也是一种继承，接口的实现类是接口的子类
  - 接口不能实例化
  - 接口不受多继承限制，接口可以多实现



> 接口的声明特征

- 接口的声明中默认存在一个abstract，所以接口必然是抽象的
- 接口普遍声明为public 鼓励继承



> 接口的成员特征：
>
> - 成员变量
> - 成员方法
> - 构造方法

- 接口中的所有成员变量都默认是由public static final修饰的

  - 无法使用除public外的访问权限修饰符，修饰成员变量
  - 普遍来说，开发时在接口中定义成员变量省略public static final
  - 但是接口内部不支持用static代码块给成员变量初始化
    - 必须要提供显式的初始化

- 接口中的所有方法都默认是由public abstract修饰的

- （了解即可）在JDK8中引入了默认方法

  - 语法

    ```java 
    default 返回值类型 方法名{
    }
    ```

  - 默认是public修饰

  - 不能用static、abstract修饰

  - 和抽象类中的具体方法一样，接口中的方法是给子类提供了一个默认实现

    - 子类可以选择直接继承使用该方法，也可以重写
    - 可以用子类对象调用，包括多态形式

  - 抽象类中有普通方法是很正常的，但是接口中不应该有具体方法，除非

    - 为了代码的兼容考虑
    - 例如class A、B、C很多类都实现了接口ITest，现在给接口新增了一个方法
      - 但这个方法不是所有类都需要重写的
      - 如果这个方法是一个抽象方法，所有类都必须实现该方法，否则会报错
      - 为了省事，可以选择default方法
      - 实际上Java8之所以引入default方法就是为了做这种事情
      - 省事是Java开发者省事，你不要省事

- （了解即可）在JDK8中引入了静态方法

  - 语法

    ```Java
    static 返回值类型 方法名{
    }
    ```

  - 默认是public修饰

  - 不能用abstract、default修饰

  - 可以使用接口名点方法名访问

- 从技术角度来说，以上实现方法是完全合法的

  - 只是它看起来违反了接口作为一个抽象定义的理念
  - 除非特别有必要，不要使用

- 接口没有构造方法，接口中的成员变量都是常量，不需要子类调用构造方法来初始化



> 接口的子类特征：

- 如果是一个类实现了接口
  - 必须要重写接口中所有的抽象方法，除非该类是一个抽象类
  - 一个类实现了接口，就变成了接口的子类
  - 接口可以多实现，配合default方法可以实现真正意义上的多继承（最好不要这么干）
  - 如果一个类又继承类又实现接口，一定是先继承再实现，顺序不能互换
- 如果是一个抽象类实现了接口
  - 可以不重写接口中的抽象方法
  - 可以实现多个接口而不重写方法
  - 抽象类也可以继承普通类
- 如果一个接口继承了接口
  - 接口之间不能互相实现，但是可以继承
  - 接口可以多继承



> 接口使用注意事项：

- 定义Java类的语法格式：先写extends，后写implements

  - ```Java
    class SubClass extends SuperClass implements InterfaceA{
    } 
    ```

- 一个类可以实现多个接口，接口也可以继承其它接口，这就是Java当中的“多继承”

- 实现接口的类中必须提供接口中所有方法的具体实现内容，方可实例化。否则，仍为抽象类

- 接口的主要用途就是被实现类实现

  - 所以接口和接口的成员默认都是public修饰，鼓励继承，鼓励重写

- 与继承关系类似，接口与实现类之间存在多态性

- 接口和类是并列的数据类型



> 接口和抽象类的异同

| 编号 | 区别点 |                            抽象类                            |                   接口                    |
| :--: | :----: | :----------------------------------------------------------: | :---------------------------------------: |
|  1   |  定义  |                       包含抽象方法的类                       |         抽象方法和全局常量的集合          |
|  2   |  组成  |           构造方法、抽象方法、普通方法、常量、变量           | 常量、抽象方法、(jdk8:默认方法、静态方法) |
|  3   |  使用  |                   子类继承抽象类(extends)                    |         子类实现接口(implements)          |
|  4   |  关系  |                    抽象类可以实现多个接口                    |  接口不能继承抽象类，但允许继承多个接口   |
|  5   |  对象  |                 不能创建对象，但是有构造方法                 |       不能创建对象，也没有构造方法        |
|  6   |  局限  |                      抽象类不能被多继承                      |       接口之间能多继承，能被多实现        |
|  7   |  思想  |                  作为模板或对共性抽象，is-a                  |     作为标准或对共性能力抽象，like-a      |
|  8   |  选择  | 如果抽象类和接口都可以使用的话，优先使用接口，因为避免单继承的局限 |                                           |



Java提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于：

- 接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。
- 类可以实现很多个接口，但是只能继承一个抽象类
- 类如果要实现一个接口，它必须要实现接口声明的所有方法。但是，类可以不实现抽象类声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。
- 抽象类可以在不提供接口方法实现的情况下实现接口。
- Java接口中声明的变量默认都是final的。抽象类可以包含非final的变量。
- Java接口中的成员方法默认是public的。抽象类的成员方法可以是private，protected或者是public。



​	接口就是这样的一种规范，它抽取了事物的相似行为，而不关心事物有什么关系

​		1，相比于继承抽象类的“is-a”关系，体现的是“是XX”思想，而实现接口体现的是“能够XX”的思想

​		2，接口允许多实现。实现多个接口，继承它们所有的属性和方法

​		3，接口的本质是契约、规范、标准



> 接口和抽象类形式参数和返回值问题

****

> 方法的形式参数（formal）在传值的时候

1.基本类型：对于基本数据类型的方法传参，存在自动类型提升

2.引用类型： 对于引用数据类型的方法传参，存在自动向上转型

- 类：调用方法时需要传入的是该类的对象或者该类的子类对象
- 抽象类：调用方法时需要传入的是该抽象类的子类对象
- 接口：调用方法时需要传入的是该接口的子类对象



> 方法的返回值类型

> 父子类方法重写中，方法声明中返回值类型的书写

1.基本类型：必须保持一模一样，不存在类型提升

2.引用类型：不必保持一模一样，存在自动向上转型

- 类：父类中的方法返回一个普通类类型
  - 子类方法中可以返回该类型
  - 也可以返回该类的子类类型
- 抽象类：父类中的方法返回一个抽象类类型
  - 子类方法可以返回该类型
  - 也可以返回抽象类的实现类类型
- 接口：父类中的方法返回一个接口类型
  - 子类方法可以返回该类型
  - 也可以返回接口的实现类类型

> 在方法中书写一个具体的返回值

1.基本类型：方法体中，返回一个具体的值的时候，存在自动类型提升

2.引用类型：方法体中，返回一个具体对象的时候，存在自动向上转型

- 类：返回该类的对象或者该类的子类对象
- 抽象类：返回抽象类的（具体）子类对象
- 接口：返回接口的（具体）子类对象

​	

C.链式调用（chain calls）

```java 
StudentDemo sd = new StudentDemo();
Student s = sd.getStudent();
s.show();
//类似这种形式的代码，可以写成链式调用的形式，就变成了
new StudentDemo().getStudent().show();
//结果是一样的
```

> 在Java API中，会看到很多接口都有相应的伴随类，这个伴随类中实现了相应接口的部分或所有方法，如Collection/AbstractCollection或MouseListener/MouseAdapter。在Java SE 8中，这个技术已经过时。现在可以直接在接口中实现方法。
>
> Java SE 8中，允许在接口中定义静态方法和默认方法。

> 默认方法冲突
>
> 如果先在一个接口中将一个方法定义为默认方法，然后又在超类或另一个接口中定义了同样的方法，规则如下：
>
> 1. 超类优先。如果超类提供了一个具体方法，同名而且有相同参数类型的默认方法会被忽略。确保了Java SE 7的兼容性。
> 2. 接口冲突。如果一个接口提供了一个默认方法，另一个接口提供了一个同名而且参数类型（不论是否是默认参数）相同的方法，必须覆盖这个方法来解决冲突。

> 警告：不要让一个默认方法重新定义Object类中的某个方法，如为toString或equals定义默认方法。由于“类优先”规则，这样的方法绝对无法超越Object.toString或Objects.equals。

## 接口与回调

> javax.swing.JOptionPane 1.2
>
> * static void showMessageDialog(Componenet parent, Object message)
>
>   显示一个包含一条消息和OK按钮的对话框。这个对话框将位于parent组件的中央。如果parent为null，对话框江西那是在屏幕的中央。
>
> javax.swing.Timer 1.2
>
> * Timer(int interval, ActionListener listener)
>
>   构造一个定时器，每个interval毫秒通告listener一次。
>
> * void start()
>
>   启动定时器。一旦启动成功，定时器将调用监听器的actionPerformed。
>
> * void stop()
>
>   停止定时器。一旦停止成功，定时器将不再调用监听器的actionPerformed。
>
> java.awt.Toolkit 1.0
>
> * static Toolkit getDefaultToolkit()
>
>   获得默认的工具箱。工具箱包含有关GUI环境的信息。
>
> * void beep()
>
>   发出一声铃声。

## Comparable<T>和Comparator<T>接口

> Comparable<T> 是一个功能接口，里面有个compareTo方法，实现了这个功能接口的类可以用Arrays.sort(Object o)或者Collections.sort(Object o)进行自然排序
>
> 但是别人已经写好的类要我们自然排序的话需要改别人的源代码实现接口，实现Comparable<T>接口还要同时重写保证equals方法的一致性，因为某些集合的操作用compartTo判断不相等但用equals判断相等的话也不能插入。
>
> 所以还可里利用Comparator<T>接口不用修改原有代码的情况下实现自然排序：
>
> Arrays.sort(T[] a, Comparable<? super T> c)直接用Lambda表达式或者匿名内部类写法
>
> 比较功能代码量多的话可用Lambda表达式指向某个已经实现的方法写法简便
>
> java.lang.Comparable<T> 1.0
>
> * int compareTo(T other)
>
>   用着个对象与other进行比较。如果这个对象小于other则返回负值；如果相等则返回0；否则返回正值。
>
> java.util.Arrays 1.2
>
> * static void sort(Object[] a)
>
>   使用mergesort算法对数组a中的元素惊醒排序。要求数组中的元素必须属于实现了Comparable接口的类，并且元素之间必须是可比较的。
>
> java.lang.Integer 1.0
>
> * static int compare(int x, int y) 7
>
>   如果x<y返回一个负整数；如果x和y相等，则返回0；否则返回一个负整数。
>
> java.lang.Double 1.0
>
> * static int compare(double x, double y) 1.4
>
>   如果x<y返回一个负数；如果x和y相等则返回0；否则返回一个负数。

比如String类实现了Comparable<String>，而且String.compareTo方法可以按字典顺序比较字符串。当我们希望按长度递增的顺序对字符串进行排序，而不是按字典顺序，肯定不能让String类用两种不同的方式实现compareTo方法。何况String 类不应该有我们来修改。

于是用Arrays.sort(T[] a, Comparable<? super T> c)，该版本需要一个数组和一个比较器为参数，比较器就是实现了Comparator接口的类的实例。

> Comparator接口包含许多静态方法来创建比较器，这些方法可以用于lambda表达式或方法引用。但我目前看不懂

# 内部类



[TOC]

> 我们现在做一个应用程序，需要描述一台电脑（Computer）中的CPU，对于电脑而言
>
> 该怎么去描述这个CPU呢？

- 它有存储设备，IO设备等等很多硬件资源组件
- CPU是电脑中最重要的组件



> 这个CPU具有以下特点：

- CPU可以调控计算中的所有硬件资源
  - CPU应该设计成一个类，并且是作为一个私有成员存在于计算机内部
- CPU需要被隐藏起来，不能直接暴露在外部，也不能独立于计算机存在
  - 根据我们现在的知识，无法实现这一点
  - 因为声明一个普通类，无法声明为private修饰
- 这个时候就想到能不能直接把CPU类丢到Computer类的内部呢？
  - 这样，有一层壳子，就能够很好的保护CPU
  - 这种嵌套定义的类，就是内部类



> 内部类的定义

- 在Java语言中类可以嵌套定义，内部类（inner class）是定义在另一类当中的类



> 内部类的概述

- 按照内部类在类中定义的位置不同：
  - 定义在成员位置的内部类，称之为成员内部类，普通成员内部类，静态内部类
  - 定义在局部位置的内部类，局部内部类，匿名内部类
- 内部类是典型的，Java从C++中拿过来但是没有经过简化的特性
  - 也就是说Java几乎照搬了C++中的内部类
  - 通过内部类可以稍微感受一下C++的语法复杂性

- 为了上课方便，我们需要统一口径，在内部类课程当中，我们统一规定
  - 像Cpu这种类我们称之为内部类（inner class）
  - Computer这种类我们称之为外围类（enclosed class）
  - Demo这种类我们称之为外部类（outside class）



## 成员内部类

> 成员内部类概述

- 成员内部类是最普通的内部类，它定义在另一个类的成员位置， 可以看成该类的一个成员

- 语法

- ```java 
  [访问权限修饰符] class EnclosedClazz{ //外围（普通）类的访问权限修饰符，只有两个，public和缺省
  	[访问权限修饰符] class InnerClazz{//内部类访问权限修饰符，有四个，和普通成员一样
      }
  }
  ```






### 成员内部类自身特点

> 成员内部类自身的特点
>
> 1，访问权限修饰符
>
> 2，成员特点
>
> 3，继承和实现



#### 权限修饰符

> 成员内部类的访问权限修饰符可以是

- public
- protected
- （default）缺省
- private



#### 成员特点

> 成员内部类的成员特点
>
> 成员变量
>
> 成员方法
>
> 构造器

- 可以定义普通成员变量，成员方法
  - 不能定义静态方法、静态成员、静态代码块
  - 可以定义全局常量（因为全局常量是编译时就加入了常量池，不触发类加载）
- 可以定义构造方法，和普通类并无差别



> 成员内部类类加载机制（重要）

- 成员内部类的类加载机制（重要）
- 成员内部类的类加载要靠创建内部类对象触发，因为成员内部类没有静态成员
  - 一个外围类中定义了成员内部类后，并不代表每个外围类对象中都会自动初始化一个内部类对象
  - 只有在外围类对象的基础上，创建内部类的对象，才会触发成员内部类的类加载
  - 也就是说，成员内部类对象依赖于外围类的对象（即成员内部类实例化是在外围类实例的基础上）
    - 任何时候都是这样，即便是反射，也没办法不创建外围类对象而创建成员内部类对象
- 成员内部类对象依赖于外围类对象而存在



#### 继承和实现

> （了解）成员内部类的继承和实现

- 内部类可以继承和实现外部的类和接口
- 甚至可以在类中定义多个普通类、抽象内部类和接口用来自己继承和实现



### 成员内部类的访问特点

> 成员内部类的访问特点
>
> - 成员内部类内部访问外围类
> - 外围类访问成员内部类成员
> - 外部类访问成员内部类成员
> - 成员内部类访问外部类成员（了解）



#### 成员内部类内部访问外围类

> 需要理解的是，成员内部类相当于外围类的成员
>
> 并且内部类对象依赖外围类，在外围类内部访问时，一定存在一个外围类对象（重要）
>
> 理解这一点，就好理解下面的现象了

- 成员内部类可以无条件访问外围类的所有成员属性和成员方法（包括private成员和静态成员）

  - 需要注意的是，当外围类中有同名的属性或者方法时，都会发生类似“隐藏”的现象

    - 即默认情况下访问的都是成员内部类的成员

  - 如果要访问外围类的同名成员，需要以下面的形式进行访问：

    - ```Java
      EnclosedClazz.this.成员变量
      EnclosedClazz.this.成员方法
      ```

- 这里有一个类似this、super一样的隐式引用，默认传给成员内部类的所有成员方法

  - 即EnclosedClazz.this
  - 该引用指向了外围类的对象



#### 外围类访问成员内部类成员

> 虽然成员内部类可以无条件地访问外围类的成员，而外围类想访问成员内部类的成员却不是这么随心所欲了
>
> 原因在于内部类访问外围类时，内部类对象和外围类对象一定都已经存在；
>
> 但外围类访问内部类时，内部类对象还不存在，所以必须手动创建内部类对象
>
> 当然如果想要访问内部类中的全局常量，直接内部类名点常量名即可

- 在外围类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象

- 再通过这个内部类的引用去访问内部类的成员

- 在外围类中创建内部类语法：最容易理解，最万能的形式如下：

  - ```Java
    EnclosedClazz oz = new EnclosedClazz();
    InnerClazz ic = oz.new InnerClazz();//该形式适合在外围类中创建内部类
    //或者
    InnerClazz ic2 = new EnclosedClazz().new InnerClazz();//该形式适合在外围类中创建内部类
    ```

  - 如果访问内部类的方法是静态的，则只能使用上述格式，因为静态方法中外围类对象可能不存在

  - 如果访问内部类的方法是普通成员方法，则可以省略创建外围类对象的过程，其语法如下

  - ```java
    InnerClazz ic = new InnerClazz();
    ```

- 在外围类中一旦创建内部类对象，使用该对象可以访问内部类的所有成员，包括私有



#### 外部类访问成员内部类成员

> 外部类要访问内部类成员，条件要苛刻的多
>
> 由于内部类属于外围类的一个成员，所以内部类受访问权限的限制

- 如果该内部类是private修饰，那么显然在任何外部类中都无法访问该内部类成员

- 如果外部类拥有内部类的访问权限，可以创建该内部类对象，来访问该内部类的成员

- 语法

- ```Java
  //该方式最全面，适合任何位置
  EnclosedClazz.InnerClazz ic3 = new EnclosedClazz().new InnerClazz();
  ```

- 和外围类创建内部类对象不同，在外部类中创建内部类对象，不能够访问内部类的私有成员



#### 成员内部类访问外部类成员（了解）

> 在成员内部类中访问外部类成员，和在普通类中访问其它类成员别无二致

- 静态成员直接类名点访问

- 普通成员需创建外部类对象
- 受访问权限控制



> 下述访问，在成员内部类的情况下，能否进行，怎么进行

- 内部类的成员方法中，去访问外围类的成员（普通或静态、私有成员）
  - 直接访问 不受访问权限限制 外围类名.this 外围类类名点.静态成员
- 内部类的成员方法中，去访问外部类的成员（普通或静态、私有成员）
  - 和普通的类访问别的类成员 一模一样 受访问权限控制
- 外围类的普通成员方法，访问内部类的成员（普通和全局常量、私有成员）
  - 直接创建内部类对象即可,然后对象名点访问 对于静态成员,直接内部类类名点访问即可 不受访问权限限制
- 外围类的静态成员方法，访问内部类的成员（普通和全局常量、私有成员）
  - 必须先创建外围类对象,然后创建内部类对象 这样才能访问内部类成员 如果是静态的 直接类名访问即可 不受访问权限限制
- 外部类的普通成员方法，访问内部类的成员（普通和全局常量、私有成员）
  - 必须创建两个对象 受访问权限限制
- 外部类的静态成员方法，访问内部类的成员（普通和全局常量、私有成员）
  - 必须创建两个对象 受访问权限限制



## 静态内部类

> 思考：怎么把一个普通成员变成一个静态成员？

- 静态内部类也是处在外围类成员位置的内部类，不同的是它需要使用static修饰

- 语法：

- ```Java
  [访问权限修饰符] class EnclosedClazz{ //外围（普通）类的访问权限修饰符，只有两个，public和缺省
  	[访问权限修饰符] static class InnerClazz{//内部类访问权限修饰符，有四个，和普通成员一样
      }
  }
  ```



### 静态内部类自身特点

> 静态内部类自身的特点
>
> 1，访问权限修饰符
>
> 2，成员特点
>
> 3，继承和实现

- 静态内部类和成员内部类的最大区别就是static关键字

- Oracle公司官网有一段文字解释静态内部类和成员内部类的区别

  - ```Java
    Nested classes that are declared static are called static nested classes. Non-static nested classes are called inner classes.
    ```

- 嵌套的static类就是静态内部类 然后不用static修饰的嵌套类 就是成员内部类

- 什么意思呢？解释一下

  - 字面意思上看，它在说静态内部类叫做嵌套类，非静态内部类（成员内部类）叫做内部类
  - 什么叫nested呢？
    - 就是直接把一个类丢到另一个类中，本来我和你没有太多的关系，我完全有能力独立的自己做一个类
    - 但是我偏做一个”寄居蟹、啃老族“，借外围类的壳子用一用，来隐藏和保护自己(猥琐)
  - 什么叫inner呢？
    - 就是我处在你的内部，是你的一部分，我了解你，我知道你的全部，没有你就没有我
    - 比如心脏和人，CPU和计算机



- 静态内部类的类加载机制（重要）
  - 静态内部类是独立存在于外围类中的
    - 创建外围类对象，不会触发静态内部类加载
    - 创建静态内部类对象，也不会触发外围类的类加载
    - 静态内部类创建对象不依赖于外围类
  - 类加载的过程对于内部类和外围类是完全独立的



#### 访问权限修饰符

> 静态内部类的访问权限修饰符可以是

- public
- protected
- （default）缺省
- private



#### 成员特点

> 静态内部类的成员特点
>
> 成员变量
>
> 成员方法
>
> 构造器

- 静态内部类可以创建普通类可以创建的所有成员，包括静态
- 体现了静态内部类的独立性



#### 继承和实现（了解）

- 静态内部类的继承与实现和成员内部类并没有太大不同
- 区别在于，静态内部类只能继承一个静态内部类，而不能继承普通类



### 静态内部类的访问特点

> 静态内部类的访问特点
>
> - 静态内部类内部访问外围类
> - 外围类访问静态内部类成员
> - 外部类访问静态内部类成员（了解）
> - 静态内部类访问外部类成员（了解）



#### 静态内部类内部访问外围类

> 静态内部类创建对象的时候，完全可能没有外围类对象
>
> 理解这一点和成员内部类的不同，就好理解下述现象了

- 静态内部类只能直接访问外围类的静态成员，包括私有
- 静态内部类如果想要访问外围类的普通成员，需要创建对象
  - 和一般类创建对象访问成员不同的是，静态内部类中创建外围类不受访问权限限制
- 静态内部类中不存在一个外围类对象的引用，该对象完全可能不存在
- 如果想要调用外围类中，和静态内部类同名的静态成员，只需要外围类名点成员即可
- 如果想要调用外围类中，和静态内部类同名的普通成员，只需要创建外围类对象，对象点即可



#### 外围类访问静态内部类成员

> 静态内部类是相对外围类独立的类，在外围类中访问静态内部类成员
>
> 除了不受访问权限限制外，和访问其他一般类并无差别

- 如果访问静态内部类中的静态成员，可以直接内部类名点，不受访问权限限制

- 如果访问静态内部类中的普通成员，需要创建内部类对象，不受访问权限限制

  - 在外围类的任何地方创建静态内部类对象，都可以用以下语法

  - 最大的区别是不需要创建外围类对象，因为是相互独立的

  - ```Java
    InnerClazz ic = new InnerClazz();
    ```



#### 外部类访问静态内部类成员

> 静态内部类在外部创建对象，可以完全独立于外围类对象，不会触发外围类的类加载

- 创建静态内部类对象

  - 语法

  - ```Java
    EnclosedClazz.InnerStaticClazz ecisc = new EnclosedClazz.InnerStaticClazz();
    ```

  - 和普通类对象访问成员一样，受访问权限限制

- 访问静态成员，无需创建对象，直接

  - ```Java
    EnclosedClazz.InnerStaticClazz.静态成员名
    ```

  - 受访问权限限制



#### 静态内部类访问外部类成员（了解）

> 在静态内部类中，访问外部类成员，和在普通类中访问其他类成员别无二致

- 静态成员，类名点直接访问
- 普通成员需创建对象访问
- 受访问权限控制



> 下述访问，在静态内部类的情况下，能否进行，怎么进行

- 内部类的成员方法中，去访问外围类的普通成员（包括私有）
  - 能，但是要通过创建对象访问，并且不受访问权限控制
- 内部类的成员方法中，去访问外围类的静态成员（包括私有）
  - 能，直接类名点访问，如果没有同名的情况下，可以直接访问，当然也不受访问权限控制
- 外围类的普通成员方法，访问内部类的成员（属性和方法包括私有成员）
  - 创建内部类对象，然后对象名访问，如果是静态的，类名直接访问，不受访问权限控制
- 外围类的静态成员方法，访问内部类的成员（属性和方法包括私有成员）
  - 创建内部类对象，然后对象名访问，如果是静态的，类名直接访问，不受访问权限控制

> 注：
>
> 当内部类不需要方位外围类对象的时候，应该使用静态内部类。
>
> 声明在接口中的内部类自动成为static和public类，（默认没有abstract 和 final）。



## 局部内部类

> 局部内部类是定义在一个方法或者一个作用域里面的类
>
> 它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内
>
> 将局部内部类看成是局部变量即可



### 局部内部类自身特点

> 静态内部类自身的特点
>
> 1，访问权限修饰符
>
> 2，成员特点
>
> 3，定义位置
>
> 4，继承和实现



#### 访问权限修饰符

- 局部内部类和局部变量一样，没有访问修饰权限，因为毫无意义，大括号已经限制了它的访问范围

- 局部内部类不能用static关键字修饰，原因和局部变量一样

  

#### 成员特点

- 局部内部类内部无法定义静态成员，局部内部类中也没有静态的概念
  - 其余变量和方法都是可以创建的
- 构造方法和普通类一致，用来给自身成员赋值



#### 定义位置

> 几乎所有的局部位置都可以使用局部内部类
>
> 包括但不限于

- 方法
- 代码块
- if分支
- for循环内部

- 局部内部类的作用：当我们在局部位置，碰到了一个麻烦的问题，需要使用类来解决
  - 但是又不希望这个类被外界知道，这种情况需要使用局部内部类
- 局部内部类在使用前要有合适的理由，不然会自找麻烦





### 局部内部类的访问特点

> 前提：
>
> - 局部内部类相当于方法的局部变量，只在方法内部生效
>
> - 要想触发局部内部类的类加载，必须在该方法内部创建该内部类对象才可以

- 若该方法是普通成员方法
  - 该局部内部类，可以无条件访问，外围类的所有成员 (原因是普通成员方法隐含this 已经有外围类对象了)
  - 局部内部类和局部变量一样，出了作用域就失效了
  - 在外围类中无法创建对象，外部类更不行，只能在方法内部创建实例
- 若该方法时静态成员方法
  - 该局部内部类，可以无条件访问，外围类的所有成员，但是需要创建外围类对象（原因是没有this）
  - 局部内部类和局部变量一样，出了作用域就失效了
  - 在外围类中无法创建对象，外部类更不行，只能在方法内部创建实例

- 要想使用局部内部类的功能，必须在该方法内部创建内部类对象，然后调用方法



### 局部内部类注意事项

- 值得注意的是：
  - Java8之前的版本中，局部内部类只能访问方法中加了final的局部变量
    - 局部内部类对象的生命周期和局部变量的生命周期是有冲突的（life cycle）
      - 局部内部类对象的有可能比局部变量存活更久
    - 为了解决冲突，JVM偷偷的帮我们把局部变量塞到了局部内部类对象的成员中了
    - 但是问题仍然存在，将局部变量复制为内部类的成员变量时，必须保证这两个变量是一样的
      - 也就是如果我们在内部类中修改了成员变量，方法中的局部变量也得跟着改变
      - 最终Java开发者选择了妥协，使用final标记局部变量，这样就不能够改变它的值了
  - Java8以后的版本，仍然也是这么做的，但是将final关键字隐藏在底层代码中了
    - 也就是说，底层代码仍然会给局部变量加final
    - 拥有局部内部类的方法的局部变量仍然是final修饰的
    - 只不过从显式变成了隐式
- 局部内部类最大的优势是对方法外部完全隐藏，除了方法本身，即便是当前类也不知道它，不能访问它
  - 这是一种极致的封装思想的体现

>  如果一定要在局部内部类中使用方法的参数且使它可变，比如一个计数器counter。补救的方法是使用一个长度为1的数组，这样既保证引用为final，又有可以操作的空间。如方法中int[] counter = new int[1]，内部类中可以操作counter[0]++。



### 局部内部类的经典使用

> 写方法返回接口或者抽象类的具体子类

```Java
class Enclosed3Clazz{
    public A getA(){
        class AImpl implements A{
            @Override
            public void test() {
            }
        }
        return new AImpl();
    }
}
interface A{
    void test();
}
```



> 补全程序，使得可以输出三个num

```Java
class Outer {
    public int num = 10;
    class Inner {
        public int num = 20;
        public void show() {
            int num = 30;
            System.out.println();
            System.out.println();
            System.out.println();
        }
    }
}
```







## 内部类的优缺点和使用场景

> Java 1.1版本就引入了内部类（原属于C++）的概念，虽然很多人觉得内部类的引入让Java程序的扩展性提升了
>
> 但也有很多人觉得内部类的引入违背了Java简化C++的初衷，因为内部类的语法过于复杂
>
> 以至于让人提不起兴趣去使用，那么这样看似精致巧秒、实则复杂没必要的设计，到底有什么意义呢？
>
> 思考，接下来几个内部类的使用场景以及内部类的缺点

- 场景一：无条件地访问外围类的所有元素（优点）
  - 无论是成员内部类、静态内部类、局部内部类还是匿名内部类都可以无条件访问
- 场景二：隐藏类
  - 可以用private、protected修饰类
  - private修饰成员内部类、提供public的创建对象方法
- 场景三：实现多继承
  - 可以创建多个成员内部类继承外部多个类
  - 然后创建内部类对象，实际上就是外围类继承了多个类的成员
- 场景四：通过匿名内部类来优化简单的接口实现
  - 重点：内部类要说使用频率 最高的肯定是匿名内部类

> 内部类的缺点

- 内部类的缺点也是显而易见，语法很复杂，在类中定义内部类也会导致类的结构变复杂，影响代码可读性
  - 除此之外，不合理使用内部类还可能导致内存泄漏（了解）
    - 如果当内部类的对象被外围类以外的其他类引用时，就会造成内部类和外围类无法被GC回收的情况



# 匿名内部类（对象）

> 以往当需要一个子类对象的时候，我们需要分两步走
>

- 定义子类继承（实现）父类（接口）
- 创建子类对象
- 那么有没有一步直达的方式呢？
  - 我们可以通过局部内部类得到一个实现子类
  - 如果把局部内部类更进一步，变成匿名（局部）内部类呢？

​	

## 匿名内部类的创建

- 首先明确两点使用匿名内部类的前提

  - 匿名内部类是特殊的局部内部类，所以匿名内部类必须定义在局部位置
    - 匿名内部类是局部内部类的更进一步
    - 匿名内部类的成员特征、访问特征和局部内部类没有区别
    - 匿名内部类访问方法的局部变量时，该变量仍然是常量
  - 存在一个已定义类或者接口，这里的类可以是具体类也可以是抽象类

- 语法：

- ```Java
  new 类名或者接口名(){
      //重写方法
  };
  ```

- 注意右大括号的结尾分号，不可省略

- 匿名内部类的本质是继承了一个（抽象）类或者实现了接口





## 匿名内部类对象的使用

- 直接使用对象去调方法即可
  - 也可以用父类接收，但是父类接收无法调用子类独有方法
- 当我们只使用一次某类或者某接口的，子类对象，此时用匿名内部类对象，会稍微方便一点
- 但是，如果要多次访问，匿名内部类对象中的成员，就比较麻烦了
  - 因为每一次访问都得创建一次匿名内部类对象
- 通常，在只使用一次类、接口的子类对象的情况下，比较适合使用匿名内部类对象来完成
- 本质：是一个继承了类或者实现了接口的子类匿名对象



## 开发中的匿名内部类

- 作为方法的实际参数
  - 学习多态的时候我们曾经讲过，可以将父类作为形式参数，而将子类作为实际参数在方法调用的时候传入
  - 匿名内部类的匿名对象就是一个子类匿名对象，所以，可以使用匿名内部类改进以前的做法
- 在方法体中，作为方法的返回值
  - 方法体中，return 返回值只会执行一次，如果方法返回一个接口类型的对象，我们也可以使用匿名内部类





## 匿名内部类的使用优缺点

- 当我们只使用一次某类或者某接口的子类对象时，使用匿名内部类，会方便一点，简洁一点
- 如果需要多次访问子类对象的成员，必须要接收这个匿名内部类对象，否则会更麻烦
  - 需要用匿名内部类对象的父类接收
  - 无法访问匿名内部类中的独有方法
- 如果访问匿名子类中的独有方法，必须用匿名对象去访问，就无法用引用去接收了



> 内部类是一种编译器现象，与虚拟机无关。编译器会把内部类翻译成用$分隔外部类名与内部类名的常规类文件，而虚拟机则对此一无所知。

> 匿名内部类可用于生成日志时获取当前类名。System.out.println(getClass());对于静态方法不奏效，System.out.println(new Object(){}.getClass().getEnclosingClass());在静态方法中也有效。



## lambda表达式

> Lambda 表达式是 JDK8 的一个新特性，可以取代接口的匿名内部类，写出更优雅的 Java 代码
>
> 匿名内部类实际上是局部内部类的更进一步，简化了局部内部类
>
> 那么lambda就是匿名内部类更进一步，语法上更简洁了
>



> lambda表达式基本使用：

- 若想使用lambda简化接口的匿名内部类，需要该接口是一个功能接口
  - 有且仅有一个抽象方法的接口称之为功能接口（FunctionInterface）
    - 功能接口有一个专门的注解标记它，写在接口声明的上面，就叫@FunctionInterface
    - 这个注解可以用来验证该接口是不是功能接口
  - Java8以后接口中可以使用静态方法和默认方法，所以严格来说功能接口可以允许不止一个方法
    - 但是普遍来说，功能接口应该仅有一个方法，就是那个抽象方法
- 下面给出六个接口，都是常见的功能接口形式

```java
//无返回值无参数的功能接口
@FunctionalInterface
interface INoReturnNoParam {
    void test();
}

//无返回值有一个参数的功能接口
@FunctionalInterface
interface INoReturnOneParam {
    void test(int a);
}

//无返回值两个参数的功能接口
@FunctionalInterface
interface INoReturnTwoParam {
    void test(int a, int b);
}

//有返回值无参数的功能接口
@FunctionalInterface
interface IHasReturnNoParam {
    int test();
}

//有返回值一个参数的功能接口
@FunctionalInterface
interface IHasReturnOneParam {
    int method(int a);
}

//有返回值两个参数的功能接口
@FunctionalInterface
interface IHasReturnTwoParam {
    int test(int a, int b);
}
```

- 接口准备完毕后，就可以开始使用lambda表达式了

- lambda基础语法

  ```java
  (接口中那个抽象方法的形参列表) -> {
  	//这里面重写这个抽象方法,也就是方法体
  }
  ```

- 基础语法解释

  - () 小括号中要写接口中抽象方法的形参
  - -> 是lambda运算符，读作“goes to”
  - {}表示重写的方法的方法体
  - {}只有一对，只能重写一个方法；()参数列表也只有一个，所以要求功能接口必须只有一个抽象方法
  - 注意：整个lambda表示式表示功能接口的一个实现类对象

- 重要：lambda表达式的类型推断

  - 按照以上语法，直接写完代码，肯定是要报错的
  - 因为编译器无法仅仅通过这个基础语法，就判断出这个lambda表达式究竟创建的是哪个接口实现类对象
  - 由于Java是强类型语言，所以必须在编译时期就确定该对象的数据类型
    - 编译器去确定lambda表达式（对象）的数据类型的过程称之为lambda表达式的类型推断
  - 实际上编译器是通过，lambda表达式所处的上下文代码去判断其类型的
  - 最简单的方式就是直接用目标功能接口接收这个lambda表达式，让编译器直接明确其数据类型

- 至此就完成了lambda表达式的基本使用



> lambda表达式继续简写
>
> lambda表达式的目标接口，有且仅有一个抽象方法，这是lambda表达式继续简化的前提

- ()里的参数列表肯定是固定的，于是可以省略形参中的数据类型，仅写形参名
  - 在上面的基础上，如果抽象方法的形参只有一个，小括号()也可以省略
- 如果{}中的方法体仅有一句，大括号可以省略
  - 在上面的基础上，如果方法有返回值，且返回值return语句仅有一条，那么连return都可以省略




> lambda表达式去引用一个已经实现的方法
>
> 有时候功能接口中的方法已经有实现了，如果不想自己再去重写这个方法
>
> 可以利用 lambda表达式的接口快速指向一个已经被实现的方法

- 语法

  - ```Java
    (接口中那个抽象方法的形参列表) -> 已实现的某个方法
    ```

- 更进一步简写

  - ```Java
    方法归属者::方法名 
    ```

  - 静态方法的归属者为类名，普通方法归属者为对象名



> lambda表达式的优缺点

- 优点：
  - 极大得简化了代码，使代码变得更加优雅
  - 函数式编程的代表，可能是未来高端的编程趋势
- 缺点：
  - 过于简单的lambda表达式，显然可读性很低

> 注意不能把Lambda表达式赋值给Object的变量，Object不是一个函数式接口。

> Java API在java.util.function包中定义了很多非常通用的函数式接口。不过对于Java程序员而言，想要用lambda表达式做某些处理，还是要谨记表达式的用途，为它建立一个特定的函数式接口。
>
> java.util.function包中有一个尤其有用的接口Predicate。
>
> public interface Predicate<T>{
>
> ​	boolean test(T t);
>
> //Additional default and static methods
>
> }
>
> 这个接口专门用来传递lambda表达式。例如ArrayList类有一个removeIf方法的参数就是一个Predicate。
>
> list.removeIf(e -> e == null);//从一个数组列表删除所有null值。

lambda表达式内作用域在方法中，可以使用所在方法中已经定义的变量，但是和内部类同样受到限制，即方法中的局部变量已经lambda表达式使用，该变量便隐式成为一个effectively final（最终变量），就常量，无论在lambda表达式内，还是lambda表达式后的方法体内该变量的值都不允许改变，否则不允许捕获该变量。

同上原因，lambda表达式中this关键字是指创建这个lambda表达式的方法的this参数，而不是函数式接口的实例。

最好参考基本类型的函数式规范来减少自动装箱。

# Object引入

Application Programming Interface(API)：应用程序编程接口，在Java当中指的是一些预先定义好的类和方法

​	作用：开发者可以在不关注具体实现细节的前提下，使用这些已经预先定义好的类和方法实现自己的需求

​	分类：

​				1，JDK中自带的，可以通过官方API文档去学习

​				2，开发者编写的，依赖于开发者之间去沟通



Object类概述：

​	1，Object类是所有类继承层次的祖先类，所有类（包括数组）都直接或者间接的继承自该类，都实现了该类的方法

​	2，但是我们在自定义类时，并不需要特别标注extends Object

​	3，如果一个类没有明确的指出它的父类，Object类就默认被认为是这个类的父类，extends Object则被省略了



为什么所有类都有一个默认无参？

​		1，当一个类没有定义构造方法的时候，就会自动添加默认构造方法

​		2，一旦有默认构造方法，在创建子类对象的时候，就会执行子类对象的隐式初始化

​		3，隐式初始化，默认调用父类的无参构造

​		4，所以最终，一定能保证，调用到Object类的无参构造方法，先初始化Object这个父类

​	

Object的成员方法：

​	1，public final Class getClass()

​	2，public String toString()

​	3，public boolean equals(Object obj)

​	4，public int hashCode()

​	5，protected void finalize() (不重要)

​	6，protected Object clone()



Object数组可以装所有引用类型

讲string的时候，输出char数组名

# getClass()

> public final Class<?> getClass()
>
> getClass()概述

- 语法

  ```java
  对象名.getClass();
  ```

- 其作用是返回调用此方法的Object的运行时类（的Class对象）





> 什么是Class对象？

- 需要注意的是Class首字母大写，这是一个类的对象，和String一样
- JVM每加载一个类，都会在内存中创建唯一一个和该类对应的Class对象
  - 这个Class对象包含了这个类的全部信息
  - 帮助程序员在运行时期，了解该对象的属性和行为
  - Class对象处于堆上
  - 在运行时期程序员可以通过这个类，获取该类型的所有信息
- 由于Class对象和类是一一对应的，所有Class对象很多时候被称为类对象
  - Class对象和方法区中加载的字节码文件，都是在触发类加载的时候生成的
  - 类加载只会触发一次，Class对象也只独一份
- 类的对象和类对象的区别
  - 一个类的Class对象叫做类对象，也称之为运行时类对象，整个程序运行期间独一份
  - 类的对象是类的一个实例，程序运行期间可以创建多个
- Class类对象是反射的基础
  - 反射实质就是Class类的API使用

​	

> Class类的常用API

- getName()
  - 获取类的全限定类名
- getSimpleName()
  - 获取类名

# toString()

>  public String toString()
>
>  toString()概述

- 语法

  ```Java
  对象名.toString()
  ```

- 返回该对象的字符串（String）表示

- 通常，toString 方法会返回一个“以文本方式表示”此对象的字符串

- 结果应是一个简明但易于读懂的信息表达式	

- 建议所有子类都重写此方法



> 总结来说

- toString()方法就是简洁明了的一句话告诉我们这个对象长啥样
- 建议在子类中都重写这个方法
- 对象的成员变量就是描述对象的外貌特征的
- 理想情况下，我们希望这个方法能够输出对象中所有成员变量的取值



> toString的使用
>
> 回想一下，我们之前直接打印数组名或者对象名，得到的是什么？

- 当我们直接打印数组名或者对象名时
  - 其实都默认隐含了调用toString()方法，输出toString()方法返回的字符串
- 这个时候我们并没有重写toString()方法，打印的是全限定类名加地址值

> Object类当中的toString()方法

- Object类的toString()方法返回一个字符串

  - 该字符串由类的全限定类名、at标记符“@”和此对象十六进制地址值组成

  - ```Java
    getClass().getName() + '@' + Integer.toHexString(hashCode()
    ```



> Object类的toString()方法往往不能满足我们的需求
>
> 我们需要自己重写toString()方法，这也是官方给我们的建议

- 常见的toString()方法的格式

  - ```Java
    对象所属类型{成员变量1 = '值1' ,成员变量2 = '值2'....}
    ```

- 一个类重写toString()后再打印对象名，就会自动调用该方法



> 注意事项

- 直接打印数组名或者对象名，默认调用toString()方法，然后打印该方法返回的字符串
- 用一个字符串和一个对象直接拼接，默认拼接该类的toString()方法字符串
- debug时下一步会打印toString()返回的字符串
  - 不要在toString()方法里对对象进行操作，避免造成奇怪的bug
- 如果类中有别的引用类型，可以在返回语句中调用该引用类型的toString()方法

> 数组的toString直接继承了Object的，修正的方式是调用静态方法Arrays.toString,多为数组调用Arrays.deepToString

> java.lang.Class 1.0
>
> * String getName()
>
>   返回这个类的名字。
>
> * Class getSuperclass()
>
>   以Class对象的形式返回这个类的超类信息。

# equals()

> public boolean equals(Object obj)
>
> equals() 概述

- 语法

  ```Java
  对象名.equals(其他对象名)
  ```

- 指示其他某个对象是否与此对象“相等”

  - 此对象：调用equals() 方法的对象
  - 其他某个对象：equals() 方法括号中的对象

- 对象相等的含义

  - 我们理想状态下的对象相等
    - 首先两个对象的类型要相同，如果类型都不想同，那就没有意义了
    - 类型相同的情况下，比较成员变量的取值是否相等，都相等则认为两个对象相等
  - Object类中的相等
    - 只有两个对象的内存地址相等，才叫相等
    - Object类中的equals()方法等价于”==“
    - 对象存在堆上没有办法直接拿出来比，于是”==“比较的是两个对象的引用
    - 两个引用变量是否相等，取决于它们是否指向了同一对象，也就是比较对象的内存地址
  - Object类中的equal()方法不能满足我们需求，需要自己手动重写该方法



> 设计equals() 方法的原则（常规协定）

- 自反性：对于任何非空引用值 x，x.equals(x) 都应返回 true
- 排他性：当比对的不是同种类型的对象或者是一个null时，默认返回false
- 对称性：对于任何非空引用值 x 和 y，当且仅当 y.equals(x) 返回 true 时，x.equals(y) 才应返回 true
- 传递性：对于任何非空引用值 x、y 和 z，如果 x.equals(y) 返回 true，并且 y.equals(z) 返回 true
  - 那么x.equals(z) 应返回 true
- 一致性：对于任何非空引用值 x 和 y，多次调用 x.equals(y) 始终返回 true 或始终返回 false
  - 前提是对象上equals 比较中所用的信息没有被修改
- 其实只要按照下述原则重写，就能够满足上面的常规协定
  - 若是不同类型的对象，直接认定不相等
  - 若是相同类型的对象，认为具有相同的成员变量的两个对象，才是相等的



判断是否是同种类型对象的两种方式：

当传入一个o作为被比较的对象时

```
1,if (!(o instanceof 这个类))
2，if (o == null || this.getClass() != o.getClass())
```



equals方法使用注意事项：

​		1，对于任何非空引用值 x，x.equals(null) 都应返回 false

​		2，不要使用一个null常量，调用方法，会引发程序错误

​				在方法中，我们只能对方法的参数进行校验，没办法校验调用者

​				应该在外部写代码，防止使用一个null去调用方法

​		3，如果类中有引用类型的成员变量，继续调用该引用类型的equal()方法判断



补充知识点：

Double类和Float类中的compare() 方法：

​	1，调用方式：Double.compare(doule d1,double d2)   Float.compare(float f1,float f2) 

​	2，作用：

​		如果这两个数字数学意义上相等，则返回 0

​		如果前者在数字上小于后者，则返回小于 0 的值

​		如果前者在数字上大学后者，则返回大于 0 的值



财务金额上使用的确保精度的数字类型：

​	如果使用double或者float作为金额的数据类型，会出现一些不可预知的精度问题。

​	推荐使用BigDecimal这个类

# hashCode()

> public int hashCode()
>
> hashCode() 概述

- 语法

  ```Java
  对象名.hashCode()
  ```

- 通过一个哈希（散列）函数，返回该对象的哈希（码）值

- 支持此方法是为了提高哈希表的性能（主要是集合体系中用）



> 映射的概念

- 设A和B是两个非空集合，并存在某种对应关系f
- 按照这种对应关系f，对于集合A中的任何一个元素a，在集合B中都存在唯一的一个元素素b与之对应
- 那么，这样的对应（包括集合A，B，以及集合A到集合B的对应关系f）叫做集合A到集合B的映射

> 总得来说

- 在映射的定义中，集合A中的任一元素都在集合B中有唯一元素对应
- 函数是特殊定义的映射
  - 在中学数学中，集合A和B都必须是数集，而在高等数学中，只有值域被限制为数集



> 通过映射的定义，我们引入hash相关概念

- 哈希函数
  - 把任意（不限制）大小的数据集合A中的元素a，唯一地映射到固定大小集合B中的元素b上
  - 这种对应关系，称之为哈希函数（方法）或者哈希算法
- hashCode()方法的哈希函数
  - 任意数据大小的集合就是对象的集合，固定大小的数据集合int
  - 不同的对象返回不同的整数

- 哈希值
  - 由哈希函数从集合A唯一映射到的集合B中的元素，被称之为哈希值

- 哈希冲突
  - 理想状态下的哈希函数，除了应该满足映射定义，唯一的将集合A中的元素映射到集合B中外
    - 我们还希望集合A和B中元素最好能够一一对应
  - 然而实际情况中，总是会存在两个集合A中的不同元素映射到了集合B中的同一个元素上
    - 这种现象，我们称之为：“hash冲突”

​		

> Object类中hashCode()方法

- 该方法是一个native方法，本地方法

- 通过将该对象的内部地址转换成一个整数来实现，但是不是通过Java语言去实现（C/C++）



> Object类中的hashCode()方法不能满足我们的需求

hashCode 的常规协定是： 

​		1，在 Java 应用程序执行期间，在对同一对象多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是将对

象进行 equals 比较时所用的信息没有被修改（哈希值是根据成员变量来计算的）。从某一应用程序的一次执行到同一应

用程序的另一次执行，该整数无需保持一致。 

​		2，如果根据 equals(Object) 方法，两个对象是相等的，那么对这两个对象中的每个对象调用 hashCode 方法都必须

生成相同的整数结果。 

​		3，如果根据 equals(java.lang.Object) 方法，两个对象不相等，那么对这两个对象中的任一对象上调用 hashCode 方

法不 要求一定生成不同的整数结果。但是，程序员应该意识到，为不相等的对象生成不同整数结果可以提高哈希表的性能。 



> 扩展
>
> hashCode()方法是会返回一个对应于当前对象的一个整数，为了将来在集合中更快捷的查找对象

- 集合类似于数组，但不同的是集合中只能装对象
- Java中的集合类 hashMap、hashSet 底层的实现都是哈希表，之所以采用哈希表
  - 是因为他能克服链表和二叉树等数据结构在查询上的低效率问题
  - 哈希表的存储，就是根据对象的哈希值，以此确定他的存储位置

# finalize()

> 方法的源代码

```java
protected void finalize()  throws Throwable {  }
```

- Object()类当中的finalize()方法是protected权限，并且是空的
- 完全可以看得出来，该方法需要子类自己重写去实现功能
- 这种方法比接口的抽象方法要自由，因为它不是强制的



> 该方法的调用时机和功能

- 当一个对象成为匿名对象，不存在任何引用指向它时

  - 它就成为了一个垃圾对象

- Java的垃圾回收器就开始准备回收该对象，释放内存空间

- 但是垃圾回收器只能回收Java相关的内存空间（new出来的对象）

  - 那些该对象获取的特殊内存空间（非Java的系统资源）垃圾回收器无法直接回收
  - 于是调用该方法去释放一些和Java没有关系的系统资源（需要子类重写）
    - 这里需要子类重写finalize()才能达到效果
    - JVM在回收new对象空间之前会自动调用finalize方法，并且只会调用一次
  - 比如说对象调用的IO资源，调用native方法开辟的空间等等
    - Scanner

- 整个垃圾回收期间，只会被调用一次

- 综上

  > 一旦垃圾收集器准备释放对象占用的存储空间，将首先调用其finalize()方法，进行一些必要的清理工作
  >
  > 在调用该finalize()方法释放其他资源后，jvm会再一次的执行检查该对象是否还存在其他引用
  >
  > 并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存（new出来的对象）
  >
  > 所以可以在子类中重写该方法，然后作为释放对象持有其他资源的手段



> 总结：

- finalize()方法是典型的Java拿来C++机制想要使用，但是失败的案例
  - C++析构函数是指对象在销毁前自动执行的方法，是为了给对象的销毁做最后的收尾工作
  - 比如释放系统资源（这里显然C++胜出）
- 但是Java的垃圾回收机制不是手动的，而是自动的。对象的销毁，垃圾回收具有不确定性
- 而只有在真正要销毁（new出来的）对象之前才会调用finalize()方法
- 所以使用finalize()给对象销毁做”善后“操作，也是不确定的，不安全的，低效率的
- 所以应该避免使用finalize()方法去释放系统资源，而是在使用完毕后，手动去关闭这些资源
- 这是自动垃圾回收便利的代价，你不得不放弃对系统资源释放的控制



> 这玩意没用，但是知道它可以增长见识

- thinking in java
- GC

# clone()

> 概述

- protected Object clone() 
- 语法：对象名点clone();
- 创建并返回此对象的一个副本（对象的引用）
- 该副本和原对象具有相同的属性



> 使用clone()方法注意事项

- protected权限问题
  - 在一个类中创建自身对象，然后调用clone()拷贝，无需重写clone() 方法
  - 在其他类中克隆一个类的对象，需要重写clone()方法权限
- 要想使用一个类的clone() 方法，这个类都必须实现Cloneable接口
  - 否则抛出CloneNotSupportedException异常

- 使用clone() 方法创建对象，和new创建对象属于同等级别的Java中创建对象的方式
  - clone()方法创建对象是调用native方法，不调用构造方法
- 返回值类型是一个Object对象，必要的时候要进行强转



> clone() 方法对该副本的要求：

​	对于任何对象 x，表达式： 

​		1，x.clone() != x 为 true（这一条是必须的）

​		2，x.clone().getClass() == x.getClass() 为true

​		3，x.clone().equals(x) 为true（一般情况下为true，但这并不是必须要满足的要求）



Cloneable接口：

​	1，该接口是一个标记接口，没有任何方法

​	2，空（标记）接口的意义：

​			a，实现空接口后，从成员角度，该类没有任何变化

​			b，但是在内存中，该类的数据类型已然发生了改变，成为了这个接口的一个实现类

​	3，空接口的作用：

​			a，空接口给该实现类打上了标记

​			b，使用 instanceOf 运算符，可以判断一个类是否是该空接口的实现类

​			c，如果判定是，可以进行一系列操作



浅拷贝和深拷贝：

​	1，浅拷贝：

​			a，被复制对象的，所有基本类型成员变量值，都与原来对象的相同，且独立

​			b，被复制对象的，所有引用类型的引用，仍然指向原来的对象，相当于复制了对象引用，而没有复制对象

​	2，深拷贝：

​			在浅拷贝的基础上，复制对象引用的同时，也复制了对象，并让复制的引用指向了复制的对象

​	3，Object类当中的clone() 方法只是浅拷贝

​	4，深拷贝基于浅拷贝实现，需要我们手动重写clone() 方法实现

​	

> 所有数组类型都有一个public的clone方法，而不是protected。可以用这个方法建立一个新数组，包括原数组所有元素的副本。

# Object类：所有类的超类

## equals方法

> Object a.equals(Object b)方法用于检测两个对象是否具有相同的引用。作为默认操作合乎情理，但对多数类来说完全没有意义。

例如需要比较Student类的两个对象是否相等，需要重写equals方法，比较id或者name是否相等才具有实际意义。

用超类属性进行相等校验可以使用instanceof先检查类型

用子类特有属性相等校验可以使用getClass()来检查类型

> Objects.equals(Object a, Object b)方法可以防止空指针

完美编写equals方法的建议：

```java
1 显示参数命名为otherObject，稍后需要将它转换成另一个叫做other的变量。
2 检测this与otherObject是否引用同一个对象：
if(this == otherObject) return true;
这条语句只是一个优化。实际上，这是一种经常采用的形式。因为计算这个等式要比一个一个地比较类中的域所付出的代价小得多。
3 检测otherObject是否为null，如果为null，返回false。这项检测是很有必要的。
if(otherObject == null) return false;
4 比较this与otherObject是否属于同一个类。如果equals的语义在每个子类中有所改变，就是用getClass检测：
if(getClass() != otherObject.getClass()) return false;
如果所有的子类都拥有统一的语义，就是用instanceof检测：
if(!(otherObject instanceof ClassName)) return false;
5 将otherObject转换为相应的类类型变量：
ClassName other = (ClassName) otherObject
6 现在开始对所有需要比较的域进行比较了。使用==比较基本类型域，使用equals比较对象域。如果所有的域都匹配，就返回true；否则返回false。
return field1 == other.field1 && Objects.equals(field2, other.field2) && ...
如果在子类中重新定义equals，就要在其中包含调用super.equals(other)。
//提示：对于数组类型的域，可以使用静态的Arrays.equals方法检测相应的数组元素是否相等。
//Double.compare(a,b)比较两个浮点数
```

> java.util.Objects 7
>
> * static boolean equals(Object a, Object b)
>
>   如果a和b都为null，返回true；如果只有其中之一为null，则返回false；否则返回a.equals(b)。
>
> java.util.Arrays 1.2
>
> * static Boolean equals(type[] a, type[] b) 5.0
>
> 如果两个数组长度相同，并且在对应位置上的数据元素也均相同，将返回true。数组的元素类型可以是Object、int、short、char、byte、boolean、float或double。

## hashCode方法

> 散列码（hash code）是由对象导出的一个整型值。散列码是没有规律的。如果x和y是两个不同的对象，x.hashCode()与y.hashCode()基本不会相同。
>
> 如果重新定义equals方法，就必须重新定义hashCode方法，一边用户可以将对象插入到散列中。
>
> hashCode方法应该返回一个整形数值（可以为负），并合理地组合实例域的散列码，以便能够让不同对象产生的散列码更均匀。
>
> 最好使用null安全的方法Objects.hashCode。如果其参数为null，该方法返回0，否则返回参数调用的hashCode的结果。另，使用静态方法Double.hashCode来避免创建Double对象：
>
> 写法：
>
> ```java
> public int hashCode() {
>     return 7 * Objects.hashCode(name)
>         + 11 * Double.hashCode(salary)
>         + 13 * Objects.hashCode(hireDay);
> }
> ```
>
> 比
>
> ```jade
> public int hashCode() {
> 	return 7 * name.hashCode()
> 	+ 11 * new Double(salary).hashCode()
> 	+ 13 * hireDay.hashCode();
> }
> ```
>
> 好
>
> 更好的，需要组合多个散列值时，可以调用Objects.hash并提供多个参数。这个方法会对各个参数调用Objects.hashCode，并组合这些散列值。这样就能简单地写为：
>
> ```java
> public int hashCode() {
>     return Objects.hash(name, salary, hireDay);
> }
> ```
>
> equals与hashCode的定义必须一致：如果x.equals(y)返回true，那么x.hashCode()就必须与y.hashCode()具有相同的值。
>
> 如果存在数组类型的域，那么可以使用静态的Arrays.hashCode方法计算一个散列码，这个散列码由数组元素的散列码组成。
>
> java.util.Object 1.0
>
> * int hashCode()
>
>   返回对象的散列码。散列码可以是任意的整数，包括正数或负数。两个相等的对象要求返回相等的散列码。
>
> java.util.Objects 7
>
> * static int hash(Object... objects)
>
>   返回一个散列码，由提供的所有对象的散列码组合而得到。
>
> * static int hashCode(object a)
>
>   如果a为null返回-，否则返回a.hashCode()。
>
> java.lang.(Integer|Long|Short|Byte|Double|Float|Character|Boolean) 1.0
>
> * static int hashCode((int|long|short|byet|double|float|char|boolean)) 8
>
>   返回给定的散列码。
>
> java.util.Arrays 1.2
>
> * static int hashCode(type[] a) 5.0
> * 计算数组a的散列码。组成这个数组的元素类型可以是object, int,long,short,char,byte,boolean,float或double。

# 泛型数组列表

语法

```java
ArrayList<Student> students = new ArrayList<Student>();
在Java SE7中，可以省去右边的类型参数；
ArrayList<Student> students = new ArrayList<>();
```

>  注：Java SE 5.0以前版本没提供泛型类，在5.0版本以后没有<...>然然可以使用ArrayList，它将被认为是一个删去了类型参数的“原始”类型。

> 注：Java的老版本中，程序员使用Vector类实现动态数组。不过，ArrayList类更加有效，没有任何理由一定要使用Vector类。

> 如果已经清楚或者能够估计出数组可能存储的元素数量，可在填充数组之前调用ensureCapacity方法或者直接在new的时候把初始容量传给ArrayList构造器
>
> 或者当一旦能够确认数组列表的大小不再发生变化，就可以调用trimToSize方法。此方法将存储区域的大小调整为当前元素数量所需要的存储空间数目。垃圾回收器将回收多余的存储空间。
>
> 一旦整理了数组列表的大小，添加新元素就要花时间再次移动存储块，所以应该再确认不会添加任何元素时，在调用trimToSize。

> java.util.ArrayList<E> 1.2
>
> * ArrayList<E>()
>
>   构造一个空数组列表
>
> * ArrayList<E>(int initialCapacity)
>
>   用指定容量构造一个空数组列表。
>
>   参数：initialCapacity 数组列表的最初容量
>
> * boolean add(E obj)
>
> * 在数组列表的尾端添加一个元素。永远返回true。
>
>   参数：obj 添加的元素
>
> * int size()
>
>   返回存储在数组列表中的当前元素数量。（这个值将小于或等于数组列表的容量。）
>
> * void ensureCapacity(int capacity)
>
>   确保数组列表在不重新分配存储空间的情况下就能够保存给定数量的元素。
>
>   参数：capacity 需要的存储容量
>
> * void trimToSize()
>
>   将数组列表的存储容量消减到当前尺寸。

> 原始的ArrayList存在一定危险性。其get方法别无选择只能返回Object，因此，get方法的调用者必须对返回值进行类型转换；它的add和set方法允许接受任意类型的对象，编译不会给出任何警告，只有在检索对象并试图对他进行类型转换时，才会发现有问题。如果使用ArrayList<Student>，编译器就会检测到这个错误。

> 对数组列表实施插入和删除元素的操作效率比较低。对于小型数组，不必担心。但如果存储的元素比较多，又经常需要在中间位置插入、删除元素，就应该考虑使用链表。

> java.util.ArrayList<T> 1.2
>
> * void set(int index, E obj)
>
>   设置数组里表指定位置的元素值，这个操作将覆盖这个位置的原有内容。
>
>   参数：index 位置（必须介于0~size()-1之间）obj 新的值
>
> * E get(int index)
>
>   获得指定位置的元素值。
>
>   参数：index 获得的元素位置（必须介于0~size()-1之间）
>
> * void add(int index, Eobj)
>
>   向后移动元素，以便插入元素。
>
>   参数：index 插入位置（必须介于0~size()-1之间） obj 新元素
>
> * E remove(int index)
>
>   删除一个元素，并将后面的元素向前移动。被删除的元素由返回值返回。
>
>   参数：index 被删除的元素位置（必须介于0~size()-1之间）

# 对象包装器与自动装箱

所有基本类型都有一个与之对应的包装器类。对象包装器类是不可变的，一旦构造了包装器，就不用交内需更改包装在其中的值。对象包装器类还是final，也不能定会一他们的子类。

数组列表的类型不能时基本类型但可以时包装器类型。但包装器数组列表效率远远低于基本类型的数组。但应该用它构造小型集合，给程序员操作的方便性比执行效率更重要。

包装对象的==运算检测的是对象是否指向同一个储存区域，因此比较两个包装器对象时应调用equals方法。因为自动装箱规范要求boolean、byte、char<=127，介于-128~127之间的short和int被包装到固定的对象中，所以在这之间的包装对象用==比较的结果才成立。

包装类型和基本数据类型的自动装箱和自动拆箱时编译器认可的，而不是虚拟机。编译器在生成类的字节码时插入必要的方法调用，虚拟机只是执行这些字节码。

包装类可以为null，要注意自动拆箱时的空指针异常。

注：包装类并不能改变Java的值传递，包装对象是不可变的。如果想要编写一个修改数值参数值的方法，可使用在org.omg.CORBA包中定义的持有者（holder）类型，包括IntHolder、BooleanHolder等。每个持有这类型都包含一个公由（！）域值，通过它可以访问存储在其中的值。（这和自己写个对象拷贝引用修改属性的原理一样）

> java.lang.Integer 1.0
>
> * int intValue()
>
>   以int的形式返回Integer对象的值（在Number类中覆盖了intValue方法）。
>
> * static String toString(int i)
>
>   以一个新String对象的形式返回给定数值i的十进制表示。
>
> * static String toString(int i, int radix)
>
>   返回数值i的基于给定radix参数进制的表示
>
> * static int parseInt(String s)
>
> * static int parseInt(String s, int radix)
>
>   返回字符串s表示的整形数值，给定字符串表示的是十进制的整数（第一种方法），或者是radix参数进制的整数（第二种方法）。
>
> * static Integer valueOf(String s)
>
> * static Integer valueOf(String s, int radix)
>
>   返回用s表示的整型数值进行进行初始化后的一个新Integer对象，给定字符串表示的是十进制的整数（第一种方法），或者是radix参数进制的整数（第二种方法）。
>
> java.text.NumberFormat 1.1
>
> * Number parse(String s)
>
>   返回数字值，假设给定的String表示了一个数值。

# 枚举

枚举的声明定义类型是一个类，{}里的每一个枚举常量实际上都是这个类的一个实例。比较两个枚举类型的值时，永远不需要调用equals，而是直接使用==就可以了。

需要的话可以在枚举类型中添加一些构造器、方法和域。当然，构造器只是在构造枚举常量的时候被调用。

> java.lang.Enum<E> 5.0
>
> * static Enum valueOf(Class enumClass, String name)
>
>   返回指定名字、给定类的枚举常量
>
> * String toString()
>
>   返回枚举常量名
>
> * int ordinal()
>
>   返回枚举常量在enum声明中的位置，位置从0开始计算。
>
> * int compareTo(E other)
>
>   如果枚举常量出现在other之前，则返回一个负值；如果this==other，则返回0；否则，返回正值。枚举常量的出现次序在enum声明中给出。



# String

> String概述

- 在Java语言中，所有类似“ABC”这样用双引号引起来的字符串，都是String类的对象
- String类位于java.lang包下，是Java语言的核心类
- String类提供了字符串表示、比较、查找、截取、大小写转换等各种针对字符串的操作



> 构造方法（constructor）

- 使用String尤其要注意导包问题，导错包会直接导致不能运行main方法

```Java
//创建空字符串对象，需要注意的是null != ""
public String()
//把字节数组中的元素转换成字符串，字节数组中可以是字符，也可以是ASCII码值
public String(byte[] bytes)
//同上，只不过指定了区间
public String(byte[] bytes,int offset,int length)
//同字节数组
public String(char[] value)
//同上
public String(char[] value,int offset,int count)
//套娃
public String(String original)
```



> String对象的最大特征
>
> 引例
>
> 键盘输入接收一个字符串s，并用一个temp字符串引用指向它
>
> 现在修改原先字符串s（拼接一个字符串），比较s和temp

- 字符串是常量，它的值在创建之后不能更改，也就是说String对象不可变
  - String对象不可变指的是对象的状态不可变，而不是引用中的地址不可变
  - 原因是String中的字符串都是由字符数组装着的，而该数组是final修饰的 

> 字符串常量池
>
> Java当中所有双引号引起来的字符串都是字符串对象

- 每一个字符串字面值都作为一个对象存储在堆上的字符串常量池中
  - 字面值常量编译时期，就能确定其取值，编译时期加入常量池
  - 当后续再使用字面值创建相同内容的字符串对象时，直接将该对象返回给引用 
  - 如果使用new关键字创建相同内容字符串对象，对象不共享，但是字符数组仍然共享 

> 字符串是JVM堆内存中最多的对象，字符串不可变后，就可以共享，节省了大量的堆内存空间
>
> 不可变后还变得更安全（多线程可以体现）
>
> 不可变后效率提升（简单举例：新建数组很快，但是移动拷贝数组很难）



> 三个获取数组的方法



- ```Java
//使用指定字符集，将字符编码成字节序列，并将结果存储到一个新的 byte 数组中
  getBytes(String charsetName) 
  ```
  
- ```Java
  //将字符从此字符串复制到目标字符数组
  getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)
  ```

- ```java 
  //将此字符串转换为一个新的字符数组。
  toCharArray()
  ```

> String类中重写了equals()方法，比较的是字符串的内容而不是地址



>  使用加号对字符串进行拼接操作，会有下述两种结果
>
>  - 直接在常量池中创建新的拼接对象=
>  - 在堆上创建新的拼接对象
>
>  经过测试我们发现
>
>  - 当参与字符串拼接的两个字符串中，至少有一个是以引用变量的形式出现时
>   - 必然会在堆上创建新的字符串对象
>     - 原因是变量参与了运算，无法在编译时期确定其值，就不能在编译时期加入常量池
>  - 只有参与字符串拼接运算的两个字符串，都是字符串字面值常量的时候
>   - 此时不会在堆上创建新的字符串对象，而是在常量池中直接拼接创建对象
>   - 如果已存在，则不创建新的对象

# String API

> String类的判断功能

```java 
//用来比较字符串的内容，注意区分大小写
boolean equals(Object obj)
    
//忽略字符串大小写比较字符串内容，常见用于比较网址URL
boolean equalsIgnoreCase(String str)
    
//判断当前字符串对象是否包含，目标字符串的字符序列，常见用于确定是否有盗链行为
boolean contains(String str)
    
//判断当前字符串对象，是否已目标字符串的字符序列开头
boolean startsWith(String str)
    
//判断当前字符串，是否以目标字符串对象的字符序列结尾，常用于确定文件后缀名格式
boolean endsWith(String str)
    
//判断一个字符串，是不是空字符串
boolean isEmpty()
```



> String类的获取功能

```Java
// 获取当前字符串对象中，包含的字符个数
int  length()  
    
//获取字符串对象代表字符序列中，指定位置的字符
char charAt(int index) 
    
//在当前字符串对象中查找指定的字符，如果找到就返回字符，首次出现的位置，如果没找到返回-1
//也可以填字符
int indexOf(int ch) 
    
//指定从当前字符串对象的指定位置开始，查找首次出现的指定字符的位置，(如果没找到返回-1)
//可以填入字符
int indexOf(int ch,int fromIndex) 
    
//查找当前字符串中，目标字符串首次出现的位置(如果包含)，找不到，返回-1
//这里的位置是指目标字符串的第一个字符,在当前字符串对象中的位置
int indexOf(String str)

//指定，从当前字符串对象的指定位置开始,查找首次出现的指定字符串的位置(如果没找到返回-1)
//这里的位置是指目标字符串的第一个字符,在当前字符串对象中的位置
int indexOf(String str,int fromIndex) ，

//返回字符串，该字符串只包含当前字符串中，从指定位置开始(包含指定位置字符)到结束的那部分字符串
String substring(int start) 
    
//返回字符串，只包含当前字符串中，从start位置开始(包含)，到end(不包含)指定的位置的字符串
String substring(int start,int end) 
```



> String类的转换功能

```Java
//获取一个用来表示字符串对象字符序列的，字节数组
byte[] getBytes()
    
//获取的是用来表示字符串对象字符序列的，字符数组
char[] toCharArray() 

//把字符数组转换成字符串
static String valueOf(char[] chs)

//把各种基本数据类型转换成字符串
static String valueOf(int i/double...)

//把字符串全部转化为小写
String toLowerCase() 
    
//把字符串全部转换为大写
String toUpperCase()

//字符串拼接，作用等价于 + 实现的字符串拼接
String concat(String str) 
```



> String类的其他功能



- 替换功能

  - ```Java
    // 在新的字符串中，用新(new)字符，替换旧(old)字符
    String replace(char old,char new)
        
    //在新的字符串中，用新的字符串(new), 替换旧(old)字符串
    String replace(String old,String new)
    ```

  - 需要注意的是，替换不是在原对象上替换，而是创建了新的对象

  - ```java
    //使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。
    String replaceAll(String regex, String replacement)
    //使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。
    String replaceFirst(String regex, String replacement)
    ```

    

- 去除空格字符

  - ```Java
    //在新的字符串中，去掉开头和结尾的空格字符
    String trim() 
    ```



- 比较功能

  - ```Java
    String类的比较功能
    int compareTo(String str)
    int compareToIgnoreCase(String str)
    ```



>  字符串的大小如何比较？
>        按照字典序，比较字符串的大小。字典序原本的含义实质，英文单词在字典中出现的先后顺序
>       (在字典中，先出现的字符串小，后出现的字符串大)
>
>  具体到编程语言，是根据两个字符串字符串从左往右数
>
>  ​	第一个对应位置的不同字符，来决定两字符串的大小
>  ​        hello
>  ​        head
>
>  ​      compareTo几乎就是按照字典序，来比较两个字符串大小的
>
>  ​       字符串对象.compareTo(字符串对象)
>
>  compareTo方法返回值，如果是=0则表示对象相等，>0则表示左边对象大于右边对象
>
>  <0则表示右边对象大于左边对象



结合克隆方法和String 两部分知识

思考:

Object类中的clone方法是浅克隆,那么如果一个类中有String的引用数据类型 成员变量,需不需要做深度克隆?

不需要,深度克隆本质上因为引用的拷贝和原先的引用共用了同一个对象

String虽然是对象 但是它不可变 任何时候 你只要修改 就直接创建新对象



# 反射 没看懂

> java.lang.Class 1.0
>
> * static Class forName(String className)
>
>   返回描述类名为clasName的Class对象。
>
> * Object newInstance()
>
>   返回这个类的一个新实例。
>
> java.lang.reflect.Constructor 1.1
>
> * Object newInstance(Object[] args)
>
>   狗仔一个这个构造器所属类的新实例。
>
>   参数：args 这是提供给构造器的参数。
>
> java.lang.Throwable 1.0
>
> * void printStackTrace()
>
>   将Throwable对象和栈轨迹输出到标准错误流。

# 异常

## Java异常概述

> 异常，异常，即是程序运行出现了不正常的情况，报错，并导致程序终止

- 为什么学习异常？
  - 虽然程序员在写程序的时候，总是想把代码写得尽善尽美，充分考虑用户使用的各种情况
  - 但是程序在运行的过程中仍然会碰到非常多的问题
    - 即理想的情况：我们的程序永远不出bug，永远没有问题
    - 实际情况：程序总会出现各种问题
  - 为了描述和处理这些问题，Java就引入了异常体系
- Java当中一切皆对象，当程序产生异常，JVM会把这个异常信息封装成一个对象（类）
  - 类中封装着问题的名称，产生的原因、描述等多个属性信息存在
  - 以及对这些信息进行操作的一系列方法（属性+行为）
  - 这些类通过继承层次构成了Java的异常体系
- 学习异常之前，需要明确的一个重要点
  - 异常的类和对象中只是存了异常的信息
  - 包括异常的原因，异常的种类等等
  - 但是何时抛出异常，怎么处理异常，不是由异常对象决定的



> Java程序运行时碰到了一系列的问题

- 编译时期，必须要检查处理的异常，不检查不能通过编译。即便发现了问题，仍然可以解决
- 运行期间，无法预料的问题，但是出现问题后，我们仍然能解决它
- 运行期间，无法预料的问题，但是出现问题后，无法解决它，是一个严重的错误



> 我们一般根据问题能不能处理，也就是问题的严重程度，来区分异常和错误

- Java程序运行时碰到了一系列的问题
  - 严重问题
    - 运行时，无法预料，且无法解决的错误
  - 一般问题
    - 编译时要检查处理的异常，出现问题，可以被解决
    - 运行时，无法预料，且能够被解决的问题



> Java异常体系确实就是这样划分的

- Throwable（祖先类）

  - Error
  - Exception
    - RuntimeException
    - 非RuntimeException

- Throwable是Java一切错误和异常的父类，是继承层次中的祖先类

  - 表示可以由程序显式或者JVM抛出的问题

- Error是严重问题，无法被解决 

  - Error描述了Java运行时虚拟机内部错误和资源耗尽错误
  - 对于Error，程序自己是无能为力的，仅靠程序本身是无法恢复和和预防
  - 于是程序只能尽量安全得保存数据， 然后终止程序，并通知用户去解决
  - 常见的Error是栈溢出，或者堆溢出这些错误

- Exception是一般问题，能够被解决

  - RuntimeException，指的是在程序运行期间，发生的一般问题，称之为运行时异常
    - 这种问题无法在编译时检查和预料，只有到程序运行后才能显现问题
    - 例如用null调用方法，数组使用错误的下标，错误的强制类型转换
    - RuntimeException可以写代码进行正常的处理，属于一般问题

  > 需要明确的是：
  >
  > 运行时异常绝大多数都是因为编码问题所导致的
  >
  > 也就是可以避免的异常，当程序抛出该异常后，最好能够重构代码，修正问题

  - 非RuntimeException，指的是在编译时期，就需要显式的检查并处理的异常，称之为编译时异常
    - 部分书籍也称其为，受检查的异常（Checked Exception）
    - 这种异常必须在编译期检查和处理
    - 例如打开一个文件夹（要考虑该文件夹存不存在）
    - 克隆一个对象（要检查该类是否实现Cloneable接口）
    - Exception的子类中，只要不是RuntimeException的子类，那必然是非RuntimeException



> Error和Exception的异同

- 两者都继承自Throwable类，共同构成了Java的异常体系
- Error类一般是指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢出等
  - 对于这类错误的导致的应用程序中断，仅靠程序本身无法恢复和和预防
  - 遇到这样的错误，只好尽量安全得保存数据， 然后终止程序，并通知用户去解决
  - Error一般都不由程序显式的抛出，而是由JVM抛出
- Exception类表示程序可以处理的异常，可以捕获且可能恢复
  - 遇到这类异常，应该尽可能处理异常，使程序恢复运行，而不应该随意地终止程序
  - Exception又分为RuntimeException（运行时异常）和非RuntimeException（编译时异常）
    - 运行时异常不受编译器检查，在程序运行期间发生，一旦发生，若不处理就会导致程序终止
      - 运行时异常包括所有RuntimeException的子类
    - 编译时异常受编译器检查，必须显式地处理该异常，才能够通过编译
      - 编译时异常包括所有Exception的子类中，非RuntimeException的子类的类



> Java设计异常体系的原则

- 尽量把一切错误，摒弃在程序运行之前，最好在编译时期就发现程序潜在的问题（通过编译器）
- 确实，Java把相当一部分异常定义为编译时异常，让程序员在编译时期就显式的处理它们
- 但仍然有很多问题，必须要Java程序运行起来，才可能产生，被发现，是编译器检查不到的
  - 这就是运行时异常

# 异常的处理

> Java程序的异常处理分为两种方式
>
> - 自己处理
> - 向上抛出

- 某个方法发生了异常

  - 自己解决
  - 抛给该方法的调用者

- 调用者（方法）拿到了异常

  - 自己解决
  - 抛给该方法的调用者

- 这个过程可以将异常一直向方法的调用者抛出，但不可能是无限的

  .........

- 最终main方法，程序的入口方法拿到了该异常，它可以选择

  - 自己解决
  - 继续抛出

- 这个时候，能接收main方法抛出的异常的，就只有JVM

  - JVM必须自己处理该异常



## Java默认的异常处理机制

> 如果我们在程序中，不写任何和异常处理相关的代码，Java程序仍然能够对异常进行处理

- 如果错误产生在main方法中
  - 当我们的代码执行到错误行数之前，代码是正常执行的
  - 当我们的代码执行到错误行数时，JVM会终止程序的执行，抛出一个该异常信息封装成的对象
  - 将该对象中的异常信息，打印到控制台上，告诉程序员发生了什么问题
  - 发生错误之后的语句，都不执行了
- 如果错误产生在main方法当中的另一个方法中
  - 当程序执行到该方法的错误行数时，JVM会终止程序的执行
    - 向上给方法的调用者抛出一个该异常信息封装成的对象
  - 一直向上抛出，直到抛给main方法，main方法最终抛给JVM
  - 发生异常之前的语句正常执行，但是之后的语句都不执行了



## 自定义（手动）异常处理

> 显然，Java默认的异常处理机制，总会导致程序终止执行，这不能够满足我们的需求
>
> 我们需要手动显式的来处理异常，以达到自己的目的

### 捕获异常，自己处理

> Java提供了结构try....catch用来捕获并处理异常

#### 单分支try...catch

- 顾名思义，其语法为

  - ```Java
    try {
     //可能出现异常的，正常的代码逻辑
    } catch(要捕捉的异常对象) {
     //每一个catch分支对应一个异常处理器
     //在catch分支中处理具体类型的代码异常
    }
    ```

- 如果try代码块中发生了异常，那么JVM就会收集这个异常的信息，封装成对象

- catch语句中需要填入一个对象引用作为匹配，而不是使用类型来匹配

  - 这个引用接收（指向）JVM封装的对象

- catch语句中可以填入多个对象来作为匹配

  - ```java
    catch(要捕捉的异常类型1 | 要捕捉的异常对类型2 | 要捕捉的异常类型3 对象名e...){
        //e隐式为final
    }
    //注：捕获多个异常时，异常变量隐含为final变量，不能在子句体中为e赋不同的值。
    ```
  ```
    
  - 注意：无论你能够匹配多少种异常类型，始终都只有一个异常对象被接收，对象名只写一个
  ```

- catch当中填入要捕捉的异常类型，如果能够匹配这个对象，那么就会执行catch代码块中的代码

  - 怎么算匹配？
  - 可以就是这个类的对象
  - 也可以是这个类的子类对象
  - catch代码块中语句可以对该异常进行处理

- 一旦匹配成功，catch中写的异常对象就会接收JVM抛出的异常对象

- 匹配失败，那么程序依然会自动向上抛出异常，直到JVM默认处理

- try代码块中发生了异常，在catch代码块中被处理了，那么程序仍然能够继续执行

> 单分支try...catch使用注意事项

- try...catch会显著的影响代码结构，严重影响代码可读性
  - 所以应该把尽量少的代码放入try中，最好是产生异常的那一行代码

- 如果catch不能匹配异常对象，那么不会执行catch代码块中的内容
- 只有当try代码块中产生了异常，catch才有机会执行，没有异常不执行，不匹配也不执行
- 当实在不清楚异常的种类时，可以使用Exception接收（但实际上这是偷懒程序员的借口）
- try代码块中某个位置产生了异常，那么try中的代码就不继续执行了
  - 也就是说try当中要么不产生异常，要么只会产生一个异常



#### 获取捕获异常对象中的异常信息

> 既然能捕获该异常对象，那么获取其中的异常信息也是势在必行的
>
> 使用捕获的异常对象，能够调用的常用API有

```Java
//获取异常信息，返回字符串。打印的实际上是异常产生的原因 
（不使用）String getMessage()
//获取异常类名和异常信息，返回字符串。 打印的是异常产生的原因和所在类
（不使用）String toString()
//获取异常类名和异常信息，以及异常出现在程序中的位置
（推荐使用）void printStackTrace()
//使用IO流，将异常内容保存在日志文件中，以便查阅，早已过时，了解即可
（过时的日志处理方式）printStackTrace(PrintStream s) 
```



#### 多分支try...catch

> 如果代码只会发生一个异常，那么单分支的try...catch就够用了，那么如果发生多个异常呢？

- 语法为

  - ```Java
    try {
     //可能出现异常的，正常的代码逻辑
    } catch(要捕捉的异常对象1) {
     //每一个catch分支对应一个异常处理器
     //在catch分支中处理具体类型的代码异常
    }catch(要捕捉的异常对象2) {
     //每一个catch分支对应一个异常处理器
     //在catch分支中处理具体类型的代码异常
    }
    ...
    ```

- 该格式和单分支try...catch并无实质不同，只是多个几个catch分支而已

- 多分支try...catch的匹配流程

  - 根据实际的异常对象的类型，和catch中声明的异常类型，从上到下一次做类型匹配
  - 一旦通过类型匹配，发现实际异常对象的类型和catch中的异常对象类型匹配
    - 就把该异常对象交给这个catch分支进行处理（异常处理器）
  - 没有相匹配catch代码块的异常，那么程序依然会自动向上抛出异常，直到JVM默认处理



> 多分支try...catch使用注意事项

- 多分支的异常处理的执行，有点类似于多分支if-else的执行，一次匹配，只会执行多个catch分支中的一个

- 如果多个catch中处理的是毫无关系的异常，那么catch的顺序并不需要特别注意

- 如果多个catch中处理的异常有父子关系，那么就必须要注意了

  - 如果父类异常写在了上面，那么子类异常的catch分支就永远没有机会执行了，并且会报错

- 所以，应该把具体子类放在catch分支的上面作类型匹配，父类放在后面作兜底

- catch()括号当中，尽量不要写Exception这种大而宽泛的异常

  - 而是应该写具体的异常，越具体越好
  - 这样对处理异常有帮助，能够清晰定位异常的类型

- 两种运行时异常

  - ```
    NullPointerException： 运行时异常，空指针异常，用一个等于null的引用调用了方法和成员变量
    IndexOutOfBoundsException：运行时异常，数组下标越界异常。调用了超过数组最大下标的位置
    ```



### 抛出异常，上层处理

> 程序总会有在异常发生处不想处理该异常的情况，Java提供了向上层抛出异常的解决方案



#### throws关键字

> throws关键字表示在方法上抛出异常

- 在方法声明时使用，声明该方法可能抛出的异常类型

语法:

```java 
方法名(形参列表) throws 异常列表{
}
```

注意事项:

- 运行时异常会自动向上抛出，不用我们手动throws
  - 我们只需要手动throws编译时异常
- 如果方法抛出一个编译时异常，可以在语法层面，强制要求方法调用者处理该异常

- 异常列表可以是多个异常类，但是注意用逗号隔开
- 列表中出现的异常如果有父子关系，那么编译器只会强制要求处理父类
  - 所以尽量抛出同级别的异常



方法覆盖中的异常列表匹配问题

>  首先，异常说明属于方法声明的一部分，紧跟在形式参数列表之后
>
>  方法的声明中加了throws关键字表示所有要抛出的潜在异常类型后
>
>  方法在重写的时候也会发生一些变化

- 总体上的原则是：子类中的覆盖方法，不能比父类中的方法抛出更多异常
  - 因为Java中存在多态现象，当用父类引用调用方法时
  - 如果允许子类重写后有更多的异常，那么就没有办法处理
  - 运行时异常显式抛出对程序并无影响，那么子类重写方法可以多抛出运行时异常
- 如果子父类方法，完全抛出相同的异常，允许进行方法的重写
- 如果父类方法没有抛出异常，子类重写方法，要么也不抛出异常
  - 要么就只能抛出运行时异常（本身就是自动的，不算多）
- 如果父类方法抛了异常，那么
  - 子类重写方法可以选择完全不抛出异常
  - 如果父类方法抛出的是RuntimeException，那么子类重写方法也只能抛出RuntimeException
    - 种类不限制，允许类型不同
    - 父类方法抛出一个RuntimeException子类，子类方法重写可以是RuntimeException
  - 如果父类方法抛出的是编译时异常，那么子类重写方法
    - 可以抛出相同的编译时异常，但不能抛出不同的编译时异常
    - 抛出所有运行时异常
    - 不可以抛出Exception
  - 如果父类方法直接抛出Exception
    - 那么子类重写方法就可以抛出任何异常了



> 我们其实并不需要特别记忆这些规则，实际开发中，我们并不是像老师上课一样，需要一点不能出错。我们可以不断的尝试，然后最终提交出一份正确的代码。这样，我们仍然是一名优秀的Java开发工程师。如果面试中被问到，建议直接说子类中的覆盖方法，不能比父类中的方法抛出更多异常即可。

- 建议在开发中，子父类重写方法拥有一致的抛出异常列表
- 避免自找麻烦



#### throw

> 在很多时候，我们不满于在方法声明中声明要抛出的异常的类型，我们想要直接在方法内部抛出异常

概述：

​	  1.在方法体中使用，主动在方法中抛出异常

​	  2.每次只能抛出确定的某一个异常对象

基本语法：

```Java
  throw 异常对象;
```

注意：

- 每次只能抛出一个异常对象
- 一旦程序运行到该throw代码，必然会抛出一个异常对象
- 在方法中抛出一个异常，相当于使用了return关键字
  - 方法立刻结束，后面也不能有其它代码了
  - throw必须位于方法的最后一行
- 每个异常类的构造方法都可以显式得传入一个字符串，表示异常信息（原因）的说明
- 如果在方法中显式地抛了一个编译时异常
  - 那么会和产生编译时异常的代码一样，需要显式处理
  - 最好和throws一起使用（如果try...catch就没有意义）
- 一旦主动使用throw关键字，就代表在当前方法中，必然不会处理该异常，此时直接抛给方法调用者去处理
- 举例：
  - 结合成员变量的封装和set方法，判断输入的参数是否合法（IllegalArgumentException）
  - 空接口（Cloneable）

```Java
private static void testThrowCheckableDemo() throws CloneNotSupportedException {

    throw new CloneNotSupportedException("发生了禁止克隆异常");

}

private static void testThrowRuntimeDemo() throws NullPointerException{

    throw new NullPointerException("发生了空指针异常");

}
```



> 编译期异常和运行期异常的区别?

- 必须要显式处理的，否则编译不通过
- 无需显示处理，编译就能通过
  - 可以不处理，也可以处理
  - 不推荐使用异常处理，而应该修改代码逻辑



#### throws和throw的区别

​	throws

```
1.用在方法声明后面，跟的是异常类名

2.可以跟多个异常类名，用逗号隔开

3.表示抛出异常，由该方法的调用者来处理

4.throws表示出现异常的一种可能性，并不一定会发生这些异常
```

throw

```
1.用在方法体内，跟的是异常对象名

2.只能抛出一个异常对象

3.表示抛出异常，可以由方法体内的语句处理（多此一举） 最常见的是结合throws抛给调用者去处理

4.throw则是抛出了异常，执行throw则一定抛出了某种异常
```



##### 到底是该try还是该抛出

总结一下，目前为止，我们所学习过的异常的处理策略主要有两种：

  1.捕获并处理 try -catch

  2.向上抛出。

 运行时异常会自动上抛，直到抛给JVM

 编译时异常需要用throws关键字向上抛出

那么究竟，在遇到异常时我们该如何选择处理策略呢？

原则：

```
 对于运行时异常，我们不应该写出产生这种异常的代码，应该在代码的测试阶段修正代码。
 对于编译时异常，功能内部能够处理的就处理，如果不能够或者没有必要处理，就抛出。
```

#### finally

finally的特点

1.无论try中是否发生异常，都会执行

2.try-catch代码中有return也不能阻止它

3.特殊情况：在执行到finally之前jvm退出了

  System.exit(0)

finally的作用

用于释放资源，在IO流操作和数据库操作中会见到

```java
private static void method() {
    try {
        System.out.println(10/0);
    }
    catch (ArithmeticException e){
        e.printStackTrace();
        System.exit(0);
    }
    finally {
        System.out.println("finally");
    }
}
```

2:如果在try里面有return,请问finally还执行吗?如果执行,在return前还是后

会。 前面。return是最后一步，返回结果



 注意事项：

如果try中遇到了return，那么暂时不执行这个return

先去执行finally中的语句

1.如果finally中没有return，那么执行完finally后再回到try中执行return语句。

2.如果finally中也有return，那么执行完finally语句中的return后，不会再回到try中了！

3.执行完return语句后，返回值无论怎么修改，都不会改变打印结果。

4.如果没catch到，但是finally中有return,会直接执行finally中的return，异常的抛出就无法执行到了

try...catch变形

```
		try...catch...finally
		try...catch...
		try...catch...catch...
		try...catch...catch...fianlly
		try...finally
```

try...finally在IO操作中比较常见，异常抛给上层，但必须释放资源。

#### final，finally和finalize的区别

```
  final:  最终的
	可以修饰类 成员变量 成员方法
       类:类不能被继承
       成员变量:常量
       成员方法: 不能被重写
   finally: 异常处理体系当中,用于资源释放.最大的特点 不发生特殊情况 必然会执行
   finalize: Object()类中的成员方法,垃圾回收。但是注意jvm有自己的垃圾回收机制，并不会因为你调用这个方法就立刻回收对象。
```

## 解耦合try/catch和try/finally

内层try语句块只有一个之策，就是确保关闭输入流。外层的try语句块也只有一个职责，就是确保报告出现的错误。这种设计方式不仅清楚，而且还具有一个功能，就是将会报告finally子句中出现的错误。

```java
InputStream in = ...;
try
{
    try
    {
        code that might throw exception
    }
    finally
    {
        in.close();
    }
}
catch(IOException e)
{
    show error message
}
```

> 只要需要关闭资源，尽可能使用带资源的try语句，这样原来的异常会重新抛出，而close方法抛出的异常会“被抑制”。这些异常将自动捕获，并由addSuppressed方法增加到原来的异常。如果对浙西而一场感兴趣，可以调用getSuppressed方法，他会得到从close方法抛出并被抑制的异常列表。不论这个块如何退出，in和out资源都会关闭。

# 自定义异常

自定义异常

  继承自Exception：编译时要检查

  继承自RuntimeException：编译不需要检查

通过已有异常类的构造方法添加message也可以实现输出不同的信息，那么为什么还要去实现我们自己的自定义异常呢？

因为用已有异常添加message的方法虽然在抛出时，和自定义异常是一样的。但是无法单独catch，单独处理。

# File类

> File类概述

- 在操作系统中，数据都是以文件的形式，永久保存在外部储存设备上的
- 做开发的时候，难免需要对文件进行操作，比如检查作业，上传作业
- 根据Java当中一切皆对象的思想，这个时候我们需要一个对象用来操作文件
- 于是Java引入了File类用来描述文件或者文件夹（目录）
- File类位于java.io包下，是Java进行IO操作的核心类
- File是文件和目录（文件夹）路径名的抽象表达形式



> 绝对路径和相对路径

- 绝对路径
  - 绝对路径名是完整的路径名，根据绝对路径可以唯一确认文件和目录
  - 例如：E:\demo\first\a.txt
- 相对路径
  - 相对路径是不完整的路径名，只依赖相对路径不能唯一确认文件和目录
  - 相对路径名必须使用其他路径名的信息进行解释，也就是常说地相对于“某个路径”
  - 相对路径是不跟盘符和路径分隔符的
  - 例如相对于（E:\demo）下的first\a.txt文件







> 绝对路径可以唯一确认一个文件，相对路径却不可以
>
> 那么在IDEA中写代码，如果使用一个相对路径来表示文件
>
> 那这个相对路径又是相对于谁呢？

- 默认情况下，java.io包中的类总是根据当前用户目录来解析相对路径名

- 此目录由系统属性user.dir指定，通常是 Java虚拟机的调用目录

- 可以使用以下代码获取

  - ```Java
    System.getProperty("user.dir")
    ```

- 这个属性默认是project的根目录

- 可以在run configuration中修改

- 一般情况下默认就好了

- 普遍来说，在Java程序中应该优先使用绝对路径，因为相对路径会随着环境的改变而指向不同的文件



> 不同操作系统下路径名表示的符号其实是有区别的
>
> Microsoft Windows平台

- Windows操作系统下，包含盘符的路径名前缀由驱动器号和一个 ":" 组成

- 后面不同层级目录用“\”或者“\\”表示

- 例如

  - ```
    绝对路径： e:\demo\a.txt
    相对路径： （相对于e:\）demo\a.txt
    ```



> 类Unix平台
>
> 包括Unix系统，Linux系统，macOS系统

- 这些系统是没有盘符标识的，而是用一个“/”表示根目录

- 绝对路径就是从根目录开始的，一个完整的目录，后面的每个层级都用“/”分隔

- 相对路径则不从根目录开始

- 例如

  - ```
    绝对路径：/home/demo/a.txt
    相对路径：（相对于/home/demo）a.txt
    根目录：/
    ```



> 转义字符 ‘\xxx’

- ```
  '\t'表示制表符
  ```

- ```
  '\r'表示回车
  ```

- ```
  '\n'表示换行
  ```

- ```
  '\\'表示字符串"\"
  ```




> 根据以上种种特征，那么我们怎么在Java程序中表示一个文件或者目录呢？
>
> 难道我们需要在用Windows写代码测试的时候用“\\”，而在代码上线后用"/"吗？

- 当然不需要，Java早已是一门成熟的语言，跨平台性上，已经对路径符号作了优化
- 你可以自由选择以下一种方式书写路径名，都是可以的
  - 全部用“//”
  - 全部用“\\”（推荐使用）
  - 全部用“/”
- 不要使用“\”，单独使用“\”，这是一个转义字符

# File类的使用

> 首先，在使用File之前，再明确一下File类的定义
>
> File是文件和目录（文件夹）路径名的抽象表达形式F

- File类是对文件、目录的抽象表示，并不代表这个文件和目录就一定存在

- 创建File类对象的时候，编译器也不会去检查这个File对应的文件和目录是否存在

- 用一个file对象调用以下方法，可判断该目录文件是否存在

  - ```java 
    public boolean exists()
    ```




> File类的构造方法

```java
//创建一个File对象，该方法一般使用绝对路径来创建对象，也可以使用相对路径
File (String pathname)
    
//和第一种方式类似，只不过把一个路径劈成了两半
//普遍来说，parent路径表示一个绝对路径。child路径跟一个相对路径
File (String parent, Sting child)
    
//和第二种方式一样，只不过，子路径用一个File对象表示
File (File parent, String child)
```



# File API

> 几个属性

```java 
//与系统有关的多个路径名的分隔符 “;”
static String pathSeparator 
//与系统有关的单个路径层级的分隔符 “\”
static String separator 
```

- 已经没有什么实用意义了，了解知道即可



## 创建功能

```Java
//只负责创建文件，目录路径如果不存在，会报错而不是帮你创建
public boolean createNewFile() 

//只负责创建目录，但只能创建单层目录，如果有多级目录不存在的话，创建失败
public boolean mkdir()
    
//只负责创建目录，但可以创建多级目录，如果多级目录不存在，则帮你全部创建
public boolean mkdirs()
```

- createNewFile()只能创建文件，不能创建目录，会报错
- mkdir()和mkdirs()的区别就在于能否创建多级目录
  - 需要注意的是，它两个都不能创建文件
  - 如果File对象路径中包括文件名，它会把文件名当成目录名处理



## 删除功能

```Java
public boolean delete()
```

- 删除此抽象路径名表示的文件或目录。如果此路径名表示一个目录，则该目录必须为空才能删除
- 该方法删除后不会到回收站



## 移动且重命名文件功能

```Java
public boolean renameTo(File dest)
```

- 当源文件和修改之后的目标文件，在同一目录的时候，效果只是重命名
- 当源文件和修改之后的目标文件，不在同一目录的时候，效果是移动且重命名
- 真正操作文件，应该使用（IO流操作）    



## 判断功能

```Java
//判断File对象是否表示的是一个文件
public boolean isFile()
    
//判断File对象是否表示的是一个目录
public boolean isDirectory()
    
//判断File对象表示的文件或目录，是否真实存在
public boolean exists()

//判断File对象表示的文件，是否可读
public boolean canRead()

//判断File对象表示的文件，是否可写
public boolean canWrite()

//判断File对象表示的文件是否是隐藏文件
public boolean isHidden()
```



## 获取功能

```Java
//获取File对象表示的抽象文件的绝对路径
public File getAbsolutePath()

//获取File对象表示的抽象路径名的字符串，简单来说，创建的时候给的是什么就输出什么
public String getPath()

//获取File对象表示的文件或者目录的文件名
public String getName()
    
//返回由此抽象路径名表示的文件的所占硬盘空间大小，以字节为单位
//但是需要注意的是，这个方法只能获取文件的大小，不能获取目录大小
public long length()

//返回此File对象表示的文件的最后一次修改的时间
public long lastModified()
```



## 高级获取功能

```Java
//返回一个字符串数组，这些字符串包括，此抽象的路径名表示的目录中的所有文件和文件夹的名字
//如果File对象表示的是一个文件，则返回null
//只能获取当前目录的下一层，并不是获取所有层级
//如果是一个空目录，返回一个长度为0的数组，而不是null
public String[] list() 
    
    
//返回指定File目录下的文件和文件夹的绝对路径形式的File对象数组
//如果File对象表示的是一个文件，则返回null
//只能获取当前目录的下一层，并不是获取所有层级
//如果是一个空目录，返回一个长度为0的数组，而不是null
public File[] listFiles()
```

以上可以用来判断是否为文件或文件夹，但是没有必要。



## 自定义获取功能

```java 
//获取这个文件夹下，满足filter过滤器的条件的文件
File[] listFiles(FileFilter filter) 
```

- 自定义获取功能是在高级获取功能的基础上，加了一个过滤器，所以高级功能的特点它都有

- FileFilter是一个接口，它只有下面一个方法

  - ```Java
    //测试指定抽象路径名是否应该包含在某个路径名列表中
    boolean accept(File pathname)
    ```

  - 这个方法相当于把高级功能中listFiles()获取的File数组中File对象遍历一遍，然后逐个判断

  - 符合条件的留下，不符合条件的干掉（丢弃）- 

- 常用匿名内部类来做实现

```Java
//留下所有txt文件
public class FileTest2 {
    public static void main(String[] args) {
        File file = new File("E:\\temp");
        //匿名内部类创建一个过滤器
        FileFilter fileFilter = new FileFilter() {
            @Override
            public boolean accept(File dir) {
                //条件是 dir对象是一个文件并且它的名字以txt结尾
                return dir.isFile() && dir.getName().endsWith("txt");
            }
        };
        //在有过滤器的情况下创建一个File[]数组，并且遍历
        File[] files = file.listFiles(fileFilter);
        for(File f : files){
            System.out.println(f);
        }
    }
```

- 补充Arrays.sort(files, new Comparator<File>())方法



> 递归删除目录的思路

- 获取目录的下的所有File对象（包括文件和文件夹）
- 判断，如果是一个空目录或者file对象不是一个目录而是文件
  - 直接删除
- 程序执行到这里，那么一定是一个目录，且不是空目录
  - 遍历获取的file数组
  - 如果这个file对象仍然是一个目录，递归删除该目录
  - 如果这个file对象是文件，直接删除
- 最后不要忘记删除已经是空目录的当前目录

# 基本数据类型对象包装类概述

基本类型包装类的产生  

  在实际程序使用中，程序界面上用户输入的数据都是以字符串类型进行  存储的。而程序开发中，我们需要把字符串数据，根据需求转换成指定的基本数  据类型，如年龄需要转换成int类型，考试成绩需要转换成double类型等  

基本数据类型，都有对应的引用数据类型。

* byte Byte
* short Short
* int Integer
* long Long
* char Character
* float Float
* double Double
* boolean Boolean

```java
//把字符串转化为int,Integer类parseInt方法
int i = Integer.parseInt("12");
System.out.println(i/2);//6

//Integer或int转成字符串
//使用+与字符串拼接
int i = 3;
String s = i+"";
System.out.println(s+1);//"31"
//toString(int ,int 进制),任意进制整数转成任意进制的字符串 (了解)
String s1 = Integer.toString(5,2);//二进制字符串形式

/** Integer类构造方法
*   public Integer( int value)
* 	public Integer ( String s)
*   将数字格式的字符串,传递到Integer类的构造方法中
*   创建Integer对象,包装的是一个字符串
*   将构造方法中的字符串,转成基本数据类型,调用方法,非静态的
*	intValue()
*/
Integer ii =new  Integer(10);
Integer in = new Integer("100");
int i = in.intValue();

//Integer类常用方法
/** Integer类的3个静态方法
* 十进制转成二进制  toBinarString(int)
* 十进制转成八进制  toOctalString(int)
* 十进制转成十六进制 toHexString(int)
* 三个方法,返回值都是以String形式出现
*/
System.out.println(Integer.toBinaryString(99));
System.out.println(Integer.toOctalString(99));
System.out.println(Integer.toHexString(999));
/** 获取int的最大值和最小值
*   Integer类的静态成员变量
*   MAX_VALUE
*   MIN_VALUE
*/
System.out.println(Integer.MAX_VALUE);
System.out.println(Integer.MIN_VALUE);

//int类型和String类型的相互转换
//int -->String
//方式1：字符串拼接
String s1=""+number;
System.out.println(s1);
//推荐方式2
//方式2：String的方法:可以把任意类型的转换成字符串
String s2  =String.valueOf(number);
System.out.println("s2 = " +  s2);
//方式3
Integer i= new  Integer(number);
System.out.println(i.toString());
//方式4：
String s4=Integer.toString(number);
System.out.println(s4);
//String -->int
String s="100";
//方式1：
//String--Integer---int
Integer ii =new  Integer(s);//把String类型转成Integer类型
int  x=ii.intValue();//把Integer类型转成int类型
System.out.println(x);
//方式2：很重要，同理，类似float
//public static int parseInt(String s)
int  y=Integer.parseInt(s);
System.out.println(y);
```

自动装箱和自动拆箱  

自动装箱,拆箱的 好处: 基本类型和引用类直接运算  

自动装箱:  

使用Integer.valueOf(整数值)返回一个封装了该整数值的Integer对象，即把 基本类型转为引用类型  

自动拆箱:  

使用Integer对象.intValue()返回Integer对象中封装的整数值，把引用类型转为基本数据类型

```java

public  static  void  function(){
//引用类型  ,引用变量一定指向对象
//自动装箱,基本数据类型1,直接变成了对象
Integer  in  =  1; //  Integer  in  =  new  Integer(1)
//in是引用类型,不能和基本类型运算,自动拆箱,引用类型in,转换基本类型
//in+1  ==>  in.inValue()+1  = 2
//in  =  2自动装箱
in  =  in  + 1;
System.out.println(in);
```



# StringBuffer

1. 概述：表示一个字符串缓冲区，它的对象是可变的。也是线程安全的可变字符序列。
   底层为字符数组。初始容量为16，可以自动扩容。这个大小为16的初
   始空间不存储东西，作为预留空间；比如存储一个长度为13的字符串，容量就变为了29。
2. StringBuffer和String的区别?  
   * StringBuffer:  对象可变的字符序列，对象是变量，在堆上
   * String:  对象不可变的字符序列,对象是常量，在常量池
   * String 作为参数传递类似于基本数据类型作为参数传递  (对象的不可改变 性)。
   * StringBuffer 作为参数传递就是引用数据类型传递（对象可以改变）  

String,StringBuffer,StringBuilder的区别  

* String:  不可变的字符序列
* StringBuffer:  可变的字符序列，线程安全的，效率低.
* StringBuilder: 可变的字符序列，线程不安全的，效率高。

StringBuffer和数组的区别 

* StringBuffer和数组都可以看成是一个容器
* StringBuffer可以自动扩容，数组长度是固定的
* 数组只能存储一个数据类型，StringBuffer可以把任意数据类型转换  成字符来存储  

StringBuffer的构造方法

```java
//A.public StringBuffer()  
StringBuffer sb = new StringBuffer(); System.out.println(sb);  
System.out.println(sb.length()); //0  System.out.println(sb.capacity()); //默认值16  

//B.public StringBuffer(int  capacity)  
StringBuffer sb = new StringBuffer(4);
System.out.println(sb); System.out.println(sb.length()); // 0  System.out.println(sb.capacity()); //4  

//C.public  StringBuffer(String str)  
StringBuffer sb = new StringBuffer("Hello, wuhan!"); System.out.println(sb);  
System.out.println(sb.length()); //长度为13  
System.out.println(sb.capacity()); //容量为13+16 = 2
```

StringBuffer的常见功能（成员方法）

```java
//int capacity() 返回容量 (初始值为16，并且可以自动扩容)
//int length()   返回长度

//A:添加功能
//public StringBuffer append(String str) 可以把任意类型追加进StringBuffer并且在append之后，StringBuffer对象本身也会变化，所以可以直接返回该对象，不需要新建对象来接收。和String不同
StringBuffer  sb  =  new StringBuffer("Hello");
System.out.println(sb);  //输出Hello
StringBuffer  sb1  =  sb.append(", world!");
System.out.println(sb);  //  Hello  World
System.out.println(sb1);//  Hello  World
System.out.println(sb  ==  sb1);  // true

sb.append(",  world!");
System.out.println(sb);  //Hello  World
//可以链式编程
sb.append("world").append("wuhan").append("shenzhen");
System.out.println(sb);

StringBuffer  sb  =  new StringBuffer();
Date  date  =  new Date();
System.out.println(date);
char[]  chars  =  {'爱', '我',  '中',  '华'};
sb.append(100).append('中').append(true).append(3.14).append(date).append(chars);
System.out.println(sb);  //会把字符的原本形式拼接进来

//public StringBuffer insert(int offset,String str)  
//可以把任意数据类型，指定偏移位置插入字符串
StringBuffer  sb  =  new StringBuffer("abcd");
sb.insert(2,  '中');  //  ab中cd
sb.insert(sb.length(),  "中");  //在最后插入，自动扩容，abcd
sb.insert(0,  "中");  //中abcd

sb.insert(0,100).insert(0,3.14).insert(0,'中').insert(0, false).
insert(0,  new  Date());

//删除功能
//public StringBuffer deleteCharAt(int index) 删除指定索引的字符
StringBuffer  sb  =  new StringBuffer("abcd");
/sb.deleteCharAt(3);  //abc
sb.deleteCharAt(3).deleteCharAt(3);  //越界

//public StringBuffer delete(int start, int end)  （包左不包右）删除一段字符
sb.delete(2,  3)  //abd
sb.delete(2,  3).delete(0,0);  //bd
sb.delete(0,  sb.length());  //空

//替换功能
//public StringBuffer replace(int start,int end,String str)  // 包左不包右
StringBuffer  sb  =  new StringBuffer("abcd");
sb.replace(0,  3,  "XYZ,  now i  see...");
System.out.println(sb);  //d没有被替换掉

//反转功能
//public StringBuffer reverse()
StringBuffer  sb  = new  StringBuffer("abcd");
sb.reverse();
System.out.println(sb);  //dcba

//截取功能(注意这个返回值，原对象没有修改)
//public String substring(int start)
StringBuffer  sb  = new  StringBuffer("abcd");
String  s1  =  sb.substring(2);
System.out.println(s1);  //输出  cd
System.out.println(sb);  //输出  abcd

//public String substring(int start,int end)
String  s1  =  sb.substring(1, 3);
System.out.println(s1);  //输出bc
System.out.println(sb);  //输出abcd
```

  String和StringBuffer作为参数的区别

​	String作为参数传递  

​	StringBuffer作为参数传递 

* 总结：

  String作为参数传递类似于基本数据类型作为参数传递  (对象的不可改变性)。

  StringBuffer作为参数传递就是引用数据类型传递（对象可以改变）

API应用示范

* 判断一个字符串是否对称

  ```java
  //方法一：把字符串转为char[]数组，然后第一个和最后一个比较，第二个和倒数第二个比较
  //方法二：直接让StringBuffer的方法翻转字符串，若翻转后和原字符串相等，则是对称字符串
  ```

  

# Java日期类

> 严格来说，Java的日期类设计是比较曲折的，甚至是有些失败的，可谓是改了又改，始终不尽如人意
>
> java.util包下提供了 Date 类来封装当前的日期和时间，这个类中绝大多数方法已经过时了
>
> 但是作为Java日期类的基本类，仍然有学习的必要

- Date类表示一个特定的瞬间时间，精确到毫秒

    它允许把日期表示为年月日小时，也允许初始化和解析日期字符串  

- 构造方法：目前仍没有过时的只有两个

  - ```java
    //该构造函数使用当前日期和时间来初始化对象
    //表示创建对象时的系统时间
    //Date()
  Date date = new Date();
    System.out.println(date);//Fri Mar 19 09:00:48 CST 2021
    
    ```
    
  - ```java
    //第二个构造函数接收一个参数，该参数是从1970年1月1日起的毫秒数
    Date(long millisec)
    ```

  - 无参构造方法调用底层的native方法System.currentTimeMillis()方法

    - 该方法会根据操作系统来获取当前的时间戳

  - 时间戳：从格林威治时间（GMT）1970 年 1 月 1 日 00:00:00 到现在的毫秒数

    - 时间戳可以通过一些工具网站进行查询和转换时间

- 成员方法：了解两个即可

  - ```java
    //用自1970年1月1日00:00:00 GMT以后time毫秒数设置时间和日期。
    void setTime(long time)
    ```

  - ```java
    //返回自1970年1月1日00:00:00 GMT以来此Date对象表示的毫秒数。
    long getTime( )
    ```

- 中国处在东八区，格林威治时间1970 年 1 月 1 日 00:00:00是中国的1970 年 1 月 1 日 08:00:00



> 显然这种日期格式和我们生活中的日期格式，相去甚远
>
> 为了以更贴近生活中的方式去描述时间，实现直接把一个字符串转换成Date的需求
>
> 因此考虑使用别的日期类实现需求
>
> DateFormat是日期和时间格式化子类的抽象类，它能够以自定义的格式解析或者格式化日期和时间
>
> 由于其是一个抽象类，所以使用其子类SimpleDateFormat实现日期和字符串的相互转换。

*  System类方法currentTimeMillis(): 
  * 作用：获取系统当前毫秒值 （和getTime方法类似）
  * 定义：static long currentTimeMillis()
  * 应用场景：  如对程序执行时间测试，计算程序的执行时间 

*   DateFormat类 

  ```java
  /******************
  public abstract class DateFormat extends Format
  针对日期进行格式化和针对字符串进行解析的类，但是是抽象类，所以使用其子类SimpleDateFormat来实例化。
  它以与语言无关的方式格式化并解析日期或时间。日期/时间格式化子类（如 SimpleDateFormat）允许进行格式化（也就是日期 -> 文本）、解析（文本-> 日期）和标准化。
  成员方法：
  Date Parse(String s) 解析：把String文本转成Date类的日期String format(Date date) 格式化：把Date类日期转换为String文本
   ******************/
  ```

  

- SimpleDateFormat的构造方法

  * ```java
    //SimpleDateFormat()
    //用默认的模式和默认语言环境的日期格式符号构造SimpleDateFormat
    //注：此构造方法可能不支持所有语言环境。要覆盖所有地区，请使用 DateFormat 类中的工厂方法。
    //默认中文格式化文本格式 21-3-19 上午9:19
    ```

    

  - ```Java
    //用给定的模式和默认语言环境的日期格式符号构造 SimpleDateFormat
    //注：此构造方法可能不支持所有语言环境。要覆盖所有语言环境，请使用 DateFormat 类中的工厂方法。
    public SimpleDateFormat(String pattern)
  //Pattern必须用模式字符来写
    ```
    
  - pattern的书写格式

    - y：表示年，例如yyyy，表示千年年份

    - M：表示月份，例如MM，表示月份（最多12，两位数）

    - d：表示月份中的天数，例如dd，表示天数（最多31，两位数）

    - H：表示一天中的小时数，例如HH，表示小时数（最多24，两位数）

    - m：表示小时中的分钟数，例如mm，表示分钟数（最大59，两位数）

    - s：表示分钟里的秒数，例如ss，表示秒数（最大59，两位数）

      ```java
      Date  date  = new  Date();
      String  pattern  = "yyyy年MM月dd日  HH时mm分ss秒";
      SimpleDateFormat  sd  = new SimpleDateFormat(pattern);
      //格式化
      String  format  = sd.format(date);
      System.out.println(format);
      //2021年03月19日  14时02分05秒
      ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
      //解析
      System.out.println(sd.parse(format));
      //Fri Mar 19 14:02:05 CST 2021
      ```

      

  - 该对象仅仅只是描述日期的格式，并不代表时间

  - 想要表示时间，仍然要使用Date对象

- SimpleDateFormat的成员方法

  - ```Java
    //将传入的Date对象按照pattern格式，格式化成一个字符串
    public final String format(Date date)  
    ```

  - ```java
    //将传入的字符串按照pattern格式，解析成一个Date对象
    public Date parse(String source)
    ```

  - parse方法会抛出一个编译时异常ParseException，需要显式处理

    - 当传入的字符串和解析的格式不同，就会抛出该异常

  - format方法不会抛出编译时异常，不需要显式处理

    - 当pattern格式不正确，会抛出异常，非法参数



# Math类

```java
//public final class Math extends Object{}
//包含各种用于执行基本数学运算的方法，如初等质数、对数、平方根、三角函数等

//字段：
static double E://接近自然对数的底数e
static double PI://接近圆周率π

//public static int abs(int a) 返回绝对值
System.out.println(abs(‐3.14));//3.14
System.out.println(abs(3.14));//3.14

//public static double ceil(double a) 向上取整（取一个更大的数）
System.out.println(ceil(‐3.14));  //  ‐3
System.out.println(ceil(3.14));  //  4

//public static double floor(double a) 向下取整（取一个更小的数）
System.out.println(floor(‐3.14));  //  ‐4
System.out.println(floor(3.14));  //  3

//public static int max(int a,int b)两个整数间的最大值
System.out.println(max(3,  4));  //4
System.out.println(max(E,  PI));//3.141592653589793

//public static double pow(double a,double b)计算a的b次幂
System.out.println(pow(2.0,  3.2));//9.18116

//public static double random()伪随机数
System.out.println(random());//[0.1, 1.0)

//public static int round(float a)返回四舍五入
System.out.println(round(3.5));//4
System.out.println(round(3.4));//3
System.out.println(round(3.6));//4

//public static double sqrt(double a)计算平方根，负数返回NaN
System.out.println(sqrt(9.0));  //3
System.out.println(sqrt(‐1));  //NaN (not a number)
```

# System类

```java
//System类方法currentTimeMillis()
//获取系统当前毫秒值
//static  long  currentTimeMillis()
//可用于计算程序的执行时间

//System类方法exit()方法
System.exit (0) //退出虚拟机,所有程序全停止,即使finally也不能幸免
    
//System类方法gc
System.gc() //回收垃圾
//JVM在内存中,收取对象的垃圾,当没有更多引用指向该对象时,会自动调用垃圾回收机制回收堆中的对象,同时调用回收对象所属类的finalize方法

/* 
* System类方法arraycopy
* System类方法,复制数组
* arraycopy(Object src, int srcPos, Object dest, int destPos, int length)
* Object src, 要复制的源数组
* int srcPos, 数组源的起始索引
* Object dest,复制后的目标数组
* int destPos,目标数组起始索引
* int length, 复制几个
*/
int[]  src  =  {11,22,33,44,55,66};
int[]  desc  =  {77,88,99,0};
System.arraycopy(src,  1,  desc,  1, 2);//将src数组的1位置开始(包含1位置)的两个元素,拷贝到desc的1,2位置上
```



#  数字格式化

查资料

# IO概述

什么是IO

- I：Input 输入
- O：Output输出

为啥有IO？

-  在操作系统中，一切需要永久保存的数据都以文件的形式 存储。需要长久保存的文件数据，存储在外部设备。
   但是需要读入内存才能显示这些数据
   同时，内存的大小有限，因此常常需要在内存和外设之间交换数据，即I/O

java当中如何实现IO功能

- 我们通过java的IO流

- java流模型

  【  JVM内存  】                                   【 ↓ 】

  【输入流对象】<==read方法 读=== 【硬】

  【输出流对象】<==write方法 写=== 【盘】

  创建流对象之后，就建立起了内存和外设的数据通道，当数据从一端移动到另一端就完成了一次数据传输。



流的分类

- 按流向分（以内存为参照为）
  - 输入流   外设→内存
  - 输出流  内存→外设
- 按照数据类型分类
  - 字节流  以字节为单位，一连串的二进制  1B=8bit  0000 0000 
  - 字符流  以字符为单位，一连串的字符序列 ，理解成为一种文化符号  “你”  “abc”  “の” 

抽象基类

- 字节输出流 OutputStream
- 字节输入流 InputStream
- 字符输出流 Writer
- 字符输入流 Reader

注意：由这4个基类派生出的子类都是以其父类名字作为后缀的

eg：字节文件输出流：FileOutputStream

字节文件输入流：FileInputStream

# 字节流

## 字节输出流

### 抽象基类

OutputStream

- 继承关系

  ```
  [AutoCloseable]
  [<interface>]
  [close()]
       ↑
  [Closeable]          [Flushable]
  [<interface>]        [<interface>]
  [close()]			 [flush()]
       ↑                   ↑
  [OutputStream]→→→→→→→→→→→↑
  [abstract]
  ```

  

- 成员方法

  - | void           | close()        关闭此输出流并释放与此流有关的所有系统资源。  |
    | -------------- | ------------------------------------------------------------ |
    | void           | flush()        刷新此输出流并强制写出所有缓冲的输出字节。    |
    | void           | write(byte[] b)        将 b.length 个字节从指定的 byte 数组写入此输出流。 |
    | void           | write(byte[] b,  int off, int len)       将指定 byte 数组中从偏移量 off 开始的  len 个字节写入此输出流。 |
    | abstract  void | write(int b)        将指定的字节写入此输出流。               |

  - write(int b) 

    - write 的常规协定是：向输出流写入一个字节。要写入的字节是参数 b 的八个低位。b 的 24 个高位将被忽略。

  - write(byte[] b,  int off, int len)

  - 参数：
    b - 数据。
    off - 数据中的初始偏移量。
    len - 要写入的字节数。

### 具体子类

#### FileOutputSteam

- 构造方法

  - | FileOutputStream(File file)        创建一个向指定 File 对象表示的文件中写入数据的文件输出流。 |
    | ------------------------------------------------------------ |
    | FileOutputStream(File file,  boolean append)       创建一个向指定 File  对象表示的文件中写入数据的文件输出流。 |
    | FileOutputStream(String name)        创建一个向具有指定名称的文件中写入数据的输出文件流。 |
    | FileOutputStream(String name,  boolean append)       创建一个向具有指定 name 的文件中写入数据的输出文件流。 |

- 成员方法

| void | write(byte[] b)        将 b.length 个字节从指定 byte 数组写入此文件输出流中。 |
| ---- | ------------------------------------------------------------ |
| void | write(byte[] b,  int off, int len)       将指定 byte 数组中从偏移量 off 开始的  len 个字节写入此文件输出流。 |
| void | write(int b)        将指定字节写入此文件输出流。             |

Demo

```java
public class Demo2 {
    public static void main(String[] args) throws IOException {
        //   1.创建字节输出流对象
        FileOutputStream out = new FileOutputStream("a.txt");

        //    2.把我们的数据交给write方法
        // write(int b)
        //writeSingle(out);

        // 用字节数组方式
        //writeMuti(out);

        String s = "abcd";
        out.write(s.getBytes(),0,s.getBytes().length);


        //    3.close
        out.close();
    }

    private static void writeMuti(FileOutputStream out) throws IOException {
        String s = "abcd";
        out.write(s.getBytes());
    }

    private static void writeSingle(FileOutputStream out) throws IOException {
        out.write(97);
        out.write(98);
        out.write(99);
        out.write(100);
    }
}

```

注意

- 创建字节输出流对象做了什么事情

  - 创建之前，jvm到操作系统找文件
    - 没找到，会帮我们创建文件
    - 找了，会清空文件内容 从头开始写
  - 创建输出流对象，建立起内存与外设的数据通道

- 怎么实现文件追加？

  - ```java
        public static void main(String[] args) throws IOException {
            FileOutputStream out = new FileOutputStream("a.txt", true);
            out.write("abcd".getBytes());
            out.close();
        }
    ```

- 如何实现换行

  - ```java
        public static void main(String[] args) throws IOException {
            FileOutputStream out = new FileOutputStream("a.txt",true);
            //out.write("\r\n".getBytes());
            //out.write(System.lineSeparator().getBytes());
            out.write("\n".getBytes());
    
            out.write("abcd".getBytes());
            out.close();
        }
    ```

- 为什么要close?

  - java 流底层使用操作系统的内核资源,io资源属于操作系统的.不像new出来的对象一样被垃圾回收机制给回收,所以只能释放资源,close显式的去释放资源.一般来说只有使用close方法 都是使用了jvm以外的资源,文件,端口.

- 异常处理

  - 方式一:

    - ```java
      /*传统的异常处理方式*/
      public class Demo {
          public static void main(String[] args) {
              String s = "hello";
              FileOutputStream out = null;
              try {
                  out = new FileOutputStream("a.txt");
                  out.write(s.getBytes());
      
              } catch (FileNotFoundException e) {
                  e.printStackTrace();
              } catch (IOException e) {
                  e.printStackTrace();
              }finally {
                  try {
                      //判断是否为null
                      if (out != null) {
      
                          out.close();
                      }
                  } catch (IOException e) {
                      e.printStackTrace();
                  }
              }
      
          }
      }
      ```

  - 方式二

  - ```
    //try-with-resources
    语法:
    try(需要释放的资源,实现了Closeable或者AutoCLoseable接口){
    //代码
    }catch(){
    
    }finally{
    
    }
    
    ```

    ```java
    public class Demo2 {
        public static void main(String[] args) {
            // try-with-resources
    
            try(FileOutputStream out =
                        new FileOutputStream("a.txt")){
                // 写数据操作
                out.write("world".getBytes());
    
            } catch (FileNotFoundException e) {
                e.printStackTrace();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
    ```

    Demo

    ```java
    // 实现AutoCloseable接口
    public class Demo3 {
        public static void main(String[] args) {
            try(A a=new A()) {
                // 调用test方法
                a.test();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
    
    class A implements AutoCloseable {
    
        @Override
        public void close() throws Exception {
            System.out.println("执行了close方法");
        }
    
        public void test() {
            System.out.println("执行了test方法");
        }
    }
    ```


#### BufferedOutputStream

该类实现缓冲的输出流。通过设置这种输出流，应用程序就可以将各个字节写入底层输出流中，而不必针对每次字节写入调用底层系统。

- 继承关系

  * ```
    <C> BufferedOutputStream
    	<C> FilterOutputStream
    		<C> OutputStream
    			<C> Object
    			<I> Closeable
    			<I> Flushable
    ```

  ​	

- 构造方法

  - | BufferedOutputStream(OutputStream out)        创建一个新的缓冲输出流，以将数据写入指定的底层输出流。 |
    | ------------------------------------------------------------ |
    | BufferedOutputStream(OutputStream out,  int size)       创建一个新的缓冲输出流，以将具有指定缓冲区大小的数据写入指定的底层输出流。 |

  - 这种需要传入底层基础流我们称为包装流(处理流),实际上在原有流的基础上进行了功能的扩展,参数是底层流,也叫作节点流

    ```
    【BufferedInputStream】		   【		】
    【  [InputStream]    】<==read===【	磁	】
    【  (缓冲区8192B)     】			 【		   】
    								 【		  】
    【BufferedOutputStream】			【		 】
    【   [OutputStream]   】==write==>【	盘    】
    【	(缓冲区8192B)     】		  【			】
    ```



简单使用:

```java
/*| BufferedOutputStream(OutputStream out)
     创建一个新的缓冲输出流，以将数据写入指定的底层输出流。 |
| ------------------------------------------------------------ |
| BufferedOutputStream(OutputStream out,  int size)
   创建一个新的缓冲输出流，以将具有指定缓冲区大小的数据写入指定的底层输出流。 |*/
public class Demo1 {
    public static void main(String[] args) throws IOException {
        FileOutputStream out = new FileOutputStream("a.txt");
        BufferedOutputStream bo = new BufferedOutputStream(out);

        //BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(
        //        new FileOutputStream(new File("a.txt")));

        // 写数据
        bo.write("hello".getBytes());
        // 刷新数据 
        //bo.flush();
        //close
        bo.close();
        // close方法会自动执行flush方法 
        // 关闭包装流 会去自动关闭底层流
    }
}
```





## 字节输入流

### 抽象基类

InputStream

- 继承关系

  * ```
    AutoCloseable<interface>
    +close()
    	↑
    Closeable<interface>
    +close
    	↑
    InputStream<abstract>
    +3个read方法
    ```

    

- 成员方法

  - | abstract  int | read()        从输入流中读取数据的下一个字节。               |
    | ------------- | ------------------------------------------------------------ |
    | int           | read(byte[] b)        从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。 |
    | int           | read(byte[] b,  int off, int len)       将输入流中最多 len 个数据字节读入 byte 数组。 |

  - read()   

    - 从输入流中读取数据的下一个字节。readData
    - 返回 0 到 255 范围内的 int 字节值。如果因为已经到达流末尾而没有可用的字节，则返回值 -1。在输入数据可用、检测到流末尾或者抛出异常前，此方法一直阻塞。

  - read(byte[] b,  int off, int len) 

  - 参数：
    b - 读入数据的缓冲区。
    off - 数组 b 中将写入数据的初始偏移量。
    len - 要读取的最大字节数




### 具体子类

#### FileInputStream

- 构造方法

- | FileInputStream(File file)        通过打开一个到实际文件的连接来创建一个 FileInputStream，该文件通过文件系统中的  File 对象 file 指定。 |
  | ------------------------------------------------------------ |
  | FileInputStream(String name)        通过打开一个到实际文件的连接来创建一个 FileInputStream，该文件通过文件系统中的路径名  name 指定。 |

- 成员方法

  - | int  | read()        从此输入流中读取一个数据字节。                 |
    | ---- | ------------------------------------------------------------ |
    | int  | read(byte[] b)        从此输入流中将最多 b.length 个字节的数据读入一个 byte 数组中。 |
    | int  | read(byte[] b,  int off, int len)       从此输入流中将最多 len 个字节的数据读入一个  byte 数组中。 |

读取数据

- read()

- ```java
  public class Demo1 {
      public static void main(String[] args) throws IOException {
          //FileInputStream in = new FileInputStream(new File("a.txt"));
          FileInputStream in = new FileInputStream("a.txt");
  
          // read()读取数据  返回的是字节值
          //readSingle(in);
  
          // read(byte[] b) 返回的是个数
          //readMuti(in);
  
          // read(byte[]b,int off,int len)
          byte[] bytes = new byte[4];
          int readCount = in.read(bytes, 0, bytes.length);
          System.out.println(readCount);
          System.out.println(new String(bytes,0,readCount));
  
  
          // close
          in.close();
      }
  
      private static void readMuti(FileInputStream in) throws IOException {
          byte[] bytes = new byte[4];
          int readCount = in.read(bytes);
          System.out.println(readCount);
          System.out.println(new String(bytes,0,readCount));
      }
  
      private static void readSingle(FileInputStream in) throws IOException {
          int readData = in.read();
          System.out.println(((char) readData));
  
          int readData2 = in.read();
          System.out.println(((char) readData2));
  
          int readData3 = in.read();
          System.out.println(((char) readData3));
  
          int readData4 = in.read();
          System.out.println(((char) readData4));
  
          int readData5 = in.read();
          System.out.println((readData5));
      }
  }
  
  ```

  注意:（写入长度）

- ```java
  public class Demo2 {
      public static void main(String[] args) throws IOException {
          FileInputStream in = new FileInputStream("a.txt");
          byte[] bytes = new byte[4];
          int readCount = in.read(bytes);
          System.out.println(readCount);
          System.out.println(new String(bytes,0,readCount));
  
          int readCount2 = in.read(bytes);
          System.out.println(readCount2);
          System.out.println(new String(bytes,0,readCount2));
  
          in.close();
      }
  }
  
  ```

  

循环读取数据

- ```java
  public class Demo3 {
      public static void main(String[] args) throws IOException {
          // 第一种方式
          FileInputStream in = new FileInputStream("a.txt");
          //readWhile1(in);
  
          // 第二种方式
          //readwhile2(in);
  
          // 第三种方式 :用字节数组的方式
          // readCount用来接收读取到的字节个数
          int readCount;
          byte[] bytes = new byte[1024];
          while ((readCount=in.read(bytes)) != -1) {
              System.out.println(new String(bytes,0,readCount));
          }
  
          // close
          in.close();
      }
  
      private static void readwhile2(FileInputStream in) throws IOException {
          int readData;
          while ((readData = in.read()) != -1) {
              System.out.print(((char) readData));
          }
      }
  
      private static void readWhile1(FileInputStream in) throws IOException {
          while (true) {
              int readData = in.read();
              System.out.println(readData);
              if (readData == -1) {
                  break;
              }
          }
      }
  }
  
  ```


读取单个字节与读取多个字节,哪个效率更好?

- 肯定是读取多个字节的效率更高

#### 文件复制练习

- 文本文件

  - 单字节

  - 多字节

  - ```java
    public class Ex1 {
        public static void main(String[] args) throws IOException {
            // 创建字节输入流对象
            FileInputStream in = new FileInputStream("D:\\workspace2\\30th\\code\\day16_io02\\src\\com\\cskaoyan\\bytestream\\in\\Demo2.java");
    
            // 创建字节输出流对象
            FileOutputStream out = new FileOutputStream("D:\\copy2.txt");
    
            // 边读边写
            // 单个字节的形式
            //copy1(in, out);
    
            //字节数组 0ms
            long start = System.currentTimeMillis();
            byte[] bytes = new byte[1024];
            int readCount;
            while ((readCount = in.read(bytes)) != -1) {
                out.write(bytes,0,readCount);
            }
            long end = System.currentTimeMillis();
            System.out.println("耗时:" + (end - start) + "ms");
    
            // close
            in.close();
            out.close();
        }
        // 耗时:13ms
        private static void copy1(FileInputStream in, FileOutputStream out) throws IOException {
            long start = System.currentTimeMillis();
            int readData;
            while ((readData=in.read()) != -1) {
                out.write(readData);
            }
            long end = System.currentTimeMillis();
            System.out.println("耗时:" + (end - start) + "ms");
        }
    }
    
    ```

    

- 图片文件

  - 单字节

  - 多字节

  - ```java
    public class Ex2 {
        public static void main(String[] args) throws IOException {
            // 单字节
            FileInputStream in = new FileInputStream("D:\\mm.jpg");
            FileOutputStream out = new FileOutputStream("copy_mm2.jpg");
            //copy1(in, out);
    
            // 多字节  耗时:0ms
            long start = System.currentTimeMillis();
    
            byte[] bytes = new byte[1024];
            int readCount;
            while ((readCount = in.read(bytes)) != -1) {
                out.write(bytes,0,readCount);
            }
            long end = System.currentTimeMillis();
    
            System.out.println("耗时:" + (end - start) + "ms");
    
            //close
            in.close();
            out.close();
        }
    //耗时:97ms
        private static void copy1(FileInputStream in, FileOutputStream out) throws IOException {
            // 边读边写
            long start = System.currentTimeMillis();
            int readData;
            while ((readData = in.read()) != -1) {
                out.write(readData);
            }
            long end = System.currentTimeMillis();
    
            System.out.println("耗时:" + (end - start) + "ms");
        }
    }
    
    ```

    

- 视频文件

  - 单字节

  - 多字节

  - ```java
    public class Ex3 {
        public static void main(String[] args) throws IOException {
            // 单字节
            FileInputStream in = new FileInputStream("D:\\aa.mp4");
            FileOutputStream out = new FileOutputStream("copy_aa2.mp4");
            //long start = System.currentTimeMillis();
    
            //copy1(in, out, start);
    
            // 多字节 耗时:16ms
    
            long start = System.currentTimeMillis();
    
            byte[] bytes = new byte[1024];
            int readCount;
            while ((readCount = in.read(bytes)) != -1) {
                out.write(bytes,0,readCount);
            }
            long end = System.currentTimeMillis();
    
            System.out.println("耗时:" + (end - start) + "ms");
    
    
            in.close();
            out.close();
    
        }
        // 耗时:8700ms
        private static void copy1(FileInputStream in, FileOutputStream out, long start) throws IOException {
            int readData;
            while ((readData = in.read()) != -1) {
                out.write(readData);
            }
            long end = System.currentTimeMillis();
    
            System.out.println("耗时:" + (end - start) + "ms");
        }
    }
    ```

利用缓冲流复制文件

```java
public class Demo3 {
    public static void main(String[] args) throws IOException {
        // 创建缓冲输入流对象
        BufferedInputStream bi = new BufferedInputStream(
                new FileInputStream("D:\\aa.mp4"));
        // 创建缓冲输出流对象
        BufferedOutputStream bo = new BufferedOutputStream(
                new FileOutputStream("copy_aa4.mp4"));
        // 单个字节 复制  边读边写
        //copy1(bi, bo);

        // 字节数组  耗时:4ms
        long start = System.currentTimeMillis();

        int readCount;
        byte[] bytes = new byte[1024];
        while ((readCount = bi.read(bytes)) != -1) {
            bo.write(bytes,0,readCount);
        }
        long end = System.currentTimeMillis();
        System.out.println("耗时:" + (end - start) + "ms");

        // close
        bi.close();
        bo.close();
    }

    private static void copy1(BufferedInputStream bi, BufferedOutputStream bo) throws IOException {
        long start = System.currentTimeMillis();
        int readData;
        while ((readData=bi.read()) != -1) {
            bo.write(readData);
        }
        long end = System.currentTimeMillis();
        System.out.println("耗时:" + (end - start) + "ms");
    }
}

```





#### BufferedInputStream

BufferedInputStream 为另一个输入流添加一些功能

构造方法

| BufferedInputStream(InputStream in)        创建一个 BufferedInputStream 并保存其参数，即输入流  in，以便将来使用。 |
| ------------------------------------------------------------ |
| BufferedInputStream(InputStream in,  int size)       创建具有指定缓冲区大小的 BufferedInputStream  并保存其参数，即输入流 in，以便将来使用。 |

继承关系

```
<c> BufferedInputStream
	<c> FilterInputStream
		<c> InputStream
			<c> Object
			<I> Closeable
```



简单使用

```java
public class Demo2 {
    public static void main(String[] args) throws IOException {
        // 利用缓冲输入流读取数据
        BufferedInputStream bi = new BufferedInputStream(
                new FileInputStream("a.txt"));
        //int readData = bi.read();
        //System.out.println(((char) readData));
        byte[] bytes = new byte[1024];
        int readCount = bi.read(bytes);
        System.out.println(new String(bytes,0,readCount));
        bi.close();
    }
}

```



练习:

利用装饰器的设计模式,包装BufferedInputStream,扩展功能

要求:读取到的数据全部是小写的.

提示:重写read方法  继承FilterInputStream

```java
public class LowerCase extends FilterInputStream {
    /**
     * Creates a <code>FilterInputStream</code>
     * by assigning the  argument <code>in</code>
     * to the field <code>this.in</code> so as
     * to remember it for later use.
     *
     * @param in the underlying input stream, or <code>null</code> if
     *           this instance is to be created without an underlying stream.
     */
    protected LowerCase(InputStream in) {
        super(in);
    }
    // 重写read()
    @Override
    public int read() throws IOException {
        int readData = super.read();
        //if (readData == -1) {
        //    return readData;
        //} else {
        //    // 如果不=-1 把读到的数据转换成小写
        //    readData = Character.toLowerCase(((char) readData));
        //}
        //return readData;

        return (readData == -1 ? readData : Character.toLowerCase(((char) readData)));
    }
    // read(b, off, len)
    @Override
    public int read(byte[] b, int off, int len) throws IOException {
        int readCount = super.read(b, off, len);
        for (int i = off; i < off+readCount; i++) {
            b[i] = ((byte) Character.toLowerCase(((char) b[i])));
        }
        return readCount;
    }
}
```

单元测试

```java
public class LowerCaseTest {
    // 测试单个字节
    @Test
    public void read() throws IOException {
        LowerCase lowerCase = new LowerCase(
                new BufferedInputStream(new FileInputStream("a.txt")));
        int readData = lowerCase.read();
        assertEquals(97,readData);
    }
    // 测试字节数组
    @Test
    public void read1() throws Exception{
        LowerCase lowerCase = new LowerCase(
                new BufferedInputStream(new FileInputStream("a.txt")));
        byte[] bytes = new byte[1024];
        int readCount = lowerCase.read(bytes, 0, bytes.length);
        String s = new String(bytes, 0, readCount);
        assertEquals("abc",s);
    }
}
```



# 字符流

字符流产生的原因

- 先用字节流读取英文字符和数字
  - 没有问题 正常显示
- 读取中文
  - 产生了乱码问题

一个字节所能表示的范围 0000 0000 -1111 1111  255个字符  

用字节流处理文本数据的时候不是很方便,尤其是不同国家有不同的文字和符号



编解码

- 一个字符在计算机当中是怎样存储的?
  - 基于某个编码表,有一个对应的整数值(编码值) 存储在计算机当中
- 编码:
  - 基于某个编码表,把字符数据转化成相应的编码值存储在计算机中的过程(把人看懂的东西转化为计算机看懂的东西)
- 解码:
  - 基于某个编码表,把计算机存储的编码值转化成相应的字符数据(把计算机看懂的转化成人看懂的东西)

产生乱码的原因

- 编解码的不一致

中文编码表    '你'   0001

日文编码表     'の'  0001



编码表

ASCII：美国标准信息交换码。
用一个字节的7位可以表示。
ISO8859-1：拉丁码表。欧洲码表
用一个字节的8位表示。

GB2312：中国的中文编码表。
GBK：中国的中文编码表升级，融合了更多的中文文字符号。
GB18030：GBK的取代版本
BIG-5码 ：通行于台湾、香港地区的一个繁体字编码方案，俗称“大五码”。

Unicode：国际标准码，融合了多种文字。

UTF-8：可变长度来表示一个字符。
UTF-8不同，它定义了一种“区间规则”，这种规则可以和ASCII编码保持最大程度的兼容：

它将Unicode编码为00000000-0000007F的字符，用单个字节来表示  0111  1111  =  7F
它将Unicode编码为00000080-000007FF的字符用两个字节表示 
它将Unicode编码为00000800-0000FFFF的字符用3字节表示 

1字节 0xxxxxxx 
2字节 110xxxxx 10xxxxxx 
3字节 1110xxxx 10xxxxxx 10xxxxxx 



utf-16:

jvm使用的编码表，用2个字节来编解码

char : 2 字节



开发当中常用的编码表:

utf-8   GBK  ASCII  ISO8859-1

默认编码表

- idea当中采用utf-8编码表
- Windows中采用GBK编码



java中编解码



字符流的本质

```
             			<基于某个编码表>
【   字符输入流Reader   】				 |
【(缓冲区，解码器，把相应)】				 |
【(的编码值转化成字符数字)】<=============|	磁
【		[字节输入流  ] 】				 |
【		[InputStream] 】				 |
	内          存				     |
【   字符输出流Writer   】				  |
【(缓冲区，编码器，将字符)】				  |
【(数据转化成相应的编码值)】==============>|  盘
【		[字节输出流  ] 】				  |
【		[OutputStream] 】			 |

字符流的本质是：字节流+编码表
```



## 字符输出流

### 抽象基类

#### Writer

- 成员方法

- | void           | write(char[] cbuf)        写入字符数组。                     |
  | -------------- | ------------------------------------------------------------ |
  | abstract  void | write(char[] cbuf,  int off, int len)       写入字符数组的某一部分。 |
  | void           | write(int c)        写入单个字符。                           |
  | void           | write(String str)        写入字符串。                        |
  | void           | write(String str,  int off, int len)       写入字符串的某一部分。 |

- 写入单个字符。要写入的字符包含在给定整数值的 16 个低位中，16 高位被忽略



### 具体子类

#### OutputStreamWriter转化流

OutputStreamWriter 是字符流通向字节流的桥梁：可使用指定的 charset  将要写入流中的字符编码成字节。它使用的字符集可以由名称指定或显式给定，否则将接受平台默认的字符集。 

继承关系

```
<C> OutputStreamWriter
	<C>Writer
		<C>Object
		<I>Appendable
		<I>Closeable
		<I>Flushable
```



构造方法

| OutputStreamWriter(OutputStream out)        创建使用默认字符编码的 OutputStreamWriter。 |
| ------------------------------------------------------------ |
| OutputStreamWriter(OutputStream out,  String charsetName)        创建使用指定字符集的 OutputStreamWriter。 |

成员方法:

| String | getEncoding()        返回此流使用的字符编码的名称。          |
| ------ | ------------------------------------------------------------ |
| void   | write(char[] cbuf,  int off, int len)       写入字符数组的某一部分。 |
| void   | write(int c)        写入单个字符。                           |
| void   | write(String str,  int off, int len)       写入字符串的某一部分。 |

注意:

所有带缓冲区的输出流,就要执行flush操作

简单使用:

```java
public class Demo {
    public static void main(String[] args) throws IOException {
        // 创建转化输出流对象
        OutputStreamWriter out = new OutputStreamWriter(
                new FileOutputStream("a.txt"));
        // 写数据
        String s = "我秃了";
        //writeSingle(out, s);

        // 多字符
        //writeMuti(out, s);

        // 直接写字符串
        out.write(s,0,s.length());

        out.flush();
        // close
        out.close();
    }

    private static void writeMuti(OutputStreamWriter out, String s) throws IOException {
        char[] chars = s.toCharArray();
        out.write(chars,0,chars.length);
    }

    private static void writeSingle(OutputStreamWriter out, String s) throws IOException {
        char[] chars = s.toCharArray();
        for (int i = 0; i < chars.length; i++) {
            out.write(chars[i]);
        }
    }
}
```



#### FileWriter简化流

继承关系

```
<C> FileWriter
	<C> OutputStreamWriter
		<C> Writer
			<C> Object
			<I> Appendable
			<I> Closeable
			<I> Flushable
```



构造方法:

​     public FileWriter(String fileName)
​     public FileWriter(String fileName, boolean append)

简单使用:

```java
    public static void main(String[] args) throws IOException {
        //     public FileWriter(String fileName)
        //     public FileWriter(String fileName, boolean append)
        FileWriter fileWriter = new FileWriter("a.txt");
        fileWriter.write("你好呀");
        fileWriter.flush();
        fileWriter.close();
    }
```



#### BufferedWriter 缓冲流

构造方法:

| BufferedWriter(Writer out)        创建一个使用默认大小输出缓冲区的缓冲字符输出流。 |
| ------------------------------------------------------------ |
| BufferedWriter(Writer out,  int sz)       创建一个使用给定大小输出缓冲区的新缓冲字符输出流。 |

缓冲区大小是16KB

新的方法:

newLine        写入一个行分隔符。

```java
public class Demo {
    public static void main(String[] args) throws IOException {
        // 创建缓冲输出流
        BufferedWriter bw = new BufferedWriter(
                new FileWriter("a.txt"));
        bw.write("我秃了");
        // newLine()换行
        bw.newLine();
        bw.write("也变强了!");
        bw.close();
    }
}
```



## 字符输入流



### 抽象基类

#### Reader

成员方法

| int           | read()        读取单个字符。                                 |
| ------------- | ------------------------------------------------------------ |
| int           | read(char[] cbuf)        将字符读入数组。                    |
| abstract  int | read(char[] cbuf,  int off, int len)       将字符读入数组的某一部分。 |

读取单个字节

​	作为整数读取的字符，范围在 0 到 65535 之间 (0x00-0xffff)，如果已到达流的末尾，则返回 -1 



### 具体子类

#### InputStreamReader转换流

InputStreamReader 是字节流通向字符流的桥梁：它使用指定的 charset  读取字节并将其解码为字符。它使用的字符集可以由名称指定或显式给定，或者可以接受平台默认的字符集。

继承关系:

```
<C>InputStreamReader
	<C>Reader
		<C>Object
		<I>Readable
		<I>Closeable
```



构造方法:

| InputStreamReader(InputStream in)        创建一个使用默认字符集的 InputStreamReader。 |
| ------------------------------------------------------------ |
| InputStreamReader(InputStream in, String charsetName)        创建使用指定字符集的 InputStreamReader。 |

成员方法:

| String | getEncoding()        返回此流使用的字符编码的名称。 |
| ------ | --------------------------------------------------- |
| int    | read()        读取单个字符。                        |
| int    | read(char[] cbuf,  int offset, int length)          |

简单使用

```java
public class Demo2 {
    public static void main(String[] args) throws IOException {
        // 创建转换输入流
        InputStreamReader in = new InputStreamReader(
                new FileInputStream("a.txt"));
        // 读取数据
        //readSingle(in);

        // 读取多个字符 读取的字符数，如果已到达流的末尾，则返回 -1

        readMuti(in);

        in.close();
    }

    private static void readMuti(InputStreamReader in) throws IOException {
        char[] chars = new char[1024];
        int readCount;
        while ((readCount = in.read(chars)) != -1) {
            System.out.println(new String(chars,0,readCount));
        }
    }

    private static void readSingle(InputStreamReader in) throws IOException {
        int readData = in.read();
        System.out.println(((char) readData));
        int readData2 = in.read();
        System.out.println(((char) readData2));
        int readData3 = in.read();
        System.out.println(((char) readData3));
        int readData4 = in.read();
        System.out.println((readData4));
    }
}
```



复制文件:

复制文本文件:

```java
public class Demo3 {
    public static void main(String[] args) throws IOException {
        // 创建输入流对象
        InputStreamReader in = new InputStreamReader(
                new FileInputStream("a.txt"));
        // 创建输出流对象
        OutputStreamWriter out = new OutputStreamWriter(
                new FileOutputStream("b.txt"));
        // 用while边读边写
        char[] chars = new char[1024];
        int readCount;
        while ((readCount = in.read(chars)) != -1) {
            out.write(chars,0,readCount);
        }

        // close
        in.close();
        out.close();
    }
}

```

注意:

复制文件的时候,如果是文本文件,字节流字符流都可以,但是对于非文本文件,只能用字节流

字节流是万能的.



#### FileReader

继承关系

```
<C> FileReader
	<C> InputStreamReader
		<C> Reader
			<C> Object
			<I> Readable
			<I> Closeable
```



构造方法:

​    public FileReader(String fileName)
​     public FileReader(File file)

简单使用:

```java
public class Demo2 {
    public static void main(String[] args) throws IOException {
        //     public FileReader(String fileName)
        //     public FileReader(File file)
        FileReader reader = new FileReader("a.txt");
        char[] chars = new char[1024];
        int readCount = reader.read(chars);
        System.out.println(new String(chars,0,readCount));
        reader.close();
    }
}

```



转化流VS简化流

- 转化流麻烦 简化流 简单

- 简化流虽然简单 但是不能只能字符集 

- 如果要指定字符集 只能选择转化流

  



#### BufferedReader

构造方法

| BufferedReader(Reader in)        创建一个使用默认大小输入缓冲区的缓冲字符输入流。 |
| ------------------------------------------------------------ |
| BufferedReader(Reader in,  int sz)       创建一个使用指定大小输入缓冲区的缓冲字符输入流。 |

特殊方法

| String | readLine()        读取一个文本行。 |
| ------ | ---------------------------------- |
|        |                                    |

注意:

包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 


简单使用:

```java
public class Demo2 {
    public static void main(String[] args) throws IOException {
        // 创建缓冲输入流对象
        BufferedReader br = new BufferedReader(
                new FileReader("a.txt"));
        // 读取一个文本行readLine方法
        //read1(br);
        String line;
        while ((line = br.readLine()) != null) {
            System.out.println(line);
        }

        br.close();

    }

    private static void read1(BufferedReader br) throws IOException {
        String s = br.readLine();
        System.out.println(s);
        String s2 = br.readLine();
        System.out.println(s2);
    }
}

```



# 其他流

## 数据流

### DataOutputStream

数据输出流允许应用程序以适当方式将基本 Java 数据类型写入输出流中。然后，应用程序可以使用数据输入流将数据读入。

构造方法:

DataOutputStream(OutputStream out)        创建一个新的数据输出流，将数据写入指定基础输出流。

成员方法:

各种write方法,我们想写入哪种数据类型的数据 就使用相对应的write方法即可

简单使用:

```java
public class Demo2 {
    public static void main(String[] args) throws IOException {
        // 创建数据输出流对象
        DataOutputStream out = new DataOutputStream(
                new FileOutputStream("a.txt"));
        // 写入1000
        out.writeInt(1000);
        out.close();
    }
}
```



### DataInputStream

数据输入流允许应用程序以与机器无关方式从底层输入流中读取基本 Java 数据类型

构造方法:

DataInputStream(InputStream in)        使用指定的底层 InputStream 创建一个 DataInputStream。

成员方法:

各种read方法

简单使用

```java
public class Demo3 {
    public static void main(String[] args) throws IOException {
        DataInputStream dataInputStream = new DataInputStream(
                new FileInputStream("a.txt"));
        int readInt = dataInputStream.readInt();
        System.out.println(readInt);
        dataInputStream.close();
    }
}
```

注意:

按照怎样的顺序写入,就需要按照相应的顺序读取(相应的read方法)

Demo:

```java
public class Demo4 {
    public static void main(String[] args) throws IOException {
        write();
        read();
    }

    private static void read() throws FileNotFoundException, IOException {
        DataInputStream dis = new DataInputStream(
                new FileInputStream("dos.txt"));
        byte b = dis.readByte();
        System.out.println(b);
        short s = dis.readShort();
        System.out.println(s);
        int i = dis.readInt();
        System.out.println(i);
        long l = dis.readLong();
        System.out.println(l);
        float f = dis.readFloat();
        System.out.println(f);
        double d = dis.readDouble();
        System.out.println(d);
        char ch = dis.readChar();
        System.out.println(ch);
        boolean bb = dis.readBoolean();
        System.out.println(bb);
        dis.close();
    }

    private static void write() throws IOException {
        DataOutputStream dos = new DataOutputStream(new FileOutputStream(
                "dos.txt"));
        dos.writeByte(1);
        dos.writeShort(20);
        dos.writeInt(300);
        dos.writeLong(4000);
        dos.writeFloat(12.34f);
        dos.writeDouble(12.56);
        dos.writeChar('a');
        dos.writeBoolean(true);
        dos.close();
    }

}
```



## 打印流

练习:

需求:写一个工具类,PrintUtil,

4个方法:printInt, printLnInt ,printDouble,printLnDouble

```java
public class Demo5 {
    public static void main(String[] args) throws IOException{
        PrintUtil printUtil = new PrintUtil(
                new FileOutputStream("a.txt"));
        printUtil.printLnInt(1000);
        printUtil.printDouble(3.14);
        printUtil.printBoolean(true);
        printUtil.close();
    }
}

class PrintUtil {
    OutputStream out;

    public PrintUtil(OutputStream out) {
        this.out = out;
    }
/*写int数据*/
    public void printInt(int a) throws IOException {
        String s = String.valueOf(a);
        out.write(s.getBytes());

    }
    public void printLnInt(int a) throws IOException {
        String s = String.valueOf(a);
        out.write(s.getBytes());
        out.write(System.lineSeparator().getBytes());
    }

    /*写double数据*/
    public void printDouble(double d) throws IOException {
        String s = String.valueOf(d);
        out.write(s.getBytes());
    }
    public void printLnDouble(double d) throws IOException {
        String s = String.valueOf(d);
        out.write(s.getBytes());
        out.write(System.lineSeparator().getBytes());

    }

    /*写入boolean数据*/
    public void printBoolean(boolean b) throws IOException {
        String s = String.valueOf(b);
        out.write(s.getBytes());

    }


    public void close() throws IOException {
        out.close();
    }


}
```

打印流特点
只能操作目的地，不能操作数据来源。

可以操作任意类型的数据。就是把相应的数据类型转化成字符串

如果启动了自动刷新，能够自动刷新。有前提条件:println、printf 或 format 方法

可以操作文件的流

### PrintStream打印字节流

### PrintWriter打印字符流

```
public PrintWriter(Writer out,
                   boolean autoFlush)
 参数：
out - 字符输出流
注意:
autoFlush - boolean 变量；如果为 true，则 println、printf 或 format 方法将刷新输出缓冲区
```

标准输出流

System.out    默认的输出设备是显示器

是打印字节流 PrintStream

标准输入流

System.in      默认的输入设备是键盘

是普通字节输入流   InputStream

练习:

使用System.in,去模拟Scanner里面nextLine方法.键盘输入数据

提示:使用BufferedReader

```java
public class Demo8 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(
                new InputStreamReader(System.in));
        //String s = br.readLine();
        //System.out.println(s);

        // 新需求 : 要求键盘连续输入
        // 增加一个结束的约定: 滚  结束
        String line ;
        while ((line = br.readLine()) != null) {
            System.out.println(line);
            if ("滚".equals(line)) {
                break;
            }
        }

        br.close();

    }
}

```





## 对象流(序列化与反序列流)

   序列化：  就是将内存中的对象数据，转化为二进制数据，输出到外部设备，即永久保存内存中的数据
   反序列化：将外部设备上，永久保存的数据，读取到内存中，还原成对象
   类必须实现serializable接口（没有方法的标记接口）
    序列化操作问题：
    1.为啥要实现序列化和反序列化？
          // 序列化流:  内存中的对象对象  -> 外部设备
          // 反回序列化流： 外部设备上之前保存的对象 ——> 内存中的对象

​    2.如何实现对象序列化和反序列化
​          ObjectOuputStream#

​			writeObject()

​          ObjectInputStream#

​			readObject()

​    3.是否可以有选择性的序列化？
​        可以有选择，对象中不想被保存的成员变量值，用transient关键字修饰（注意是修饰不是注解）

​    4.序列化数据后，再次修改类，读取数据会出问题？
​        可以，只需要，在修改过的类中定义，并且让其值，和序列化的对象所保存的serialVersionUID相同即可

​	eg. static final long serialVersionUID = 324389745805407L注意要定义为常量

### ObjectOutputStream

构造方法:

ObjectOutputStream(OutputStream out)        创建写入指定 OutputStream 的 ObjectOutputStream。

成员方法

writeObject(Object obj)        将指定的对象写入 ObjectOutputStream。      

注意:

java.io.NotSerializableException     没有实现Serializable

java.io.InvalidClassException     类信息发生了变化

简单使用:

```java
public class Demo9 {
    public static void main(String[] args) throws IOException, ClassNotFoundException {
        // 序列化
        //serialize();

        // 反序列化 ObjectInputStream
        ObjectInputStream in = new ObjectInputStream(
                new FileInputStream("a.txt"));
        // 读取对象数据
        Student student = (Student) in.readObject();
        System.out.println(student);

    }

    private static void serialize() throws IOException {
        // ObjectOutputStream(OutputStream out)
        ObjectOutputStream out = new ObjectOutputStream(
                new FileOutputStream("a.txt"));

        // 创建student对象
        Student student = new Student("Kobe", 42);
        System.out.println(student);
        out.writeObject(student);

        // close
        out.close();
    }
}

class Student implements Serializable {
    String name;
    int age;

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}
```



### ObjectInputStream

构造方法

ObjectInputStream(InputStream in)        创建从指定 InputStream 读取的 ObjectInputStream。

成员方法:

readObject()        从 ObjectInputStream 读取对象。



# IO流总结

| 类型     | 字节输出流           | 字节输入流          | 字符输出流         | 字符输入流        |
| -------- | -------------------- | ------------------- | ------------------ | ----------------- |
| 基类     | OutputStream         | InputStream         | Writer             | Reader            |
| 文件相关 | FileOutputStream     | FileInputStream     | FileWriter         | FileReader        |
| 转换相关 |                      |                     | OutputStreamWriter | InputStreamReader |
| 缓冲相关 | BufferedOutputStream | BufferedInputStream | BufferedWriter     | BufferedReader    |
| 数据相关 | DataOutputStream     | DataInputStream     |                    |                   |
| 打印相关 | PrintStream          |                     | PrintWriter        |                   |
| 对象相关 | ObjectOutputStream   | ObjectInputStream   |                    |                   |





# 操作系统相关知识

```
java代码是在某一条执行路径下按顺序执行的
一个执行路径就是一个线程。
单线程（顺序） 多线程（“同时”）
|			|...
|/|			|  |
|\|			|..|...
|			|  |  |
|/|			|  |  |
|\|			|  |  |
```

线程

- 线程是CPU进行资源调度与分配的基本单位,线程依赖于进程而存在,每个进程可以有多个子任务,每个子任务都可以当做线程,从执行路径的角度来讲,线程就是一个执行路径.



进程

- 一个计算机程序在某一数据集合上的运行活动,进程是操作系统进行资源分配与调度的基本单位.
- 简单理解,进程就是一个正在运行的软件(程序)
- 进程之间是相互独立 互不影响

线程与进程的关系

- 进程中可以有多个线程,线程依赖于进程存在

- 线程共享进程中的资源.

  ```
  进程的上下文切换：
  1. 保护现场
  2. 恢复现场
  |    C     P    U   |  进程1     进程2
  | 寄存器A  | 寄存器B  |  a = 1     d = 10
  |     ↑.........↑   |  b = 2     e = 20
  |     | 运算器   |   |  ...       ...
  |     ```````````   |
  ```

串行

- 一个任务一个任务按照顺序执行

并行

- 在同一时刻,多个任务同时执行

并发

- 在同一时间段内,多个任务同时执行

  ===|任务A|任务B|任务C|===> 串行

  ​       |任务A|

  ​       |任务B|

  ===|任务C|===> 并行

  ​       |任务A|

  ​           |任务B|

  =======|任务C|===> 并发

****



同步、异步 概念

同步与异步描述的是被调用者的。 

如 A 调用 B：

 如果是同步，B 在接到 A 的调用后，会立即执行要做的事。A 的本次调用可以得到结 果。(你走我不走 我走你不走)

 如果是异步，B 在接到 A 的调用后，不保证会立即执行要做的事，但是保证会去做，B 在做好了之后会通知 A。A 的本次调用得不到结果，但是 B 执行完之后会通知 A。

举例:

同步:

我给书店老板打电话,问有没有java书,老板接电话,说我去看看,电话不挂断.找到了回拿起电话回复

异步:

我给书店老板打电话,问有没有java书,老板接电话,说我去看看,然后把电话挂了.找到了会打电话通知我.

多线程是天生异步的.

实际应用

```
比如注册页面
后台接收用户注册数据，如不重复，入数据库，并给用户发送邮件。此时active状态为0，待用户右键确认之后修改active为1并返回前端注册成功页面给用户。
这里发送右键就是异步，要不用户如果不确认邮件，前端页面一直转圈。
```



elasticSearch 理解成为在内存的数据库



****

# java程序运行

java命令启动java程序的原理

- java命令,创建jvm进程
- jvm进程创建一个线程,主线程 main
- 执行主线程中的main方法

jvm是单线程还是多线程

- jvm是多线程的,起码有一个垃圾回收线程



# 多线程的实现方式一:继承Thread

文档实例

Thread类线程 是程序中的执行线程。Java 虚拟机允许应用程序并发地运行多个执行线程。

```java
class PrimeThread extends Thread {
	long minPrime;
    PrimeThread(long minPrime) {
        this.minPrime = minPrime;
    }
    public void run() {
		//compute primes larger than minPrime
        ...
    }
}
```

步骤

1. 继承Thread类
2. 重写里面的run方法
3. 创建子类对象
4. start方法去启动线程

示例:

```java
public class Demo {
    public static void main(String[] args) {
        MyThread myThread = new MyThread();

// 启动线程
        myThread.start();
                }
                }

class MyThread extends Thread {
    @Override
    public void run() {
        for (int i = 0; i < 10; i++) {
            System.out.println(i);
        }
    }
}
```

获取设置线程名称

- 获取 getName()

  - 默认线程名 Thread-0   类名+数字

- 设置 setName()

- Thread(String name)        分配新的 Thread 对象。

- 如何获取主线程的名称

  - | static Thread | currentThread()        返回对当前正在执行的线程对象的引用。 |
    | ------------- | ----------------------------------------------------------- |

```java
public class Demo1 {
    public static void main(String[] args) {
        // static Thread currentThread()
        // 返回对当前正在执行的线程对象的引用。
        Thread thread = Thread.currentThread();
        System.out.println(thread.getName());
        MyThread myThread = new MyThread("吴彦祖");
        myThread.start();
    }
}

class MyThread extends Thread {
    public MyThread(String name) {
        super(name);
    }

    @Override
    public void run() {
        for (int i = 0; i < 10; i++) {
            System.out.println(getName() + "---" + i);
        }
    }
}
```





start方法执行

-------------JVM------------           .......底层函数 [win]=>算法=>CPU资源

|start()方法=>start0()|-------|-----底层函数 [mac]=>算法=>CPU资源

--------------------------------           -----底层函数 [mac]=>算法=>CPU资源



注意事项

- 一个Thread或Thread子类对象才代表一个线程
- 为什么要重写run方法？
  - 只有Thread中的run方法中代码才会在子线程中执行
  - 为了保证子线程中运行的是我们的想要他执行的代码，我们要重写run方法（换句话说，把我们想要在子线程中执行的任务封装在了run方法中）
- 一个方法，被哪个线程调用，这个方法就运行在调用它的那个线程当中
- 启动线程，必须要用start方法而不是run方法。如果只是线程对象.run()  那么这仅仅只是普通方法调用。
- 同一个Thread对象或子类对象只能被启动一次。如果我想启动多个线程的话，只能创建多个对象IllegalThreadStateException

# 线程调度方式

两种调度方式

线程调度是指系统为线程分配处理器使用权的过程。
调度的方式主要有两种：

1. 协同式线程调度。
   a. 如果使用协同式调度的多线程系统，线程的执行时间，由线程本身来控制，线程把自己的工作执行完了之后
      主动通知系统切换到另外一个线程上去。

   b. 其最大的好处是实现简单，坏处是线程执行时间不可控

2. 抢占式线程调度
   a. 如果使用抢占式调度的多线程系统，那么每个线程将由系统来分配执行时间，线程的切换不由线程本身决定。
   b. 其最大的好处是，线程的执行时间是可控的

java中采用的是抢占式线程调度方式

# 线程优先级

操作系统的线程调度

- 静态优先级+动态优先级
- 正在CPU上执行的线程会随着执行时间的延长而降低优先级,等待的线程会随着等待的时间的延长优先级而升高

获取 设置优先级

- get 和 set方法

- ```java
  public class Demo2 {
      public static void main(String[] args) {
          MyThread2 t1 = new MyThread2();
          MyThread2 t2 = new MyThread2();
          t1.setName("短");
          t2.setName("细");
          // 设置线程优先级 线程优先级的范围1-10
          t1.setPriority(Thread.MAX_PRIORITY);
          t2.setPriority(Thread.MIN_PRIORITY);
          t1.start();
          t2.start();
          // 获取优先级
          // 默认优先级 5
          int priority = t1.getPriority();
          System.out.println(priority);
          int priority2 = t2.getPriority();
          System.out.println(priority2);
      }
  }
  
  class MyThread2 extends Thread {
      @Override
      public void run() {
          for (int i = 0; i < 10; i++) {
              System.out.println(getName()+"----"+i);
          }
      }
  }
  ```

- 为什么大的优先级没有先执行?

  - 我们设置的优先级是静态优先级,仅仅只是给操作系统的一种建议.

- java官方： 线程优先级并非完全没有用，我们Thread的优先级，它具有统计意义，总的来说，高优先级的线程占用的cpu执行时间多一点，低优先级线程，占用cpu执行时间，短一点



# 线程控制API

## 休眠线程sleep

```java
public class SleepThreadDemo {
    public static void main(String[] args) {
        SleepThread t = new SleepThread();

        t.start();
    }
}

class SleepThread extends Thread {
    @Override
    public void run() {
        for (int i = 0; i < 10; i++) {
            System.out.println(getName()+"---"+i);
            try {
                //Thread.sleep(2000);
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```



## 合并线程join

2个问题

- 谁等待:调用join的代码在哪个线程中运行就是哪个线程等待

- 等待谁:等待调用join的那个线程

  ```
  ↓main
  ↓___
   __|执行join的线程  插队
  ↓   
  main
  ```

  

```java
public class JoinThreadDemo {
    public static void main(String[] args) {
        System.out.println("main start");
        JoinThread joinThread = new JoinThread();
        joinThread.setName("55开");
        joinThread.start();
        try {
            joinThread.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("main end");
    }
}

class JoinThread extends Thread {
    @Override
    public void run() {
        for (int i = 0; i < 10; i++) {
            System.out.println(getName()+"----"+i);
        }
    }
}
```



## 守护线程daemon

分类:

- 用户线程
- 守护线程

setDaemon(boolean on)        将该线程标记为守护线程或用户线程。

注意;

将该线程标记为守护线程或用户线程。当正在运行的线程都是守护线程时，Java 虚拟机退出。 

该方法必须在启动线程前调用。 

java.lang.IllegalThreadStateException:启动线程之后调用

## 礼让线程yield

| static void | yield()        暂停当前正在执行的线程对象，并执行其他线程。 |
| ----------- | ----------------------------------------------------------- |

```java
public class YieldThreadDemo {
    public static void main(String[] args) {
        YieldThread t1 = new YieldThread();
        YieldThread t2 = new YieldThread();

        t1.setName("金牌讲师");
        t2.setName("第一赌神");

        t1.start();
        t2.start();
    }
}

class YieldThread extends Thread {
    @Override
    public void run() {
        for (int i = 0; i < 10; i++) {
            System.out.println(getName()+"----"+i);
            // yield() 暂停当前正在执行的线程对象，并执行其他线程。
            Thread.yield();
            // 为什么没有你一个我一个的执行呢?
            // 虽然调用了yield方法,放弃CPU的执行权,但是java采用的是抢占式调度方式
            // 仍然会参加下一轮的CPU竞争 并不能保证一定保证被哪个线程抢到执行权.
        }
    }
}
```



## 中断线程stop,interrupt

stop不安全，强行中断，弃用。

通过interrupt()方法来中断. 这个方法通过修改了被调用线程的中断状态来告知那个线程, 说它被中断了. 对于非阻塞中的线程, 只是改变了中断状态, 即isInterrupted()将返回true; 对于可取消的阻塞状态中的线程, 比如等待在这些函数上的线程, Thread.sleep(), Object.wait(), Thread.join(), 这个线程收到中断信号后, 会抛出InterruptedException, 同时会把中断状态置回为false.但调用Thread.interrupted()会对中断状态进行复位。

Core Java中有这样一句话：”没有任何语言方面的需求要求一个被中断的程序应该终止。中断一个线程只是为了引起该线程的注意，被中断线程可以决定如何应对中断 

```java
//参考https://blog.csdn.net/canot/article/details/51087772
//https://www.jianshu.com/p/b6e3c0f02aa2 这篇没看，应该更深入
//isInterrupted的经典使用代码    
    public void run(){    
            try{    
                 ....    
                 while(!Thread.currentThread().isInterrupted()&& more work to do){    
                        // do more work;    
                 }    
            }catch(InterruptedException e){    
                        // thread was interrupted during sleep or wait    
            }    
            finally{    
                       // cleanup, if required    
            }    
    } 

 /*  
    * 如果线程被阻塞，它便不能核查共享变量，也就不能停止。这在许多情况下会发生，例如调用 
    * Object.wait()、ServerSocket.accept()和DatagramSocket.receive()时，他们都可能永 
    * 久的阻塞线程。即使发生超时，在超时期满之前持续等待也是不可行和不适当的，所以，要使 
    * 用某种机制使得线程更早地退出被阻塞的状态。很不幸运，不存在这样一种机制对所有的情况 
    * 都适用，但是，根据情况不同却可以使用特定的技术。使用Thread.interrupt()中断线程正 
    * 如Example1中所描述的，Thread.interrupt()方法不会中断一个正在运行的线程。这一方法 
    * 实际上完成的是，在线程受到阻塞时抛出一个中断信号，这样线程就得以退出阻塞的状态。更 
    * 确切的说，如果线程被Object.wait, Thread.join和Thread.sleep三种方法之一阻塞，那么， 
    * 它将接收到一个中断异常（InterruptedException），从而提早地终结被阻塞状态。因此， 
    * 如果线程被上述几种方法阻塞，正确的停止线程方式是设置共享变量，并调用interrupt()（注 
    * 意变量应该先设置）。如果线程没有被阻塞，这时调用interrupt()将不起作用；否则，线程就 
    * 将得到异常（该线程必须事先预备好处理此状况），接着逃离阻塞状态。在任何一种情况中，最 
    * 后线程都将检查共享变量然后再停止。下面示例描述了该技术。 
    * */  

class Example3 extends Thread {  

    volatile boolean stop = false;  

    public static void main(String args[]) throws Exception {  
        Example3 thread = new Example3();  

        System.out.println("Starting thread...");  
        thread.start();  

        Thread.sleep(3000);  

        System.out.println("Asking thread to stop...");  

        /* 
        * 如果线程阻塞，将不会检查此变量,调用interrupt之后，线程就可以尽早的终结被阻  
        * 塞状 态，能够检查这一变量。 
        * */  
        thread.stop = true;  

        /* 
        * 这一方法实际上完成的是，在线程受到阻塞时抛出一个中断信号，这样线程就得以退 
        * 出阻 塞的状态 
        * */  
        thread.interrupt();  

        Thread.sleep(3000);  
        System.out.println("Stopping application...");  
        System.exit(0);  
    }  

    public void run() {  
    	while (!stop) {  
            System.out.println("Thread running...");  
            try {  
             Thread.sleep(2000);  
            } catch (InterruptedException e) {  
            // 接收到一个中断异常（InterruptedException），从而提早地终结被阻塞状态  
            System.out.println("Thread interrupted...");  
       		 }  
   		 }  

    System.out.println("Thread exiting under request...");  
    }  
}  
    /* 
    * 把握几个重点：stop变量、run方法中的sleep()、interrupt()、InterruptedException。串接起 
    * 来就是这个意思：当我们在run方法中调用sleep（或其他阻塞线程的方法）时，如果线程阻塞的 
    * 时间过长，比如10s，那在这10s内，线程阻塞，run方法不被执行，但是如果在这10s内，stop被 
    * 设置成true，表明要终止这个线程，但是，现在线程是阻塞的，它的run方法不能执行，自然也就 
    * 不能检查stop，所 以线程不能终止，这个时候，我们就可以用interrupt()方法了：我们在 
    * thread.stop = true;语句后调用thread.interrupt()方法， 该方法将在线程阻塞时抛出一个中断 
    * 信号，该信号将被catch语句捕获到，一旦捕获到这个信号，线程就提前终结自己的阻塞状态，这 
    * 样，它就能够 再次运行run 方法了，然后检查到stop = true，while循环就不会再被执行，在执 
    * 行了while后面的清理工作之后，run方法执行完 毕，线程终止。 
    * */ 
```

练习:

如何安全的终止线程? 不用任何线程控制api , 当终止的时候 把记录  当前时间 + 终止信息保存到 log.txt

提示:使用flag标记 ,FileWriter 

```java
public class SecurityStopDemo {
    public static void main(String[] args) {
        StopThread2 stopThread2 = new StopThread2();
        stopThread2.setName("张三");
        stopThread2.start();
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        stopThread2.flag = false;
    }
}

class StopThread2 extends Thread {
    boolean flag = true;
    @Override
    public void run() {
        for (int i = 0; i < 10; i++) {
            if (flag) {
                System.out.println(getName() + "----" + i);
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();

                }
            } else {

                // flag 为 false说明线程终止
                System.out.println("线程终止");
                // 记录哪个线程 什么时间发生了中断
                try {
                    FileWriter fileWriter =
                            new FileWriter("../day19_thread02/log.txt");
                    SimpleDateFormat simpleDateFormat =
                            new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
                    String formatTime = simpleDateFormat.format(new Date());
                    String s = formatTime + ": " + getName() + " 发生了中断,数据已保存";
                    fileWriter.write(s);
                    fileWriter.write(System.lineSeparator());
                    fileWriter.flush();
                    fileWriter.close();
                    
                    
                } catch (IOException e) {
                    e.printStackTrace();
                }

                // 进行一些数据保存的操作
                return;
            }
        }
```

interrupt

```java
public class InterruptThreadDemo {
    public static void main(String[] args) {
        StopThread3 stopThread3 = new StopThread3();
        stopThread3.setName("女流");
        stopThread3.start();
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        // 抛出中断异常 相当于泼了一盆冷水
        stopThread3.interrupt();
    }
}

class StopThread3 extends Thread {
    @Override
    public void run() {
        System.out.println("stop before");
        for (int i = 0; i < 10; i++) {
            System.out.println(getName()+"----"+i);
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                //e.printStackTrace();
                System.out.println("有异常");
            }
        }
        System.out.println("stop end");
    }
}
```



# 线程的生命周期

五种线程状态

新建:线程对象刚刚创建出来 没有start 

就绪:执行start方法 启动了 没有CPU的执行权

执行:抢到了CPU的执行权 该线程在CPU上运行 

阻塞:没有CPU的执行权 还缺少一些必要条件 

死亡:线程中的run方法执行完,被当做垃圾被垃圾回收机制回收

各个状态之间的转换

```
【新建】----------start方法---------↓
	.-->除CPU资源外满足了器他条件->【就绪】<-----|
	↑                  抢到CPU执行权↓   被抢走CPU执行权
【阻塞】<----sleep join----------【执行】------↑
				     run方法执行完成↓
                               【死亡】
```



# 多线程的实现方式二:Runnable

Runnable

文档示例

```java
class PrimeRun implements Runnable {
	long minPrime;
    PrimeRun(long minPrime) {
        this.minPrime = minPrime;
    }
    public void run() {
        //compute primes larger than minPrime
        ...
    }
}
```

步骤

1.实现Runnable接口

2.重写run方法

3.创建Runnable子类对象

4.创建Thread对象,并且把刚创建的Runnable子类对象作为参数传递

5.start方法启动

```java
public class Demo {
    public static void main(String[] args) {
        MyRunnable myRunnable = new MyRunnable();
        // thread 对象才代表线程
        Thread thread = new Thread(myRunnable);

        thread.setName("宋仲基");

        thread.start();
    }
}

class MyRunnable implements Runnable {
    @Override
    public void run() {
        for (int i = 0; i < 10; i++) {
            System.out.println(Thread.currentThread().getName()+"---"+i);
        }
    }
}
```



注意事项

- 我们Runnable接口子类的run()方法代码，会运行在子线程当中。

- 所以，在线程的第二种实现方式中，我们自己定义子类，实现Runnable接口的run方法，将要在子线程中执行

- 但是，Runnable子类对象，并不代表线程，它只代表，要在线程中执行的任务。

  我们认为，从逻辑上说，第二种方法逻辑十分清晰：

- 线程就是一条执行路径，至于在线程这条执行路径上，究竟执行的是什么样的具体代码， 应该和线程本身没有关系的

- 也就是说，线程，和在线程(执行路径)上执行的任务应该是没有什么直接关系的

- 线程实现的第二种方式，把线程(Thread对象代表线程) 和在 线程上执行的任务(Ruannable子类对象)分开

```java 
// 为什么Runnable当中的run方法会运行在子线程当中
new Thread(Runnable target)

Thread{
private Runnable target;
init(xxx){
	this.target = target;
}
run (){
	if(target!=null){
		target.run();
	}
}
}
```



# 方式一VS方式二

方式二一 VS 方式二：

- 方式一实现步骤较方式二少
- 方式一的实现方式，存在单重继承的局限性
- 方式二将线程和任务解耦
- 方式二，便于多线程数据的共享

# 数据安全问题

练习:

多线程仿真如下场景：
假设A电影院正在上映某电影，该电影有100张电影票可供出售，现在假设有3个窗口售票。请设计程序模拟窗口售票的场景。

分析：
3个窗口售票，互不影响，同时进行。
3个窗口共同出售这100张电影票

结果:

- 产生了重复的票
- 产生了不存在的票

方式一:

```java
public class Demo3 {
    public static void main(String[] args) {
        SellWindow sellWindow = new SellWindow();
        SellWindow sellWindow2 = new SellWindow();
        SellWindow sellWindow3 = new SellWindow();

        sellWindow.setName("A窗口");
        sellWindow2.setName("B窗口");
        sellWindow3.setName("C窗口");

        sellWindow.start();
        sellWindow2.start();
        sellWindow3.start();
    }
}

class SellWindow extends Thread {
    static int tickets = 100;
    @Override
    public void run() {
        while (true) {
            if (tickets > 0) {
                try {
                    Thread.sleep(200);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(getName()+"卖了第"+tickets--+"票");
            }
        }
    }
}
```

方式二:

```java
public class Demo4 {
    public static void main(String[] args) {
        SellWindow2 sellWindow2 = new SellWindow2();

        Thread thread = new Thread(sellWindow2);
        Thread thread2 = new Thread(sellWindow2);
        Thread thread3 = new Thread(sellWindow2);

        thread.setName("窗口A");
        thread2.setName("窗口B");
        thread3.setName("窗口C");

        thread.start();
        thread2.start();
        thread3.start();

    }
}

class SellWindow2 implements Runnable {
    int tickets = 100;
    @Override
    public void run() {
        while (true) {
            // 假设是线程A抢到CPU的执行权 tickets=100
            // 线程B抢到了CPU的执行权  100
            
            // 不存在的原因 假设A执行 此时 tickets=1
            if (tickets > 0) {
                try {
                    // 线程A睡眠 B睡眠
                    Thread.sleep(200);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName()
                +"卖了第"+tickets-- + "票");
                // A走到这里  100 
                // 又发生了线程切换 B抢到了CPU的执行权 100
                // A输出 卖了第100 张票
                // B输出 卖了第100 张票
                
                // tickets--拆成3步
                // 1.取值  2.做-1操作  3.重写赋值
                
                
                // ABC三个线程都进入了if
                // 最坏情况
                // A 卖了第1张票 此时还剩0张
                // B 卖了第0张票 此时还剩-1张票
                // C 卖了第-1张票 此时还剩-2张票
            }
        }
    }
}
```



## 产生数据安全问题的原因

分析:

- 多线程的运行环境
- 多线程访问了共享数据
- 存在非原子操作
  - 什么是原子操作?  一个操作要么一次完成 要么不执行



# 解决数据安全问题

先从逻辑上，解决把一组操作变成原子操作这件事情
   思路1：如果我们能在一个线程，对共享变量的一组操作的执行过程，能够阻止线程切换，那么很自然的，这一组操作就变成了原子操作。
          但是思路1我们实现不了： 抢占式线程调度，代码层面(线程中执行的代码)，无法控制线程调度

   思路2：我们无法阻止线程切换，但是我们换个思路，我们给共享变量，加一把锁，利用锁来实现原子操作
          使用锁，可以给共享变量加锁，从而保证：
			a. 只有加锁的线程，能够访问到共享变量
			b. 而且，在加锁线程，没有完成对共享共享变量的，一组操作之前，不会释放锁，
			c. 只要不释放锁.其他线程，即使被调度执行，也无法访问共享变量



锁的概念

```
Thread-01      |-----------|
Thread-02	   x Thread-03 |
  排队          |-----------|
```



## 解决方式一:synchronized

语法

```java
synchronized(锁对象){
	// 要同步的代码 对共享数据的操作
}
问题的关键是()里面填什么
```

锁对象是什么

- 可以是任意锁对象 但是要注意 一定必须是同一个锁对象

同步方法的锁对象

- this

静态方法锁对象

- 字节码文件对象

```java
public class Demo2 {
    public static void main(String[] args) {
        SellWindow2 sellWindow = new SellWindow2();
        Thread t1 = new Thread(sellWindow);
        Thread t2 = new Thread(sellWindow);
        Thread t3 = new Thread(sellWindow);
        t1.setName("窗口A");
        t2.setName("窗口B");
        t3.setName("窗口C");
        t1.start();
        t2.start();
        t3.start();
    }
}

class SellWindow2 implements Runnable {
    static int tickets = 100;
    Object obj = new Object();
    //A a = new A();
    int i = 0;

    @Override
    public void run() {
        while (true) {
            if (i % 2 == 0) {
                // 字节码文件对象 .class对象  
                synchronized (SellWindow2.class) {
                    if (tickets > 0) {
                        try {
                            Thread.sleep(100);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        System.out.println(Thread.currentThread().getName()
                                + "卖了第" + tickets-- + "票");
                    }
                }
            } else {
                sell();
            }
            i++;

        }
    }
	// 同步方法时 是this
    static private synchronized void sell() {

        if (tickets > 0) {
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName()
                    + "卖了第" + tickets-- + "票");


        }
    }
}
```



注意:

同步代码块的细节：
    a. synchronized代码块中的锁对象，可以是java语言中的任意对象(java语言中的任意一个对象，都可以充当锁的角色仅限于synchronized代码块中)：
        1)因为java中所有对象，内部都存在一个标志位，表示加锁和解锁的状态
        2)所以其实锁对象，就充当着锁的角色
        所谓的加锁解锁，其实就是设置随对象的标志位，来表示加锁解锁的状态。

​    b.  我们的代码都是在某一条执行路径(某一个线程中运行)，当某个线程执行到同步代码块时，
​        会尝试在当前线程中，对锁对象加锁
​        1） 此时，如果锁对象处于未加锁状态，jvm就会设置锁对象的标志位(加锁)，并在锁对象中记录，是哪个线程加的锁
​            然后，让加锁成功的当前线程，执行同步代码块中的代码

​        2） 此时，如果锁对象已经被加锁，且加锁线程不是当前线程，系统会让当前线程处于阻塞状态(等着)，
​            直到加锁线程，执行完了对共享变量的一组操作，并释放锁


​    c. 加锁线程何时释放锁？
​       当加锁线程，执行完了同步代码块中的代码(对共享变量的一组操作)，在退出同步代码块之前，
​       jvm自动清理锁对象的标志位，将锁对象变成未上锁状态(释放锁)

 千万要注意：
         a. 虽然，synchronized代码块，中的锁对象，可以是java语言中的任意对象
         b. 但是，在多线程运行环境下，想要让访问 同一个共享变量的， 多个synchronized代码块中的代码是原子操作
            注意，对同一个共享变量的访问，必须使用同一个锁对象。





## 解决方式二:Lock

文档示例

```java
Lock l = ...;
l.lock();
try{
    //access the resource protected by this lock
} finally {
    l.unlock();
}
```

语法:

```java
lock()
// 加锁
unlock()
// 释放锁
```

常用子类:

ReentrantLock

使用:

```java
public class Demo3 {
    public static void main(String[] args) {
        SellWindow3 sellWindow = new SellWindow3();
        Thread t1 = new Thread(sellWindow);
        Thread t2 = new Thread(sellWindow);
        Thread t3 = new Thread(sellWindow);
        t1.setName("窗口A");
        t2.setName("窗口B");
        t3.setName("窗口C");
        t1.start();
        t2.start();
        t3.start();
    }
}

class SellWindow3 implements Runnable {
    int tickets = 100;
    Lock lock = new ReentrantLock();
    /* 如何使用lock */
    @Override
    public void run() {
        while (true) {
            // 加锁
            lock.lock();
            try{
                if (tickets > 0) {
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(Thread.currentThread().getName()
                            + "卖了第" + tickets-- + "票");
                }
            }finally {
                // 释放锁
                lock.unlock();
            }
        }
    }
}
```



## 方式一VS方式二

 Lock锁对象 VS synchoronized 锁对象

   区别

      1.  synchronized 锁对象，只提供了用来模拟锁状态的标志位(加锁和释放锁)，
          但是加锁和释放锁的行为，都是由jvm隐式完成(和synchronized 锁对象没关系)，
          所以synchronized 锁对象不是一把完整的锁

   2.一个Lock对象，就代表一把锁，而且还是一把完整的锁，
     Lock对象，它如果要实现加锁和释放锁，不需要synchronized关键字配合，它自己就可以完成
     Lock(接口): lock() 加锁
                 unlock 释放锁

   3. 两种锁对象，实现完全不同的
      联系： 都可以实现线程同步

          1.  synchronized(锁对象) {
                需要同步的代码
            
          }
          
            2.  lock.lock()
            需要同步的代码
            lock.unlock()
                学习了Lock锁对象之后，我们就有两种方式，构造同步代码块，从而实现线程通过(构造原子操作)，
                实际开发的时，使用哪种方式呢？ 推荐 synchronized代码块
                    1. 两种方式，实现线程同步，效果相同，但是 使用synchronized代码块的方式要简单的多
          
                         2. 虽然说在jdk早期版本中，两种方式加锁和释放锁，确实有效率上的差别，Lock锁机制加锁释放锁
              效率高一些，但是，在今天的jdk中，两种方式加锁和释放锁的效率已经相差无几了

# 死锁

## 什么是死锁

2个或以上的线程竞争资源 而造成的互相等待的现象 

```
  .---拥有-->资源A<--等待---.
线程A                     线程B
  `---等待-->资源B<--拥有---`
都需要集齐资源释放
```



## 产生死锁的情况

```java
synchronized(objA){
	synchronized(objB){
		// 代码
	}
}
```

死锁例子:

```java
public class Demo {
    public static void main(String[] args) {
        DieLock dieLock = new DieLock(true);
        DieLock dieLock1 = new DieLock(false);

        Thread t1 = new Thread(dieLock);
        Thread t2 = new Thread(dieLock1);

        t1.start();
        t2.start();
    }
}
/*该类用来描述 锁*/
class MyLock {
    // 定义了2把锁
    static final Object objA = new Object();
    static final Object objB = new Object();
}

class DieLock implements Runnable {
    // 成员变量
    boolean flag;

    public DieLock(boolean flag) {
        this.flag = flag;
    }

    @Override
    public void run() {
        // synchronized(objA){
        //	synchronized(objB){
        //		// 代码
        //	}
        //}
        if (flag) {
            synchronized (MyLock.objA) {
                System.out.println("if A");
                synchronized (MyLock.objB) {
                    System.out.println("if B");
                }
            }
        } else {
            synchronized (MyLock.objB) {
                System.out.println("else B");
                synchronized (MyLock.objA) {
                    System.out.println("else A");
                }
            }
        }

    }
}
```



## 解决死锁

### 方式一

更改加锁顺序 加锁顺序保持一致

```java
public class Demo {
    public static void main(String[] args) {
        DieLock dieLock = new DieLock(true);
        DieLock dieLock1 = new DieLock(false);

        Thread t1 = new Thread(dieLock);
        Thread t2 = new Thread(dieLock1);

        t1.start();
        t2.start();
    }
}
/*该类用来描述 锁*/
class MyLock {
    // 定义了2把锁
    static final Object objA = new Object();
    static final Object objB = new Object();
}

class DieLock implements Runnable {
    // 成员变量
    boolean flag;

    public DieLock(boolean flag) {
        this.flag = flag;
    }

    @Override
    public void run() {
        // synchronized(objA){
        //	synchronized(objB){
        //		// 代码
        //	}
        //}
        if (flag) {
            synchronized (MyLock.objA) {
                System.out.println("if A");
                synchronized (MyLock.objB) {
                    System.out.println("if B");
                }
            }
        } else {
            synchronized (MyLock.objA) {
                System.out.println("else B");
                synchronized (MyLock.objB) {
                    System.out.println("else A");
                }
            }
        }
    }
}
```



### 方式二

再加一把锁  把一个非原子操作变成一个原子操作

```java
public class Demo {
    public static void main(String[] args) {
        DieLock dieLock = new DieLock(true);
        DieLock dieLock1 = new DieLock(false);

        Thread t1 = new Thread(dieLock);
        Thread t2 = new Thread(dieLock1);

        t1.start();
        t2.start();
    }
}
/*该类用来描述 锁*/
class MyLock {
    // 定义了2把锁
    static final Object objA = new Object();
    static final Object objB = new Object();
    static final Object objC = new Object();
}

class DieLock implements Runnable {
    // 成员变量
    boolean flag;

    public DieLock(boolean flag) {
        this.flag = flag;
    }

    @Override
    public void run() {
        // synchronized(objA){
        //	synchronized(objB){
        //		// 代码
        //	}
        //}
        if (flag) {
            synchronized (MyLock.objC) {
                synchronized (MyLock.objA) {
                    System.out.println("if A");
                    synchronized (MyLock.objB) {
                        System.out.println("if B");
                    }
                }
            }
        } else {
            synchronized (MyLock.objC) {
                synchronized (MyLock.objB) {
                    System.out.println("else B");
                    synchronized (MyLock.objA) {
                        System.out.println("else A");
                    }
                }
            }

        }

    }
}
```



# 生产者和消费者模型

# 线程通信

## 等待唤醒机制

线程间通信，Java中主要通过Object中的方法来实现：
wait()          阻止自己
notify()        通知别人
notifyAll()    通知别人

    wait方法
    1. 阻塞功能：
        当在某线程中，对象上.wait(), 在哪个线程中调用wait(), 导致哪个线程处于阻塞状态
        当某线程，因为调用执行某对象的wait(),而处于阻塞状态，我们说，该线程在该对象上阻塞。
    	 Object A = 	new Object()  o.wait()
    2. 唤醒条件
       当某线程，因为某对象A的wait(), 而处于阻塞状态时，如果要唤醒该线程，只能在其他线程中，
       再同一个对象(即对象A)上调用其notify()或notifyAll()
       即在线程的阻塞对象上，调用notify或notifyAll方法，才能唤醒，在该对象上阻塞的线程
    3. 运行条件
          当前线程必须拥有此对象监视器。
          监视器：指synchronized代码块中的锁对象
        即我们只能在，当前线程所持有的synchronized代码块汇中的，锁对象上调用wait方法，
        才能正常执行
        如果我不在同步代码块中调用就会有这样一个异常
        IllegalMonitorStateException
        示例:
        public class Demo {
        public static void main(String[] args) {
            A a = new A();
            try {
                a.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
    
    class A {
    
    }
        
    4. 执行特征
          a.该线程发布(release)对此监视器的所有权
          b.等待(阻塞)

notify:

- 唤醒在此对象监视器上等待的单个线程。
- 如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。
- 选择是任意性的



面试题：
    Thread.sleep VS Object.wait()

1. 所属不同：
   a. sleep定义在Thread类，静态方法
   b. wait定义在 Object类中，非静态方法

2. 唤醒条件不同
   a. sleep: 休眠时间到
   b. wait: 在其他线程中，在同一个锁对象上，调用了notify或notifyAll方法

3. 使用条件不同：
   a. sleep 没有任何前提条件
   b. wait(), 必须当前线程，持有锁对象，锁对象上调用wait()

4. 休眠时，对锁对象的持有，不同：（最最核心的区别）
   a. 线程因为sleep方法而处于阻塞状态的时候，在阻塞的时候不会放弃对锁的持有
   b. 但是wait()方法，会在阻塞的时候，放弃锁对象持有



例子:

```
生产者--->蒸笼--->消费者
蒸笼属于共享数据，非空则生产者停消费者吃，空则消费者停生产者在生产
```



```
分析:
类定义:
蒸笼类 Box
生产者线程  消费者线程
包子  Food

方法:
生产包子的方法  setFood(Food newFood)
吃包子的方法    eatFood()
判断蒸笼状态方法  boolean isEmpty()
```

代码

第一版

```java
/*蒸笼类*/
public class Box {
    // 定义成员变量包子
    Food food;

    // 定义方法
    // 生产包子
    public void setFood(Food newFood) {
        food = newFood;
        System.out.println(Thread.currentThread().getName()
        +"生产了"+newFood);
    }
    // 吃包子
    public void eatFood() {
        System.out.println(Thread.currentThread().getName()
                + "吃了" + food);
        food = null;
    }

    // 判断蒸笼状态方法
    public boolean isEmpty() {
        return food==null;
        // 如果为true 表示蒸笼为空
        // 如果false 表示蒸笼非空
    }

}

/*包子类*/
class Food {
    // 定义成员变量
    String name;
    int price;

    public Food(String name, int price) {
        this.name = name;
        this.price = price;
    }

    @Override
    public String toString() {
        return "Food{" +
                "name='" + name + '\'' +
                ", price=" + price +
                '}';
    }
}

package com.cskaoyan.producer_consumer.V1;

public class ConsumerTask implements Runnable{
    // 蒸笼
    Box box;

    public ConsumerTask(Box box) {
        this.box = box;
    }

    @Override
    public void run() {
        while (true) {
            synchronized (box) {
                // 消费者: 吃包子
                //判断蒸笼状态
                if (box.isEmpty()) {
                    //如果蒸笼为空 说明没有包子
                    //阻止自己吃
                    try {
                        box.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                } else {
                    //如果蒸笼非空 说明有包子
                    box.eatFood();
                    //吃包子 并且通知生产者再生产
                    box.notify();
                }
            }
        }
    }
}

package com.cskaoyan.producer_consumer.V1;

import java.util.Random;
public class ProducerTask implements Runnable{
    // 定义蒸笼
    Box box;
    Food[] foods = {new Food("杭州小笼包", 5),
            new Food("开封灌汤包", 30), new Food("天津狗不理", 50)};
    Random random;

    public ProducerTask(Box box) {
        this.box = box;
        random = new Random();
    }

    public ProducerTask() {

    }

    @Override
    public void run() {
        while (true) {
            synchronized (box) {
                // 生产者  : 生产包子
                //判断蒸笼状态
                if (box.isEmpty()) {
                    //如果为空 说明没有包子
                    //生产包子   通知消费者来吃
                    // random.nextInt(int bound) [0,bound)
                    int index = random.nextInt(foods.length);
                    box.setFood(foods[index]);
                    box.notify();
                } else {
                    //如果非空 说明有包子
                    //阻止自己生产包子
                    try {
                        box.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }

            }
        }
    }
}


public class TestDemo {
    public static void main(String[] args) {
        // 创建生产者 消费者任务
        Box box = new Box();
        ProducerTask producerTask = new ProducerTask(box);
        ConsumerTask consumerTask = new ConsumerTask(box);

        // 创建线程
        // 生产者线程
        Thread t1 = new Thread(producerTask);
        Thread t2 = new Thread(consumerTask);

        t1.setName("生产者");
        t2.setName("消费者");

        // 启动线程
        t1.start();
        t2.start();
    }
}

```

第二版本

```java
public class TestDemo {
    public static void main(String[] args) {
        // 创建蒸笼对象
        Box box = new Box();
        // 创建生产者 消费者任务
        ProducerTask producerTask = new ProducerTask(box);
        ConsumerTask consumerTask = new ConsumerTask(box);

        // 创建线程
        Thread t1 = new Thread(producerTask);
        Thread t3 = new Thread(producerTask);

        t1.setName("生产者1");
        t2.setName("消费者1");

        // start
        t1.start();
        t2.start();
    }
}


public class ConsumerTask implements Runnable{
    Box box;

    public ConsumerTask(Box box) {
        this.box = box;
    }

    @Override
    public void run() {
        while (true) {
            box.eatFood();
        }
    }
}


import java.util.Random;
// 生产者
public class ProducerTask implements Runnable{
    Box box;
    Food[] foods = {new Food("上海生煎包",15),
            new Food("叉烧包",10),new Food("黄金开口笑",30)};
    Random random;

    public ProducerTask(Box box) {
        this.box = box;
        random = new Random();
    }

    @Override
    public void run() {
        while (true) {
            int index = random.nextInt(foods.length);
            box.setFood(foods[index]);
        }
    }
}

public class Box {
    Food food;

    // 生产包子 只有生产者执行
    public synchronized void setFood(Food newFood) {
        // 生产包子
        //判断蒸笼状态
        if (food == null) {
            //如果为空 说明没有包子
            //生产包子   通知消费者来吃
            food = newFood;
            System.out.println(Thread.currentThread().getName()
            +"生产了"+newFood);
            this.notify();
        } else {
            //如果非空 说明有包子
            //阻止自己生产包子
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }


    }

    // 吃包子 只有消费者执行
    public synchronized void eatFood() {
        // 吃包子
        //判断蒸笼状态
        if (food == null) {
            //如果蒸笼为空 说明没有包子
            //阻止自己吃
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        } else {
            //如果蒸笼非空 说明有包子
            //吃包子 并且通知生产者再生产
            System.out.println(Thread.currentThread().getName()
            +"吃了"+food);
            food = null;
            this.notify();
        }

    }
}

class Food {
    String name;
    int price;

    @Override
    public String toString() {
        return "Food{" +
                "name='" + name + '\'' +
                ", price=" + price +
                '}';
    }

    public Food(String name, int price) {
        this.name = name;
        this.price = price;
    }
}
```

当有多个生产者和消费者的时候  出现卡顿的现象

假设生产者1线程获取了CPU的执行权,蒸笼是空的,另外3个线程 生产者2 消费者1 消费者2 都在阻塞

生产者1生产包子,notify方法  唤醒线程 . 是随机的

如果唤醒的是消费者线程 没有问题

但是唤醒的是生产者2线程 判断蒸笼是否为空  非空  wait方法 造成4个线程阻塞.

怎么解决?

notifyAll方法

虚假唤醒

生产者1应该唤醒的是消费者线程  但是  notifyAll方法 生产者2线程也被唤醒





为什么wait, notify方法不定义在Thread类中?

- 锁对象可以是任意java对象



# 完整的线程转换图

```
                        ↓---------其他阻塞
      sleep()时间到join线程执行完毕     ↑join() sleep()等
                        ↓            ↑
|新建状态|--start()-->|就绪状态|--->|执行状态|--run()结束-->|死亡状态|
                                      ↓ ↓
                      ↓--synchronized-` `---wait()--↓   
                  |同步阻塞|<--notify或notifyAll--|等待阻塞|
```



# 多线程工具

## 线程池

为什么会有线程池?

```
Thread t = new Thread()
当run方法执行完 就进入了死亡状态 被回收
想要重新使用线程 还要重新创建 
就产生了线程池
```



### 三种线程池

```java
//JDK5提供了一Executors来产生线程池，有如下方法：
ExecutorService newCachedThreadPool()
// 1.会根据需要创建新线程，也可以自动删除，60s处于空闲状态的线程
// 2.线程数量可变，立马执行提交的异步任务（异步任务：在子线程中执行的任务）
ExecutorService newFixedThreadPool(int nThreads)
// 1.线程数量固定
// 2.维护一个无界队列（暂存已提交的来不及执行的任务）
// 3.按照任务的提交顺序，将任务执行完毕  
ExecutorService newSingleThreadExecutor()
// 1.单个线程
// 2.维护了一个无界队列（暂存已提交的来不及执行的任务）
// 3.按照任务的提交顺序，将任务执行完毕

```



如何使用

线程池的使用：ExecutorService(接口)
Future<T> submit(Callable<T> task)
Future<?> submit(Runnable task)

第一种方式   Future<?> submit(Runnable task)

```java
public class Demo {
    public static void main(String[] args) {
        ExecutorService pool = Executors.newFixedThreadPool(2);
        // 向线程池中提交任务submit()
        pool.submit(new MyRunnable());
        pool.submit(new MyRunnable());
        pool.submit(new MyRunnable());
        // 关闭线程池
        //pool.shutdown();
        
        pool.shutdownNow();
    }
}

class MyRunnable implements Runnable {

    @Override
    public void run() {
        for (int i = 0; i < 10; i++) {
            System.out.println(Thread.currentThread().getName()
            +"----"+i);
        }
    }
}
```



第二种方式 Future<T> submit(Callable<T> task)

```java
Future 表示异步计算的结果
public class Demo2 {
    public static void main(String[] args) {
        ExecutorService pool = Executors.newFixedThreadPool(2);
        Future future = pool.submit(new MyCallableTask());
        // get()
        // 如有必要，等待计算完成，然后获取其结果。
        try {
            System.out.println("get befor");
            String s = (String) future.get();
            System.out.println("get after");
            System.out.println(s);

        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
    }
}
// 可以理解为多线程的实现方式三
// Callable 和 Runnable的区别  一个带返回值 一个不带
class MyCallableTask implements Callable {

    // 注意 这里就不在是run方法了
    @Override
    public Object call() throws Exception {
        for (int i = 0; i < 10; i++) {
            System.out.println(Thread.currentThread().getName()
            +"-----"+i);
        }
        Thread.sleep(10000);
        return "hello call";
    }
}
```



### 多线程实现方式三:Callable

```java
public class Demo3 {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        // FutureTask(Callable<V> callable)
        // 创建一个 FutureTask，一旦运行就执行给定的 Callable。
        FutureTask futureTask = new FutureTask(new MyCallable());

        Thread thread = new Thread(futureTask);

        thread.start();

        String s = (String) futureTask.get();
        System.out.println(s);
    }
}

class MyCallable implements Callable {

    @Override
    public Object call() throws Exception {
        for (int i = 0; i < 10; i++) {
            System.out.println(Thread.currentThread().getName()
                    + "----" + i);
        }
        return "1234";
    }
}
```



## 定时任务

定时器

Timer()

```
定时器中维护了一个线程
|定时任务|___|___|___|___|
小顶堆
按照将要执行的时间顺序进行排序
```



```java
Timer的调度功能：
schedule(TimerTask task, Date time)
schedule(TimerTask task, long delay, long period)
schedule(TimerTask task, Date firstTime, long period)
scheduleAtFixedRate(TimerTask task, long delay, long period)
```



定时任务

TimerTask()



例子

```java
public class Demo {
    public static void main(String[] args) throws ParseException {
        Timer timer = new Timer();
        // schedule(TimerTask task, Date time)
        //schedule(TimerTask task, long delay, long period)
        //schedule(TimerTask task, Date firstTime, long period)
        //scheduleAtFixedRate(TimerTask task, long delay, long period)
        String s = "2021-3-23 16:07:10";
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        Date date = simpleDateFormat.parse(s);
        //timer.schedule(new MyTask(),date);
        //timer.schedule(new MyTask(),5000,3000);
        //timer.schedule(new MyTask(),date,5000);
        timer.scheduleAtFixedRate(new MyTask(),5000,3000);
        try {
            Thread.sleep(20000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        // cancel()
        // 取消此计时器任务。
        timer.cancel();
    }
}

class MyTask extends TimerTask {
    @Override
    public void run() {
        System.out.println("爆炸了!boom!");
    }
}
```



# 计算机网络

## OSI七层模型

1. 物理层：关注在一条通信信道上传输原始比特(01序列)
   其功能是确保当一方发送了比特1，另一方收到的也是比特1，而不是0。
   这里面涉及到的典型问题包括：
   a. 用什么样的电信号表示0和1
   b. 一个bit持续多少纳秒
   c. 传输是否可以在两个方向同时进行
   d. 初始连接如何建立,传输结束之后如何如何撤销连接
这些问题主要涉及，机械，电子，和时序接口等。以及物理层之下的物理传输介质等
2. 数据链路层：将一个原始的传输设施转变成一条没有漏剪检传输错误的传输线路
   为了完成这个任务，数据链路层具备如下功能：
   a. 成帧
   b. 差错控制(校验帧，确认 + 超时重传)
   c. 流量控制
   d. 广播式网络的数据链路层，还有介质访问控制问题
3. 网络层：其中的一个核心问题是如何将数据包从源端路由到接收端
4. 传输层：向上层提供端到端的通信服务，屏蔽底层的通信细节
   a. 提供应用进程之间的逻辑通信
   b. 复用和分用
   c. 向上层提供不同类型的通信服务
      TCP：面向连接的可靠的服务(保证报文数据的有序到达)
      UDP：无连接的不可靠的服务(不保证报文数据的顺序，广播报文数据)
5. 会话层：(记录谁发了消息，记录检查点)
   会话层允许不同主机上的各个进程之间进行会话，会话层利用传输层提供的端到端的服务，向表示层提供它的增值服务(进程上的一次连接，发送信息的过程)
   会话层负责管理主机间的会话，包括建立，管理及终止进程间的会话，会话层可以使用校验点，使通信会话在通信失效时，从校验点继续回复通信，实现数据同步。
6. 表示层：表示层主要处理两个通信系统中交换信息的表示方式
   不同机器采用的编码和表示方法不同，比如数据是否压缩，数据的加密和解密使用何种加密算法等等，这些都是由表示层决定的
7. 应用层：
   包含了用户通常所需要的各种协议。一个广泛使用的大家最熟悉的应用层协议，就是Http协议，它是www(万维网)，还有其他一些应用层协议，比如和电子邮件相关的smtp，pop
   ，还有ftp协议等等。
## IP地址

A:所谓IP地址就是给每个连接在Internet上的主机分配的一个32bit地址。按照TCP/IP规定，IP地址用二进制来表示，每个IP地址长32bit，比特换算成字节，就是4个字节。例如一个采用二进制形式的IP地址是“00001010000000000000000000000001”，这么长的地址，人们处理起来也太费劲了。为了方便人们的使用，IP地址经常被写成十进制的形式，中间使用符号“.”分开不同的字节。于是，上面的IP地址可以表示为“10.0.0.1”。IP地址的这种表示法叫做“点分十进制表示法”，这显然比1和0容易记忆得多。

B:IP地址的组成
IP地址 = 网络号码+主机地址

A类IP地址:第一段号码为网络号码，剩下的三段号码为本地计算机的号码
B类IP地址:前二段号码为网络号码，剩下的二段号码为本地计算机的号码
C类IP地址:前三段号码为网络号码，剩下的一段号码为本地计算机的号码

特殊地址:
127.0.0.1 回环地址,可用于测试本机的网络是否有问题. ping 127.0.0.1   

DOS命令 ipconfig:查看本机IP地址

xxx.xxx.xxx.0 网络地址
xxx.xxx.xxx.255 广播地址

A类	1.0.0.1---127.255.255.254	(1)10.X.X.X是私有地址(私有地址就是在互联网上不使用，而被用在局域网络中的地址)							(2)127.X.X.X是保留地址，用做循环测试用的。
B类	128.0.0.1---191.255.255.254	172.16.0.0---172.31.255.255是私有地址。169.254.X.X是保留地址。
C类	192.0.0.1---223.255.255.254	192.168.X.X是私有地址

 保留地址：
D类	224.0.0.1---239.255.255.254 	
E类	240.0.0.1---247.255.255.254	



```
		A主机Java进程						 B主机Java进程
【          应用层         		 】	  【       应用层          】
【         产生数据				 】	  【把字节数据转化为相应的数据】

【          传输层               】	   【       传输层          】
【       得到的字节数据           】		【接收到了来自A主机的字节数据】
【在jdk中已经实现了通信类Socket套接字】
【 (ip+port)，利用里面的方法发送数据 】
······································
1. ip唯一确定哪台主机
2. port唯一确定哪个进程
3. TCP与UDP协议
```



# UDP

```
		A主机Java进程						 B主机Java进程
【          应用层         		 】	   【       应用层          】
【         产生数据				 】	数 【把字节数据转化为相应的数据】
                                  =>据=>
【          传输层               】	 报 【       传输层          】
【       得到的字节数据           】   包	 【接收到了来自A主机的字节数据】
【在jdk中已经实现了通信类Socket套接字】
【 (ip+port)，利用里面的方法发送数据 】
UDP:无连接 不可靠
```



步骤

UDP传输的发送端：

- 建立udp的socket对象
- 将要发送的数据封装成数据包
- 通过udp的socket对象,将数据包发送出
- 释放资源



UDP传输接收端：

- 建立udp的socket对象.
- 创建用于接收数据的数据报包，通过socket对象的receive方法接收数据
- 通过数据包对象的功能来完成对接收到数据进行解析.
- 可以对资源进行释放

## DatagramSocket

此类表示用来发送和接收数据报包的套接字。

构造方法:

DatagramSocket(int port)        创建数据报套接字并将其绑定到本地主机上的指定端口。

成员方法:

send(DatagramPacket p)        从此套接字发送数据报包。

receive(DatagramPacket p)        从此套接字接收数据报包。

## DatagramPacket

此类表示数据报包

构造方法:

用来发送的数据报包

DatagramPacket(byte[] buf,  int offset, int length, InetAddress address, int port)        构造数据报包，用来将长度为 length 偏移量为 offset  的包发送到指定主机上的指定端口号。

用来接收数据报包:

DatagramPacket(byte[] buf,  int offset, int length)       构造  DatagramPacket，用来接收长度为 length 的包，在缓冲区中指定了偏移量。

成员方法:

| byte[] | getData()        返回数据缓冲区。                       |
| ------ | ------------------------------------------------------- |
| int    | getLength()        返回将要发送或接收到的数据的长度。   |
| int    | getOffset()        返回将要发送或接收到的数据的偏移量。 |

> 注意启动多线程，同时首发报文时，如果发送线程选择结束关闭socket的话，接受线程的socket就会报错，记得在异常判断中做出对策



# TCP

```
		A主机Java进程						 B主机Java进程
【          应用层         		 】	    【       应用层          】
【         产生数据				 】	    【把字节数据转化为相应的数据】
              ↓                     通            ↑
【          传输层               】 =>过=>【       传输层          】
【       得到的字节数据           】 <=流<=【接收到了来自A主机的字节数据】
【在jdk中已经实现了通信类Socket套接字】
【 (ip+port)，利用里面的方法发送数据 】
UDP:有连接 可靠的传输
```



```
通过accept方法返回一个Socket对象
通过socket对象就能获取输入输出流
...................
|服务端ServerSocket|
	↓			↑
	↓			↑
|客户端Socket      |
|获取输入输出流对象  |
​```````````````````
```



发送端(客户端)

- TCP客户端(发送端)
- 建立客户端的Socket服务,并明确要连接的服务器。
- 如果对象建立成功，就表明已经建立了数据传输的通道.就可以在该通道通过IO进行数据的读取和写入
- 根据需要从socket对象中获取输入，或输出流
- 向流中读取或写入数据
- 释放资源



服务端:

- TCP接收端(服务端)
- 创建Serversocket对象，在指定端口，监听客户端连接请求
- 收到客户端连接请求后，建立Socket连接
- 如果连接建立成功，就表明已经建立了数据传输的通道.就可以在该通道通过IO进行数据的读取和写入
- 从socket中根据需要获取输入，或输出流
  根据需要向流中写入数据或从流中读数据
- 释放资源

## Socket

此类实现客户端套接字（也可以就叫“套接字”）。

构造方法:

Socket(String host,  int port)       创建一个流套接字并将其连接到指定主机上的指定端口号。

成员方法:

| OutputStream | getOutputStream()        返回此套接字的输出流。 |
| ------------ | ----------------------------------------------- |

| InputStream | getInputStream()        返回此套接字的输入流。 |
| ----------- | ---------------------------------------------- |

## ServerSocket

此类实现服务器套接字。

构造方法:

ServerSocket(int port)        创建绑定到特定端口的服务器套接字。

成员方法:

| Socket | accept()        侦听并接受到此套接字的连接。 |
| ------ | -------------------------------------------- |



注意事项:

- java.net.ConnectException: Connection refused: connect 必须先启动服务端，先启动客户端报错

- 通过socket获得的InputStream在读取时，服务器接收时不要用while((readCount = in.read(bytes)) != -1)判断，经测试这和读取文件不一样，不会返回-1，我判断了下读取的长度小于字节缓存byte[] bytes的长度就终止读取循环，但这种做法是愚蠢的，万一最后一次刚好读满了，下一次再进循环就一直读取阻塞了....所以还是用shutdownInput，shutdownOutput会更好，这样能返回-1标记。或者自己再客户端上传完毕之后手动返回一个约定的标记。

  事实证明即使用shutdownOutput给服务端返回了-1，仍然是垃圾的操作者，关闭了流后面就没法用了。目前的解决方案最好是约定个标记来结束。

- 客户端上传文件时，先发送文件名在发送文件，服务端会连续读取文件名和内容而报错，客户端发送完文件sleep一点点，就能让服务端分开获取文件名和文件内容。当然这种愚蠢的处理方法以后掌握了更高端的操作之后就不存在这个问题了。

## TCP传输中容易出现的问题

shutdownInput，shutdownOutput

客户端连接上服务端，两端都在等待，没有任何数据传输。

什么原因呢？ 读阻塞

如何解决呢？

* 自定义标记

* shutdownInput，shutdownOutput

  ```
  调用Socket.shutdownInput( )后， 禁用此套接字的输入流，发送到套接字的输入流端的任何数据都将被确认然后被静默丢弃。任何想从该套接字的输入流读取数据的操作都将返回-1；
  
  调用Socket.shutdownOutput()后，禁用此套接字的输出流，对于 TCP 套接字，任何以前写入的数据都将被发送，并且后跟 TCP 的正常连接终止序列（即-1），之后，从另一端TCP套接字的输入流中读取数据时，如果到达输入流末尾而不再有数据可用，则返回 -1。
  
  就是说你没有调用shutdownOutput时，相当于没有跟服务器说“我已经说完啦，你可以说了”。那么服务器呢就觉得“哦，客户端还没说完，我要等它说完，要有礼貌”然后服务器就一直等，就阻塞了。他就不会给客户端发送消息“welcome”。
  ```

  测试shutdownInput虽然能返回-1，但是之后就不能使用流了，把我循环的工作搞成了一次性的...另寻他法。



# 反射

## 类加载

加载

通过类加载器获得二进制字节流
在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口

连接
验证：确保被加载类的正确性(正确性的校验)

​	cafe babe : magic number 起校验作用的

准备：负责为类的静态成员分配内存并设置默认初始化值

解析：将类中的符号引用(跟编译原理相关)替换为直接引用(内存地址)

初始化
给静态成员变量赋初值，执行静态代码块内容



类加载时机 （类初始化时机）

创建类的实例(首次创建该类对象)
访问类的静态变量(首次)
调用类的静态方法(首次)
使用反射方式来强制创建某个类或接口对应的java.lang.Class对象
加载某个类的子类，会先触发父类的加载
直接使用java.exe命令来运行某个主类，也就是执行了某个类的main()方法



类加载器

类加载器的分类(jdk8)
Bootstrap ClassLoader 根类加载器
Extension ClassLoader 扩展类加载器
System  ClassLoader  系统类加载器



java代码在计算机中的三个阶段

```
 Person.java 
[Person {    ]                 [  Class对象    ]
[//成员变量   ]                 [（字节码文件对象）]
[//成员方法   ]                 [               ]
[//构造方法   ]                 [Field[]        ]
[}           ]                 [描述类中的成员变量]
	  ↓         通过类加载器     [Method[]       ]==>[Person p = new Person()]
	javac     ClassLoader加载   [描述成员方法     ]
	  ↓                        [Constructor[]   ]
[Person.class]                 [描述构造方法      ]
源文件阶段Source                  Class类对象阶段          运行时阶段Runtime

```



# 反射技术

## 反射是什么

获取类运行时信息的一种技术,这种技术叫做反射技术.

换句话说,我们使用反射技术,类对于我们来说 是透明的, 我们相当于站在了上帝视角,可以获取类当中的所有信息

## 获取字节码文件对象的三种方式

Class类需要注意的地方

```java
/*final 说明不能被继承*/
public final class Class<T> implements java.io.Serializable,
                              GenericDeclaration,
                              Type,
                              AnnotatedElement {
    private static final int ANNOTATION= 0x00002000;
    private static final int ENUM      = 0x00004000;
    private static final int SYNTHETIC = 0x00001000;

    private static native void registerNatives();
    static {
        registerNatives();
    }
     /*private 说明不能通过new创建，只能通过反射获取*/
    private Class(ClassLoader loader) {
```



Class.forName("全类名")



类名.class()



对象.getClass()

```java
public class Demo2 {
    public static void main(String[] args) throws ClassNotFoundException {
        // 第一种方式 Class.forName("全类名")
        Class personClass = Class.forName("com.baidu.domain.Person");

        // 第二种方式 类名.class
        Class personClass1 = Person.class;

        // 第三种方式  对象.getClass()
        Person person = new Person();
        Class personClass2 = person.getClass();

        // 这3个对象是同一个吗? 同一个字节码文件对象
        System.out.println(personClass == personClass1);
        System.out.println(personClass == personClass2);
    }
}
```

注意:

```java
public class Demo3 {
    public static void main(String[] args) throws ClassNotFoundException {
        //Class c = Class.forName("com.baidu.getcls.A");
        // 静态代码块会执行吗? Class.forName  执行了

        Class c2 = A.class;
        // 静态代码块会执行吗?   A.class  这种方式不会触发类加载
    }
}

class A {
    static {
        System.out.println("loading A");
    }
}
```



## 配置文件Properties

原理

```
是个table
className=com.baidu.domain.Person
   key键           value值
|className|com.baidu.domain.Person|
|  ...    |      ...              |
|  ...    |      ...              |
```



怎么使用

Properties

Properties 类表示了一个持久的属性集

构造方法:

Properties()        创建一个无默认值的空属性列表。

成员方法:

| void | load(InputStream inStream)        从输入流中读取属性列表（键和元素对）。 |
| ---- | ------------------------------------------------------------ |
| void | load(Reader reader)        按简单的面向行的格式从输入字符流中读取属性列表（键和元素对）。 |

getProperty(String key)        用指定的键在此属性列表中搜索属性。



编解码注意：

* load(InputStream inStream) 源码中默认的字节流编码是ISO8859-1，所以配置文件中的中文读取后是乱码，要手动在创建流的时候指定正确的编码。

  ```java
  if (inStream != null) {
      //The line below is equivalent to calling a
      //ISO8859-1 decoder.
      c = (char) (0xff & inByteBuf[inOff++]);
  } else {
      c = inCharBuf[inOff++];
  }
  //实测用默认字节流读取之后，在用"ISO8859-1"解码为字节数组，再用该字节数组以GBK编码得到的字符串能正常显示,也说明了IDEA默认properties文件时GBK编码
  String username = properties.getProperty("username");
  byte[] bytes = username.getBytes("ISO8859-1");
  String s = new String(bytes, "GBK");
  System.out.println(s);
  ```

  

* IDEA新创建的properties文件编码默认是GBK，谨记properties文件和输入流编解码一致。

```java
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.sql.*;
import java.util.Properties;
/*配置文件一般放数据库配置信息 还有一些第三方的账号信息*/ 
public class Demo {
    public static void main(String[] args) throws SQLException, IOException {
        //String url = "jdbc:mysql://localhost:3306/test?useSSL=false";
        //String name = "root";
        //String password = "123456";

        // 通过配置文件读取配置信息
        Properties properties = new Properties();
        FileInputStream in = new FileInputStream("../day22_reflect/config.properties");
        properties.load(in);
        String url = properties.getProperty("url");
        String name = properties.getProperty("userName");
        String password = properties.getProperty("password");

        // 通过数据库驱动 获取连接
        Connection connection = DriverManager.getConnection(url, name, password);

        String selectInfo = "select * from user";
        // 预编译
        PreparedStatement preparedStatement =
                connection.prepareStatement(selectInfo);
        // 执行查询操作
        ResultSet resultSet = preparedStatement.executeQuery();
        // 取数据
        while (resultSet.next()) {
            int userId = resultSet.getInt("userId");
            String userName = resultSet.getString("userName");
            System.out.println("ID: " + userId + "用户名: " + userName);
        }
        connection.close();

    }
}
```

```java
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Properties;
public class Demo2 {
    public static void main(String[] args) throws IOException {
        // 通过配置文件读取配置信息
        Properties properties = new Properties();
        //FileInputStream in = new FileInputStream("../day22_reflect/config.properties");
        InputStreamReader in = new InputStreamReader(
                new FileInputStream("../day22_reflect/config.properties"),"GBk");
        properties.load(in);
        String url = properties.getProperty("url");
        String name = properties.getProperty("userName");
        String password = properties.getProperty("password");
        System.out.println(url);
        System.out.println(name);
        System.out.println(password);
    }
}

```



## 怎么使用反射

反射技术的起点就是获取字节码文件对象

### 需要掌握的

#### 获取构造方法

通过反射获取所有构造方法

- Constructor[] getConstructors() 
  - ​     返回一个包含某些 Constructor 对象的数组，这些对象反映此 Class  对象所表示的类的所有公共构造方法。
- Constructor[] getDeclaredConstructors()
  - 返回 Constructor 对象的一个数组，这些对象反映此 Class 对象表示的类声明的所有构造方法。

获取指定的构造方法

- Constructor<T> getConstructor(Class<?>... parameterTypes)
  -  返回一个 Constructor 对象，它反映此 Class 对象所表示的类的指定公共构造方法
  -  java.lang.NoSuchMethodException 因为去获取了非public的构造方法了
- Constructor<T> getDeclaredConstructor(Class<?>... parameterTypes)
  - 返回一个 Constructor 对象，该对象反映此 Class 对象所表示的类或接口的指定构造方法。

如何利用获得的构造方法实例化

newInstance(参数列表)

通过私有的构造方法 : java.lang.IllegalAccessException

```java
import java.lang.reflect.Constructor;
public class Demo1 {
    public static void main(String[] args) throws Exception{
        // 获取字节码文件对象
        Class personClass = Class.forName("com.baidu.domain.Person");
        // 获取所有public构造方法
        // Constructor[] getConstructors()
        System.out.println("获取所有public构造方法-------------");
        Constructor[] constructors = personClass.getConstructors();
        for (Constructor c :
                constructors) {
            System.out.println(c);
        }
        System.out.println("获取所有构造方法--------------");
        Constructor[] declaredConstructors = personClass.getDeclaredConstructors();
        System.out.println(declaredConstructors.length);
        for (Constructor c :
                declaredConstructors) {
            System.out.println(c);
        }
        // 获取指定的构造方法
        System.out.println("获取指定的构造方法--------------");
        Constructor constructor = personClass.getConstructor(String.class, int.class, boolean.class);
        System.out.println(constructor);
        System.out.println("获取指定的非public构造方法---------");
        Constructor declaredConstructor = personClass.getDeclaredConstructor(String.class);
        System.out.println(declaredConstructor);

        System.out.println("通过public构造方法进行实例化---------");
        Person person = (Person) constructor.newInstance("张三", 20, true);
        System.out.println(person);

        System.out.println("通过非public构造方法进行实例化---------");
        // setAccessible(true) 忽略java语法检查 暴力的方法
        declaredConstructor.setAccessible(true);
        Person person2 = (Person) declaredConstructor.newInstance("李四");
        System.out.println(person2);

    }
}

```



可变长参数

```java
/*
    可变长参数
    1.这个参数是可变的 1-n
    2.可变长参数可以理解为数组
    3.可变长参数只能有1个
 */
public class Demo2 {
    public static void main(String[] args) {
        m(1);
        m(1,2);
        m(1,2,3);
        m(new int[]{1,2,3});
        m1("哈哈",1);
        m1("哈哈",1,2,3);
    }

    public static void m(int... arg) {
        System.out.println("执行了 func  m!");
    }
    public static void m1(String s,int... arg){
        System.out.println("执行了 m1!");
    }

}

```



#### 获取成员变量

获取所有的public成员变量

Field[] getFields()

获取所有的成员变量

Field[] getDeclaredFields()

获取指定的public成员变量

Field getField(String name)

获取指定的成员变量

Field getDeclaredField(String name)

设置 获取成员变量的值

- Object get(Object obj)：获取值，传入对象
- void set(Object obj, Object value)：赋值，传入对象



#### 获取成员方法

获取所有的public的成员方法

Method[] getMethods()

获取所有的成员方法

Method[] getDeclaredMethods()

获取指定的public的成员方法

Method getMethod(String name, Class<?>... parameterTypes)

获取指定的成员方法

Method getDeclaredMethod(String name, Class<?>... parameterTypes



如何调用方法

Object invoke(Object obj, Object... args) 对带有指定参数的指定对象调用由此 Method 对象表示的底层方法。



```java
public class Person {
    public String name;
    private int age;
    protected boolean gender;

    public Person() {
    }

    public Person(String name, int age, boolean gender) {
        this.name = name;
        this.age = age;
        this.gender = gender;
    }

    private Person(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", gender=" + gender +
                '}';
    }

    public void eat(){
        System.out.println("eat food");
    }

    private void eat(String s) {
        System.out.println("eat " + s);
    }
}
```

应用场景:

一般用于框架 

```
|姓名|年龄|性别|成绩|  public class Student {
|张三|20  |男 |   |     String name;
|李四|28  |女 |   |     int age;
|   |    |   |   |      boolean gender;
                        int score;
     ORM             }
字节码文件对象获取constructor实例化
获取Fields
for(){
//遍历
field.set(obj, value)
}
```



### 了解

反编译成员变量

```java
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
public class Demo6 {
    public static void main(String[] args) throws Exception{
        // public class Person {
        //    public String name;
        //    private int age;
        //    protected boolean gender;
        // }

        Class c = Class.forName("java.io.BufferedInputStream");
        StringBuilder s = new StringBuilder();
        //s.append("public class Person {");
        s.append(Modifier.toString(c.getModifiers()) +
                " class " + c.getSimpleName() + "{");
        s.append("\r\n");
        Field[] declaredFields = c.getDeclaredFields();
        for (Field field : declaredFields) {
            s.append("\t");
            int modifiers = field.getModifiers();
            String strModifiers = Modifier.toString(modifiers);
            s.append(strModifiers);
            s.append(" ");
            // 获取类型
            String typeName = field.getType().getSimpleName();
            s.append(typeName);
            s.append(" ");
            // 获取field名字
            String fieldName = field.getName();
            s.append(fieldName);
            s.append(";");
            s.append("\r\n");
        }
        s.append("}");
        System.out.println(s);
    }
}

```

反编译成员方法:

```java
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
public class Demo7 {
    public static void main(String[] args) throws Exception{
        Class c = Class.forName("java.io.BufferedInputStream");
        StringBuilder s = new StringBuilder();
        s.append(Modifier.toString(c.getModifiers())
                + " class " + c.getSimpleName() + "{");
        s.append("\r\n");
        Method[] declaredMethods = c.getDeclaredMethods();
        for (Method m :
                declaredMethods) {
            s.append("\t");
            // 权限修饰符
            int modifiers = m.getModifiers();
            String strModifiers = Modifier.toString(modifiers);
            s.append(strModifiers);
            s.append(" ");
            String returnTypeName = m.getReturnType().getSimpleName();
            s.append(returnTypeName);
            s.append(" ");
            // 方法名
            String name = m.getName();
            s.append(name);
            s.append("(");
            // 获取参数
            Class[] parameterTypes = m.getParameterTypes();
            for (int i = 0; i < parameterTypes.length; i++) {
                s.append(parameterTypes[i].getSimpleName());
                s.append(",");
            }
            if (parameterTypes.length > 0) {
                s.deleteCharAt(s.length() - 1);
            }
            s.append(");");
            s.append("\r\n");
        }
        s.append("}");
        System.out.println(s);
    }
}
```

## 反射编写泛型数组代码

```java
//创建与原数组类型相同的新数组的通用的数组代码。
public static Object goodCopyOf(Object a, int newLength){
    Class cl = a.getClass();
    if(!cl.isArray()) return null;
    Class componentType = cl.getComponentType();
    int length = Array.getLength(a);
    Object newArray = Array.newInstance(componentType, newlength);
    System.arraycopy(a, 0, newArray, 0, Math.min(length, newLength));
    return newArray;
}
/**********************************
这个CopyOf方法可以洪濑扩展任意类型的数组，不仅是对象数组。
参数声明为Object而不是对象型数组Object[]是因为如整形数组类型int[]可以被转换成Object，但不能转换成对象数组。
**********************************/
```

> java.lang.reflect.Array 1.1
>
> * static Object get(Object array, int index)
>
> * static xxx getXxx(Object array, int index)
>
>   (xxx是boolean、byte、char、double、float、int、long、short之中的一种基本类型。)这些方法将返回储存在给定位置上的给定数组的内容。
>
> * static void set(Object array, int index, Object newValue)
>
> * static setXxx(Object array, int index, xxx newValue)
>
>   (xxx是boolean、byte、char、double、float、int、long、short之中的一种基本类型。)这些方法将一个新值储存到给定位置上的给定数组中。
>
> * static int getLength(Object array)
>
>   返回数组的长度
>
> * static Object newInstance(Class componentType, int length)
>
> * static Object newInstance(Class componentType, int[] lengths)
>
>   返回一个具有给定类型、给定维数的新数组。

## 我在使用泛型不良是的启示

### 泛型方法和泛型类泛型命名相同的机制以及返回泛型数组的疑问

```java
public class Demo {
    public static void main(String[] args) {
        MyGeneric<String> sss = new MyGeneric<String>("hello");
        Object test = sss.test();
        System.out.println(test);
    }
}
class MyGeneric<T> {//这个叫<T>1
    T value;
    public MyGeneric(T value) {
        this.value = value;
    }
    //这个叫<T>2
    public <T> T test(/*T t*/) {
        return (T) value;
    }
}
/*总结：
<T>2在所定义的方法中优先级高于定义在类中的<T>1，
如果不在泛型方法的参数列表中传入指定的泛型，定义在方法上的泛型<T>2实际上是Object类型，如上所示，在main方法中返回的实际是被强转为Object类型的返回值，如果传入参数的话，按参数对应类型强转。<T>2定义了的情况下如果返回value，由于覆盖问题，必须强转，否则报错，当然只不过转为了Object类型，因为<T>2根本没接收参数。<T>2不定义的情况下就不用加强转符号也不报错了，方法体内使用类所定义的泛型类型。
*/
//至于我为什么会遇到这么蛋疼的问题，是因为我实现线性表想返回个泛型数组时发现的问题。如下：
class MyDBLinkedList<T> {
    private Node head;
    private Node end;
    private int size;
    //尾部添加元素
    public boolean add(T t) {
        if (t == null) return false;//拒绝存null
        if (isEmpty()) {//链表为空内容
            head = end = new Node(null, t, null);
            size++;
            return true;
        }
        //链表内容不空，尾插
        end.next = new Node(end, t, null);
        end = end.next;
        size++;
        return true;
    }
    /**
    1.
    当我在这个方法上定义了<T>时，ts[index] = mid.value报错，我不解，我以为泛型方法上定义的<T>和类上定义的<T>是一个T，实际上不是的，我这多此一举的写法当值方法体内必须要求我把T强转为T，很懵逼，写了小测试发现定义在泛型方法上的T确实和类上的T不是一样的，这是在这里我没有给方法传入指定的T类型。
    2.
    当然我是想返回泛型数组，在不判空的情况下直接用了链表元素的通过反射创建数组，这是个Object类型的，但由于是我反射的，我直接强转为对应的T类型，最后在外面调用方法也的确能返回给我对应的类型。我觉得很好用，但大佬说不要这样用..不解中。
    **/
    //Object[] toArray() // 把一个线性表存储的内容以数组返回
    public  T[] toArray() {
        Class aClass = head.value.getClass();
        T[] ts = (T[]) Array.newInstance(aClass, size);//我测试了下返回泛型数组，可以，但是天明大佬不建议，一般是用于泛型方法，传入一个泛型

        Object[] arr = new Object[size];//题目要求是返回个object数组,这个当然没问题，但是我想返回泛型数组
        int index = 0;
        Node mid = head;
        while (mid != null) {
            ts[index] = mid.value;
            arr[index] = mid.value;
            mid = mid.next;
            index++;
        }
        return ts;
    }
    public int size() {
        return size;
    }
    public boolean isEmpty() {
        return size == 0;
    }

    @Override
    public String toString() {
        return "{" +
                "head=" + head +
                ", size=" + size +
                '}';
    }

    class Node {
        Node pre;
        T value;
        Node next;
        public Node(Node pre, T value, Node next) {
            this.pre = pre;
            this.value = value;
            this.next = next;
        }
        public boolean hasPre() {
            return pre != null;
        }
        public boolean hasNext() {
            return next != null;
        }
        @Override
        public String toString() {
            return "{" +
                    "v=" + value +
                    ", next=" + next +
                    '}';
        }
    }
}

```



## 关于反射调用方法

> invoke的参数和返回值必须是Object类型。意味着必须进行多次转换。会使编译器错过检查代码的机会，而且是用反射获得方法指针的代码要比仅仅直接调用方法明显慢一些。鉴于此，建议尽在必要的时候才使用Method对象，而最好使用接口以及Java SE 8中的lambda表达式。建议Java开发者不要使用Method对象的回调功能。使用接口进行回调会使得代码的执行速度更快，更易于维护。



[TOC]

# 注解

## 什么是注释

注释有三种形式:
1,单行注释：//
2,多行注释：/*    */
3,文档注释：/**  */

## 什么是注解

相比较于注释：
     1，注解和注释都是为代码添加额外信息
     2，定义不同。注解是Java的一种数据类型，和class，接口具有同等地位
     3，作用不同。注解是给编译器看的，编译不过会报错
     4，使用位置不同。注解的使用位置有严格限制
     5，注释完全不参与class文件和之后的JVM内存，只存在于Java文件层次，但是注解可以参与。

Java 注解用于为 Java 代码提供元数据。作为元数据，注解不直接影响你的代码执行，但也有一些类型的注解实际上可以用于这一目的。Java 注解是从 Java5 开始添加到 Java 的。

将注解理解为生活中的标签，往抽象地说，标签并不一定是一张纸，它可以是对人和事物的属性评价。在程序中，想象一下代码都是具有生命的，注解就是对代码这个鲜活生命的描述，凸出他们的个性。比如我们把纹身当成黑恶势力的标签，这个标签的对象是人，这个人不是一个好人，就好比override的对象是方法，这个方法是一个复写了父类的方法。

# 自定义注解

## 注解定义

```java
语法:
权限修饰符 @Interface 注解名称{

}
```



## 注解体定义

```java
语法
权限修饰符 @Interface 注解名称{
	属性类型 属性名称 ();
    属性类型 属性名称 ();
    属性类型 属性名称 ();
}

a. 所有的基本数据类型
b. String类型
c. Class类型
d. 枚举类型
e. 以上类型的数组
```

举例:

```java
// 注解定义
public @interface MyAnnotation {
    //int minAge() default 18;
    //int maxAge() default 25;
    int value();
    String[] name();
    boolean gender();
    Class param();
    Class[] params();
    // 等等 上述 类型 以及他们的数组
}
```



# 注解的使用

## 使用的注意事项

给注解中的数据赋值有两种方式：

- 使用注解时，给每个数据赋值，即括号里写
  在定义注解时，给每个注解定义默认值，这样的话在使用注解时，没被赋值的数据就用默认值。但是注意引用类型的数据，其默认值不能取null
- 若注解中的数据是value，且只有名为value的数据需要赋值，这样的赋值可以简写

```java
// 注解定义
public @interface MyAnnotation {
    //int minAge() default 18;
    //int maxAge() default 25;
    int value();
}

//使用
class Stu {
    // 当注解中的属性名为value时,赋予初值的时候可以不用  (属性名=属性值) 可以直接赋值
    // 当有默认值的时候也可以省略赋值 默认值关键字为default
    @MyAnnotation(10)
    int age;

    public Stu(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "Stu{" +
                "age=" + age +
                '}';
    }
}
```



# 注解处理器

练习:

创建一个学生对象,约束条件要求年龄在18-25,名字长度小于5个字符

将学生类中的构造方法设置为private,我们就不能通过new 去创建对象,我们想到可以利用反射去做.自己构建一个注解处理器.

思路:

通过反射 去创建学生对象 , 但是在创建之前要 先获取 学生类中的成员变量,并判断他们是否使用了注解,如果使用了,那么我们去获取他的注解实例,从而获取他的注解中的属性值.拿到属性值之后,去判断我们传递的参数是否合法,如果不合法 那么抛出 异常.

注解定义:

```java
//注解定义
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD,ElementType.CONSTRUCTOR,ElementType.METHOD,ElementType.TYPE})
public @interface AgeBound {
    int maxAge()default 25;
    int minAge()default 18;
}
@Retention(RetentionPolicy.RUNTIME)
@interface nameBound {
    int nameLimit()default 5;
}
```

注解使用:

```java
public class Student {
    @AgeBound()
    int age;

    @nameBound()
    String name;

    @AgeBound()
    private Student( String name,int age) {
        this.age = age;
        this.name = name;
    }

    @Override
    public String toString() {
        return "Student{" +
                "age=" + age +
                ", name='" + name + '\'' +
                '}';
    }
}

```

注解处理器:

```java
//写法没问题，没有作用是因为并未设置元注解
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
/*
利用注解，结合我们自定义的注解处理器，实现如下需求：
定义一个Student类,包含name和age两个成员
name中包含的字符个数不得超过指定值(具体的约束条件信息-> 注解)
age必须在指定范围内(具体的约束条件信息-> 注解)
name和age都满足条件才能创建Student对象，否则抛出异常。(该效果由注解处理器来实现)
 */
public class StudentFactory {
    Class stuClass;

    public StudentFactory() {
        this.stuClass = Student.class;
    }

    public Student getStudent(String name, int age) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchFieldException {
        // 校验姓名
        judgeName(name);
        // 校验年龄
        judgeAge(age);

        Constructor declaredConstructor =
                stuClass.getDeclaredConstructor(String.class,int.class);
        declaredConstructor.setAccessible(true);
        Student student = (Student) declaredConstructor.newInstance(name, age);
        return student;
    }

    private void judgeAge(int age) throws NoSuchFieldException {
        // 获取age 成员变量
        Field ageField = stuClass.getDeclaredField("age");
        // 判断成员变量 是否使用了注解
        boolean annotationPresent = ageField.isAnnotationPresent(AgeBound.class);
        if (annotationPresent) {
            // 获取注解实例
            AgeBound annotation = ageField.getAnnotation(AgeBound.class);
            // 获取具体的属性值
            int minAge = annotation.minAge();
            int maxAge = annotation.maxAge();
            // 做校验
            if (age < minAge || age > maxAge) {
                throw new IllegalArgumentException("年龄不合法:  "
                +age);
            }
        }


    }

    private void judgeName(String name) throws NoSuchFieldException {
        // 获取属性name中的值
        // 先获取成员变量
        Field nameField = stuClass.getDeclaredField("name");
        // 判断一下 是否使用了注解
        // isAnnotationPresent 是否使用了注解  为true 说明使用了 false 没使用
        boolean annotationPresent = nameField.isAnnotationPresent(nameBound.class);
        System.out.println(annotationPresent);
        if (annotationPresent) {
            // 获取注解实例
            nameBound annotation = nameField.getAnnotation(nameBound.class);
            //获取属性name中的值
            int nameLimit = annotation.nameLimit();
            // 校验工作
            if (name.length() > nameLimit) {
                throw new  IllegalArgumentException("姓名不合法:  "+name.length());
            }
        }
    }
}

```

> java.lang.reflect.AccessibleObject
>
> 直接已知子类Field, Method, Constructor
>
> * boolean isAccessible()
>
>   获取此对象 的accessible标志值，默认为false，即不管修饰符为public还是private等，都是false。根据源码其指的是是否忽略语言层面的检查。所以用isAccessible判断是否需要setAccessible是没有作用的。只有setAccessible之后才会改变其状态。

# 元注解

## 什么是元注解

描述注解的注解     元数据 meta data (描述数据的数据)

## 2种常用元注解

### @Target

      @Target元注解，注解可以作用的目标
         对于注解而言，可以作用的目标：
         1. 整个类    ElementType.TYPE
         2. 成员变量   ElementType.FIELD
         3. 构造方法   ElementType.CONSTRUCTOR
         4. 成员方法   ElementType.METHOD

### @Retention

      @Retention元注解，来定义我们自己定义的注解的保留级别.
        1. RetentionPolicy.RUNTIME
        2. RetentionPolicy.CLASS
        3。RetentionPolicy.SOURCE







# 内存管理方式

## 显示内存管理

### 显示内存管理是什么

内存的申请 释放都是程序员做的  malloc()   free()

### 常见问题

#### 内存泄漏

#### 野指针

```
100M-1M=99M            malloc：申请内存；free：释放内存
|模块一|------↓	     野指针：模块一释放资源，模块二模块三还在引用对象A
|模块二|--->|对象A|      内存泄露：没有模块去释放对象A，导致可用的内存减少了
|模块三|------↑
```



## 隐式内存管理

### 隐式内存管理是什么

由垃圾回收机制去处理

### 优缺点

优点：增加了程序的可靠性，减小了memory leak
缺点：无法控制GC的时间，耗费系统性能

# GC-Garbage collection

## 如何确定垃圾

### 引用计数

弊端 （互相引用）

```
A中的引用计数器是1
|对象A|
 ↓  ↑
|对象B|
B中的引用计数器是1
```



互相引用:

```java
public class CircularRefTest {
 private CircularRefTest instance = null; 
 private byte[] buffer = new byte[1024 * 1024];
 public static void main(String[] args) { 
CircularRefTest a = new CircularRefTest(); 
CircularRefTest b = new CircularRefTest();
 a.instance = b; 
 b.instance = a;

 a = null;
 b = null; 
 // 主动回收垃圾
 System.gc(); 
} 
} 
```



### 根搜索

```
|-------|            堆
|       |
|引用变量|------>|A|-->|B|  | C |
|       |	           ↓    ↓ ↑
|       |       |D|   |E|  | F |
| 栈    |        ↑
|-------|  |方法去中的静态属性引用的对象|

GC Roots包含的对象：
虚拟机栈中引用的对象，方法去中的静态属性引用的对象
```



## 如何回收垃圾

回收算法

#### 标记清除算法

```
垃圾对象	1		标记清除算法			
存活对象	0					
未使用	-1					
回收前				回收后		
1	0	1		-1	0	-1
0	-1	0	→	0	-1	0
1	0	1		-1	0	-1
				假设要创建一个数组		
				但是无法创建一个连续的存储空间		
特点：实现简单，但是会造成垃圾碎片
```



#### 标记复制算法

```
垃圾对象			1								
存活对象			0								
未使用			-1				标记复制算法				
			分配内存区域						保留区域		
回收前			1	0	1				-	-	-
			0	-1	0		→		-	-	-
			1	0	1				-	-	-
			成为新的保留区域						新的内存分配区		
			-	-	-				0	0	0
回收后			-	-	-				0		
			-	-	-						
特点：			1. 一次性回收大片的连续空间。								
			2. 不会产生内存碎片。								
			3. 如果说有少量对象存活的情况，复制起来很快，使用于少量对象存活的情况。								
			4. 但是，内存利用率低。								
			5. 如果有大量对象存活，就需要复制大量对象，效率就低了。								

```



#### 标记整理算法



回收过后会将存活对象排序放置 不会造成内存碎片 ,但是每次移动 都会消耗时间

#### 分带收集算法



## 何时回收垃圾

- 申请heap space失败后会触发GC回收
- 系统进入idle后一段时间会进行回收
- 主动调用GC进行回收

##  相关概念

- shallow size

  - 就是对象本身占用的内存大小，也就是对象头加成员变量占用内存大小的总和

- retained size

  - 是该对象自己的shallow size 加上仅可以从该对象访问（直接或者间接访问）的对象的shallow size之和

  - 是该对象被GC之后所能回收的内存的总和

  - ```
    .---------[GC Roots]----.
    ↓		      ↓         ↓
    [obj5]	←	<obj1>		|
    		      ↓		    ↓
    <obj4>	←	<obj2>	→	[obj3]
    ```

当GC roots到obj1的访问链断开 回收obj1时, 会去回收obj1  obj2  obj4 这3个对象(obj1直接或间接访问到的对象,也就是retained size)

```
.---------[GC Roots]----.
↓		      ↓         ↓
[obj5]	←	    		|                  ←	<obj1>
		      ↓		    ↓                         ↓
    	←	    	→	[obj3]       <obj4>	←	<obj2>	→
```



# 数据结构集合类

链表&数组

数据结构&实现

Collection集合类

Map集合类



1.什么是数据结构?

数据结构是相互之间存在一种或多种特定关系的数据元素的集合。

数据 + 结构/关系



2.数据结构和JAVA有什么关系?（数据结构在JAVA上的表现）

Java需要临时存储数据, 用集合类临时存储, 我们又希望存储的操作效率更高, 底层组织按照特定(数据结构)方式来组织存储数据。

数据结构本身和JAVA没有任何关系,

只不过JAVA中有多种集合、数组、等集合性质的多对象存储结构,

有时候我们希望更便捷,更具有逻辑性的操作这些集合或者数组数据

所以,我们根据数据结构的组织方式, 构建了一些特殊的JAVA集合类

用于描述了一些JAVA对象的底层数据的组成关系



3.数据结构的种类和JAVA中的集合类别有哪些?

数据结构: 集合, 线性表, 树  /  图

集合类: Collection, Map



为什么需要集合类？
    很多情况下，我们需要对一组对象进行操作。而且很可能事先并不知道到底有多少个对象。为了解决这个问题呢，Java 就提供了集合类供我们使用。(存储更多类型问题, 扩容问题, 内存空间浪费问题, 数据查找问题, 数据删除问题等等)

集合类的特点
    a. 只能存储引用数据类型
    b. 可以自动地调整自己的大小

数组和集合类都是容器，它们有何不同？
    a. 数组可以存储基本数据类型的数据，集合不可以。
    b. 数组的长度是固定的，集合可以自动调整自己的大小。
    c. 数组的效率高，相对来说集合效率比较低。
    d. 数组没有API，集合有丰富的API。



## 数据结构: 关系

数据结构是相互之间存在一种或多种特定关系的数据元素的集合。

公式：数据结构=数据+结构

数据：用类型表示

结构：在任何问题中，数据元素都不是孤立存在的，它们之间都存在着某种关系，这种数据元素相互之间的关系称为结构。

元素之间，通常有以下四种基本结构：

•集合

集合：结构中的数据元素之间除了同属于一个集合的关系之外，别无其他关系。这里的集合和数学中集合的概念是一致的。一”堆”数据, 

•线性结构

线性结构：结构中的数据元素之间存在一个对一个的关系。一串有序的数据

•树形结构

树形结构：结构中的数据元素之间存在一个对多个的关系。树有根节点和子树构成, 子树也是一棵树 (一对多的关系)

•图或网状结构

图或网状结构：结构中的数据元素之间，存在多个对多个的关系。



## 逻辑结构&物理结构

前面分类中定义的关系，描述的是数据元素间的逻辑关系，因此又称为逻辑结构。

但是仅仅知道数据元素间的逻辑关系是不够的，因为我们得实现自己的数据结构。

因此，我们得关注数据结构在计算机底层是如何表示的？

数据结构在计算机中的表示，称为数据的物理结构，又称为存储结构或者映像。

数据的表示很简单。

构的表示可以分为两种：顺序存储结构 (顺序映像) 和 链式存储结构 (非顺序映像)。

•顺序映像：借助元素在存储器中的相对位置来表示数据元素之间的逻辑关系。(数组)

•非顺序映像：借助指示元素存储地址的”指针”，来表示数据元素的逻辑关系。(链表)

## 数组

- Q1: 数组我们都很熟悉，那你理解的数组是什么样的呢？它的最主要特点是什么呢？

  数组是顺序存储, 所以可以随机访问.

  数组的本质是固定大小的连续的内存空间，并且这片连续的内存空间又被分割成等长的小空间。它最主要的特点是随机访问。

  数组的长度是固定的

  数组只能存储同一种数据类型的元素

  注意：在Java中只有一维数组的内存空间是连续，多维数组的内存空间不一定连续。

  那么数组又是如何实现随机访问的呢？

  寻址公式：i_address = base_address + i * type_length

- Q2: 为什么数组的索引是一般都是从0开始的呢？

  假设索引不是从0开始的，而是从1开始的，那么我们有两种处理方式：

  寻址公式变为： i_address = base_address + (i – 1) * type_length

  浪费开头的一个内存空间，寻址公式不变。

  在计算机发展的初期，不管是CPU资源，还是内存资源都极为宝贵，所以在设计编程语言的时候，索引就从0开始了，而我们也一直延续了下来。

  历史遗留问题,现在的编程语言有些索引是从1开始的，甚至有些编程语言还支持负数索引,如 ‘’易语言’’从1开始



- Q3: 为什么数组的效率比链表高？

   数组是连续存储, 链表是非连续存储

  CPU一天，内存一年；内存一天，IO十年。

### 数组的基本操作

- 添加 (保证元素的顺序)

  最好情况：O(1)

  最坏情况：移动n个元素，O(n)

  平均情况：移动 n/2 个元素，O(n)

- 删除 (保证元素的顺序)

  最好情况：O(1)

  最坏情况：移动n-1个元素，O(n)

  平均情况：移动(n-1)/2个元素，O(n)

- 查找

  a. 根据索引查找元素：O(1)

  b. 查找数组中与特定值相等的元素

  ①大小无序：O(n)

  ②大小有序：O(log2n)

总结: 数组增删慢，查找快。

## 链表

形象地说，链表就是用一串链子将结点串联起来。

结点：包含数据域和指针域。

数据域：数据

指针域：下一个结点的地址

```java
Class Node{
    String value;
    Node next;
}
```

```
结点： |数据域|指针域|
链表： |_____|_____|→|_____|_____|→|_____|_____|→|_____|_____|
```

链表的分类：



循环链表用的一般比较少，但是当处理的数据具有环形结构时，就特别适合用循环链表，比如约瑟夫问题。接下来我们讨论下单链表和双向链表。

## 单链表

单链表：

增加(在某个结点后面添加) 

删除(在某个结点后面删除) 

查找

   a. 根据索引查找元素      

   b. 查找链表中与特定值相等的元素

​      ①元素大小有序        

​      ②元素大小无序

总结：链表增删快，查找慢。

## 双向链表

很容易验证，前面那些操作，双向链表和单链表的时间复杂度是一样的。那为什么在工程上，我们用的一般是双向链表而不是单链表呢 (比如JDK中的 LinkedList & LinkedHashMap)？

那自然是双向链表有单链表没有的独特魅力——它有一条指向前驱结点的链接。

增加 (在某个结点前面添加元素)删除 (删除该结点)

查找

   a. 查找前驱结点

   b. 根据索引查找元素

   c. 查找链表中与特定值相等的元素

​     ① 元素大小无序

​     ② 元素大小有序 

总结：虽然双向链表更占用内存空间，但是它在某些操作上的性能是优于单链表的。

思想：用空间换取时间。

## 循环单链表

循环单链表: (单链表的基础上进行的改进)一个结点只有后继结点, 并且尾结点后继指向头结点

## 双向循环链表

双向链表的改进, 头结点前驱指向尾结点, 尾结点后继指向头结点

时间复杂度和空间复杂度:

理论分析: 

应用分析:  用空间换时间(我们从应用角度分析)

很容易验证，前面那些操作，双向链表和单链表的时间复杂度是一样的。那为什么在工程上，我们用的一般是双向链表而不是单链表呢 (比如JDK中的 LinkedList & LinkedHashMap)？

LinkedList → List → Collection

是一个集合类, 

集合类 : 看做一个数据容器

Java临时存储数据. 

实际在java代码中对数据进行操作, 更多的是查找操作



## 数组VS链表

| 时间复杂度 | 数组 | 链表 |
| ---------- | ---- | ---- |
| 插入&删除  | O(n) | O(1) |
| 访问       | O(1) | O(n) |

数组和链表的插入，删除，随机访问操作的时间复杂度刚好相反。

① 数组使用的是连续的内存空间，可以利用CPU的高速缓存预读数据。链表的内存空间不是连续的，不能有效预读数据。当然如果数组过大，系统没有足够的连续内存空间，会抛出OOM。

② 数组的缺点是大小固定，没法动态的调整大小。如果要存储一些对象，如果数组太大，浪费内存空间；如果数组太小，我们需要重新申请一个更大数组，并将数据拷贝过去，耗时。

③如果业务对内存的使用非常苛刻，数组更适合。因为结点有指针域，更消耗内存。而且对链表的频繁插入和删除，会导致结点对象的频繁创建和销毁，有可能会导致频繁的GC活动。

数组更加高效，链表更加灵活。

## 什么是线性表

线性表：n个数据元素的有序序列。

首先，线性表中元素的个数是有限的。

其次，线性表中元素是有序的。

那这个”序”指的是什么呢？

如果以ai表示数据元素，则线性表可以记为 {a1, … , ai-1, ai, ai+1, … , an}

表中, ai-1在 ai 之前，同时ai+1 在 ai 之后，我们称ai-1是ai的直接前驱，ai+1是ai的直接后继。

除表头和表尾元素外，其它元素都有唯一前驱和唯一后继，其唯一前驱或唯一后继确定了该元素在线性表中的位置。

因此，线性表中，每个数据元素都有一个确定的位序，这个确定的位序我们称之为索引。

表头元素有唯一后继，无前驱，表尾元素有唯一前驱，无后继。

## 链表练习

快慢指针的使用

求链表的中间元素（快慢指针）

判断链表中是否有环(circle)（快慢指针）

```
数学问题，有环快慢指针一定会相遇，而且慢指针不会走完一圈。我把链按极限密集情况想象为一条光滑的曲线，尾巴自来卷，卷回来解除了身体形成了一个小圆。
或者想象为正方形
          ____
__________|__|
```

有环的话判断环的始发点（快慢指针）

```
根据上面的想象进行数学计算
环外曲线长x，圆环周长y，环始发点到相遇点距离m
慢指针路程x+m
快指针路程x+L*y+m (L为相遇时快指针在换上熬过的整数圈)
右有快指针速度为慢指针的2倍数
故：2*(x+m) = x+L*y+m
简化为：x = L*y-m
配一下：x = (L-1)y + (y-m)
想象一下，容易完美理解的最简情况下x=y-m其实就是慢指针从相遇点走到环始发点的长度就是环外的长度x。这就很容易扩展理解了，如果L-1不为0，说明相遇前，快指针在孤独的等待时间里走入了死循环，把这个环想象成一个弹簧向远处散开，再把x这段环外的路线想象成一个相同的向远处散开的弹簧但是多出了一小节曲线就其实刚刚号等于y-m，其实也是环上弹走剥离掉完成圈数弹簧后留下的，符合公式。
之所以记录这么详细的思考过程其实是因为我数学没有什么积累，就算一时想明白了但是估计以后如果单纯看到公式还是会懵掉，而脑视角容易理解
```

反转单链表

```
(我的鲤鱼旗飘飘法很容易理解)
一串鲤鱼旗在旗杆上飘起来
我拿了另一个旗杆hooker来，从头一个个把原来的鲤鱼旗都接过来
风往右吹，动起来好理解
```

使用链表/数组实现一个线性表 ArrayList

```java
//下为以上练习
import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.logging.Level;
import java.util.logging.Logger;

public class Demo {
    public static void main(String[] args) {
        //0 1 2 3 4 5 6 7
        Node n07 = new Node("7", null);
        Node n06 = new Node("6", n07);
        Node n05 = new Node("5", n06);
        Node n04 = new Node("4", n05);
        Node n03 = new Node("3", n04);
        Node n02 = new Node("2", n03);
        Node n01 = new Node("1", n02);
        Node n00 = new Node("0", n01);
        System.out.println(n00);

        /*n07.next = n05;//寻找圈的始发点
        String circleStart = findCircleStart(n00);
        System.out.println(circleStart);*/

        /*n07.next = n03;//检查单向链表中是否有圈
        boolean hasCircle = hasCirclePart(n00);
        System.out.println(hasCircle);*/
       /* Node midNode = getMidNode(n00);//查找中间值
        System.out.println(midNode);*/
        /*Node reversed = reverseNode(n00);//反向单向链表
        System.out.println(reversed);*/
    }

    //检查有圈圈的单向链表中的圈始发点：快慢指针
    private static String findCircleStart(Node head) {
        Node fast = head;
        Node slow = head;
        while (fast.next != null && fast.next.next != null) {
            fast = fast.next.next;
            slow = slow.next;
            if (fast == slow) {
                break;
            }
        }
        if (fast.next == null || fast.next.next == null) {
            throw new RuntimeException("不存在圈异常");
        }
        fast = head;
        while (fast.next != null) {
            fast = fast.next;
            slow = slow.next;
            if (fast == slow) {
                break;
            }
        }
        return fast.value;
    }

    //检查单向链表中是否有循环圈: 快慢指针
    public static boolean hasCirclePart(Node head) {
        boolean flag = false;
        Node fast = head;
        Node slow = head;
        while (fast.next != null && fast.next.next != null) {
            fast = fast.next.next;
            slow = slow.next;
            if (fast == slow) {
                flag = true;
                break;
            }
        }
        return flag;
    }

    //查找单向链表中间值：快慢指针
    private static Node getMidNode(Node head) {
        Node fast = head;
        Node slow = head;
        while (fast.next != null && fast.next.next != null) {
            fast = fast.next.next;
            slow = slow.next;
        }
        return slow;
    }

    //反序单向链表
    private static Node reverseNode(Node head) {
        Node hooker = null;//想象成两串飘动的鲤鱼旗，这是我新建的一个鲤鱼旗勾点，让另一串鲤鱼旗一个个都挂上来
        Node mid = head;
        while (mid.next != null) {
            Node next = mid.next;
            mid.next = hooker;
            hooker = mid;
            mid = next;
        }
        mid.next = hooker;
        hooker = mid;
        return hooker;
    }
}

class SgNodeList {
    Node head;
    int size;

    public void add(String value) {//尾插新元素
        if (value == null) throw new IllegalArgumentException("非法参数，试图添加null");
        if (head == null) {
            head = new Node(value, null);
            size++;
            return;
        }
        Node temp = head;
        while (temp.next != null) {
            temp = temp.next;
        }
        temp.next = new Node(value, null);
        size++;
    }
    //TODO
    public boolean addByIndex(int index, String value) {//按下标插入新元素
        boolean flag = true;
        return flag;
    }
    @Override
    public String toString() {
        return "SingleNodeList{" +
                "head=" + head +
                ", size=" + size +
                '}';
    }
}
class Node {//节点，本来应该写在集合类里，将就测试用吧
    String value;
    Node next;

    public Node(String value, Node next) {
        this.value = value;
        this.next = next;
    }
    @Override
    public String toString() {
        return "Node{" +
                "value='" + value + '\'' +
                ", next=" + next +
                '}';
    }
}
```

 双向链表示例

```java
参考：
/**
 *  实现一个双向链表
 *  集合类: 容器
 *  底层结构: 双向链表
 *  数据结构: 线性表
 *
 */
public class MyDBLinked {

    private Node head;// 头结点
    private Node end; // 尾结点
    private int size;

    public boolean add(String str){
        if (str == null) throw new IllegalArgumentException("str is null");

        // 链表是否为空
        if (head == null || size == 0){
            head = new Node(null, str, null);
            end = head;
            size++;
            return true;
        }
        // 链表不空
        // 添加尾部

        // 创建一个新节点, 让它之前指向原本的end
        Node node = new Node(end, str, null);
        // 让旧尾结点的下一个指向新添加节点
        end.next = node;
        // 尾结点标记后移
        end = node;

        size++;
        return true;
    }

    public boolean remove(String str){
        if (str == null) throw new IllegalArgumentException("str is null");
        if (isEmpty()) throw new RuntimeException("linked is null");


        // 删除是不是头结点
        if (str.equals(head.value)){// 删除的就是头结点

            head = head.next;
            if (head == null){// 链表仅有这一个元素
                end = null;
            } else {// 链表不仅有一个元素
                head.pre = null;
            }
            size--;
            return true;
        }

        // 一定意味着: 删除的不是头结点

        // 找出要删除的非头结点
        Node mid = head;
        while (mid.next != null && !mid.next.value.equals(str)){
            mid = mid.next;
        }

        // 代码运行到这一步: 意味着上述循环有两种跳出条件
        // mid.next == null  --> 没找到
        // mid.next.value.equals(str) --> 找到了

        if (mid.next == null) return false;

        // 找到了
        // mid.next 是要删除的元素
        Node removeNode = mid.next;

        // 删除removeNode

        if (removeNode.next == null){ // 如果删除的是最后一个元素
            end = removeNode.pre;
            end.next = null;

        }else {// 删除的是中间元素

            // 让删除元素之后的元素前驱指向要删除元素的前驱
            removeNode.next.pre = removeNode.pre;
            removeNode.pre.next = removeNode.next;
        }

        size--;
        return true;
    }

    public boolean contains(String str){
        if (str == null) throw new IllegalArgumentException("str is null");
        if (isEmpty()) throw new RuntimeException("linked is null");

        Node mid = head;
        while (mid != null  && !mid.value.equals(str)){
            mid = mid.next;
        }
        // mid == null
        // mid.value.equals(str)
        if (mid == null){
            return false;
        }else {
            return true;
        }
    }
//
//    public boolean set(String oldValue, String newValue){
//
//    }
//
    public boolean add(int index, String str){
        if (str == null) throw new IllegalArgumentException("str is null");
        if (index < 0 || index > size) throw new IllegalArgumentException("index is Illegal");


        //如果添加的是头结点位置
        if (index == 0){
            // 先判断链表是否为空
            if (head == null || size == 0){// 原本链表为空
                head = new Node(null, str, null);
                end = head;
            }else {// 原本链表不空
                Node node = new Node(null, str, head);
                head.pre = node;
                head = node;
            }
            size++;
            return true;
        }

        // 如果添加的不是头位置
        if (index == size){// 如果添加的尾部, 调用另外一个尾部添加方法处理
            return  add(str);
        }

        // 代表着: 添加的是中间的某个位置
        // index
        Node mid = head;
        if (index < size/2){// 靠近头部
            mid = head;
            int tag = 1;
            while (tag != index){
                mid = mid.next;
                tag++;
            }
            // mid要添加位置的前一个位置

        } else {// 靠近尾部
            mid = end;
            int tag = size;
            while (tag != index){
                mid = mid.pre;
                tag--;
            }
            // mid要添加位置的前一个位置
        }

        // 把新元素, 添加到mid之后
        Node node = new Node(mid, str, mid.next);

        mid.next.pre = node;
        mid.next = node;
        size++;

        return true;
    }

    public String remove(int index){
        // 参数效验
        if (isEmpty()) throw new RuntimeException("linked is null");
        if (index < 0 || index >= size) throw new IllegalArgumentException("index is Illegal");


        // 删除的是头结点
        if (index == 0){
            // 如果删除的是头结点, 先判断删除的结点是不是就是唯一的一个结点
            String oldValue = head.value;
            if (size == 1){// 唯一结点
                head = null;
                end = null;
            }else {// 链表中结点超过1个
                head = head.next;
                head.pre = null;
            }
            size--;
            return oldValue;
        }

        if (index == size-1){// 如果删除的是尾结点
            String oldValue  = end.value;
            end = end.pre;
            end.next = null;
            size--;
            return oldValue;
        }


        // 删除的普通情况:
        // index 更靠近那边
        Node mid = head;
        if (index < size/2){// 靠近头部
            mid = head;
            int tag = 1;
            while (tag != index){
                mid = mid.next;
                tag++;
            }
            // mid要添加位置的前一个位置

        } else {// 靠近尾部
            mid = end;
            int tag = size;
            while (tag != index){
                mid = mid.pre;
                tag--;
            }
            // mid要添加位置的前一个位置
        }
        // mid 就是要删除元素的前一个结点

        // 要删除的结点
        Node removeNode = mid.next;
        String oldValue = removeNode.value;

        removeNode.next.pre = removeNode.pre;
        removeNode.pre.next = removeNode.next;
        size--;

        return oldValue;
    }

//    public String get(int index){
//
//    }
//
//
//    public String set(int index, String newValue){
//
//    }

    // 返回链表存储的元素
    public int size(){
        return size;
    }

    // 判断链表是否为空
    public boolean isEmpty(){
        return size == 0;
    }

    @Override
    public String toString() {
        return "MyLinked{" +
                "head=" + head +
                '}';
    }

    class Node{
        Node pre;
        String value;
        Node next;
        public Node(Node pre, String value, Node next) {
            this.pre = pre;
            this.value = value;
            this.next = next;
        }

        @Override
        public String toString() {
            return "Node{" +
                    "value='" + value + '\'' +
                    ", next=" + next +
                    '}';
        }
    }
}
```

```java
自己练练
/**
add(String);add(int,String);remove(String);contains(String);get(int);set(int,String);isEmpty();getSize().
 */
public class DBdemo {
    public static void main(String[] args) {
        DBnodeList list = new DBnodeList();
        list.add("zs");
        list.add("ls");
        list.add("ww");
        list.add("zl");
        System.out.println(list);
        System.out.println(list.get(0));
        list.set(3, "天");
        System.out.println(list);
        list.remove("天");
        System.out.println(list);
        System.out.println("contains 天 " + list.contains("天"));
        System.out.println("contains zs " + list.contains("zs"));
        list.add(0, "景");
        System.out.println(list);
        list.add(3, "风");
        System.out.println(list);
        list.remove(4);
        System.out.println(list);

    }
}

class DBnodeList {//我的双向链表集合
    private Dnode head;
    private Dnode end;
    private int size;

    //尾部添加元素
    public boolean add(String value) {
        if (value == null) throw new IllegalArgumentException("非法参数，试图传入null");//不允许null元素
        if (isEmpty()) {//集合内容为空
            head = new Dnode(null, value, null);
            end = head;
            size++;
            return true;
        }
        //集合只有一个元素的情况,不需要这么判断，直接尾接就行了
        Dnode newNode = new Dnode(end, value, null);
        end.next = newNode;
        end = newNode;
        size++;
        return true;
    }
    //按照下标添加元素
    public boolean add(int index, String value) {
        if (value == null) throw new IllegalArgumentException("非法参数，试图传入null");//不允许null元素
        if (index < 0 || index > size) throw new IllegalArgumentException("下标越界，非法 index = " + index);//参数校验
        if(isEmpty()) {//如果集合内容为空
            head = end = new Dnode(null, value, null);
            size++;
            return true;
        }
        if(index == size) {//如果插入尾部
            return add(value);
        }
        //头部以后插入
        Dnode mid = getNodeAtIndex(index);
        if(mid == head) {//如果是插入头部,如果只有一个元素那么一定会进入头部的
            Dnode newNode = new Dnode(null, value, head);
            head.pre = newNode;
            head = newNode;
        } else {//不是头部的话肯定不只有一个元素
            Dnode newNode = new Dnode(mid.pre, value, mid);
            mid.pre.next = newNode;
            mid.pre = newNode;
        }
        size++;
        return true;
    }

    //按值删除元素
    public boolean remove(String value) {
        if (value == null) throw new IllegalArgumentException("非法参数，试图传入null");//不允许null元素
        if(isEmpty()) throw new RuntimeException("集合内容为空");
        Dnode mid = getNodeByValue(value);//按值寻找
        if(mid == null) {//说明遍历到尾巴也没找到匹配的
            return false;
        }
        //如果是头
        if(mid == head) {
            head = head.next;
            if(size == 1) {//如果集合只有一个元素
                end = head;
            } else {//集合不只有一个元素
                head.pre = null;
            }
            size--;
            return true;
        }
        //如果是头部以后
        if(mid == end){//如果是尾巴
            end = end.pre;
            end.next = null;
        } else  {//不是尾巴的话
            mid.next.pre = mid.pre;
            mid.pre.next = mid.next;
        }
        size--;
        return true;
    }
    //按照下标删除
    public String remove(int index) {
        if (index < 0 || index >= size) throw new IllegalArgumentException("下标越界，非法 index = " + index);//参数校验
        String oldValue = null;
        Dnode mid = getNodeAtIndex(index);//获取该下标节点
        if(size == 1) {//如果只有一个元素
            oldValue = head.value;
            head = end = null;
            size--;
            return oldValue;
        }
        //不知一个元素的话
        if(mid == head) {//如果是头部
            oldValue = head.value;
            head = head.next;
            head.pre = null;
        } else if(mid == end) {//如果是尾巴
            oldValue = end.value;
            end = end.pre;
            end.next = null;
        } else {//如果是中间部分
            oldValue = mid.value;
            mid.pre.next = mid.next;
            mid.next.pre = mid.pre;
        }
        size--;
        return oldValue;
    }

    //集合是否包含值为参数的元素
    public boolean contains(String value) {
        if(isEmpty() || value == null) return false;//逻辑是非法参数不包含，集合内容空不包含任何
        return getNodeByValue(value) != null;//找的返回true找不到返回false
    }
    //按照下标获取元素
    public String get(int index) {//第一条校验也能判处集合内容为空的情况。
        if (index < 0 || index >= size) throw new IllegalArgumentException("下标越界，非法 index = " + index);//参数校验
        Dnode mid = getNodeAtIndex(index);
        return mid.value;
    }
    //按照下标设置元素的值
    public String set(int index, String newValue) {
        if (index < 0 || index >= size) throw new IllegalArgumentException("下标越界，非法 index = " + index);//参数校验
        if (newValue == null) throw new IllegalArgumentException("非法参数，试图传入null");//不允许null元素
        Dnode mid = getNodeAtIndex(index);
        String oldVale = mid.value;
        mid.value = newValue;
        return oldVale;
    }
    //按照值寻找节点
    private Dnode getNodeByValue(String value) {
        Dnode mid = head;
        if(value.equals(mid.value)){
            return head;
        }
        while (mid.hasNext() && !value.equals(mid.next.value)) {//按名字寻找删除元素位置之前的元素
            mid = mid.next;
        }
        if(!mid.hasNext()) {//说明遍历到尾巴也没找到匹配的
            return null;
        }
        return mid.next;
    }
    //获取给定下标位置的节点
    private Dnode getNodeAtIndex(int index) {
        Dnode mid;
        if (isLeftIndex(index)) {//根据下标偏向左侧或右侧从快的一侧寻找
            mid = head;
            int tag = 0;
            if (tag != index) {
                mid = mid.next;
                tag++;
            }
        } else {
            mid = end;
            int tag = size - 1;
            if (tag != index) {
                mid = mid.pre;
                tag--;
            }
        }
        return mid;
    }

    public boolean isEmpty() {//判断集合内容是否为空
        return size == 0 && head == null;
    }
    public int getSize() {
        return size;
    }
    private boolean isLeftIndex(int index) {//判断下标在偏向左侧还是右侧
        return (index < size / 2) ? true : false;
    }

    @Override
    public String toString() {
        return "DBnodeList{" +
                "head=" + head +
                ", size=" + size +
                '}';
    }
    class Dnode {//我的双向节点
        private Dnode pre;
        private String value;
        private Dnode next;

        public Dnode(Dnode pre, String value, Dnode next) {
            this.pre = pre;
            this.value = value;
            this.next = next;
        }

        public boolean hasNext() {
            return next != null;
        }

        public boolean hasPre() {
            return pre != null;
        }

        @Override
        public String toString() {
            return "{" +
                    "v='" + value + '\'' +
                    ", next=" + next +
                    '}';
        }
    }
}
```



# 泛型

泛型的引入
泛型，即“参数化类型”。顾名思义，就是将类型由原来的具体的类型'参数化'，此时类型也定义成参数形式，然后在使用/调用时传入具体的类型。

> 类型事先不固定, 什么时候使用什么时候告诉具体的类型

泛型的好处
      a. 提高了程序的安全性
      b. 将运行期遇到的问题转移到了编译期
      c. 省去了类型强转的麻烦

> Java1.5在2004年10月发布泛型

```
一个java项目的开发流程
.java  --自己要测试,   -- →  打包(war, jar)  → 放到服务器上(云服务器) 用户  
通过日志检测服务器上的问题: 
|浏览器|===|服务器|===|数据库|
```

## 泛型应用

泛型类
	把泛型定义在类上
	格式:public class 类名<泛型类型1,…>
	注意:参数化类型必须是引用类型

* 注意1: 我们可以在泛型类上, 定义多个泛型类型 比如如下
  class User21<E, T, K, V> {}
  但是, 不要在泛型类上定义过多的泛型 , 常见的1-2个, 不要再多了, 不是不可以(语法上是完全允许的), 但是极少有人这么用

* 注意2:  泛型一般定义格式,常见命名方式
  // T : type（任意类型，需要的时候可以用临近的U和S）
  // E : element
  // K : key
  // V : value

* 注意3:
  Java的泛型 是jdk1.5出现的: 使用泛型的写法
  User<String, Integer> user = new User<String, Integer>();

  在jdk1.7时候, java对使用泛型的写法进行了改进
  User<Integer, String> user2 = new User<>();

* 注意4: 
  如果我们在使用一个泛型类的时候, 不声明泛型, 如下
  User user3 = new User();
  那么, 里面的泛型类型, 会默认是Object类型
* 注意5:
  泛型必须是引用类型
* 注意6: 
  class S<T> extends F<T>{}
  相当于S定义了一个泛型,  那么对于S所继承的F来说, 这个类型就变成了已知的S定义的类型

泛型接口
	把泛型定义在接口上
	格式:public  interface 接口名<泛型类型1…>

泛型方法
	把泛型定义在方法上
	格式:public <泛型类型> 返回类型 方法名(泛型类型 .)



## 泛型的通配

泛型通配符：

> 为了解决模拟类似于数组协变功能而产生的的, 并且它避免了数组协变所带来的的问题(类型问题)
>
> 在java中, 数组是一个非常特殊的存在, jvm底层做了很多适配(不要把数组的情况类比到别的位置)
>
> ```java
> F[] fs = new F[10];
> S[] ss = new S[10];
> fs = ss;//没问题，数组的协变，F[]也可以是Object[]，可以往里添加Object的子类元素或F的子类元素，不报错，但运行时发现和实际数组不一致会报错
> ```

泛型不允许协变

```java
ArrayList<F> fs = new ArrayList<F>();
ArrayList<S> ss = new ArrayList<S>();
fs = ss;// 报错, 泛型不允许协变

class F {}
class S extends F{}
```

① 泛型通配符<?>
	任意类型，如果没有明确，那么就是Object以及任意的Java类了

```java
ArrayList<?> objs =  new ArrayList<S>();
objs =  new ArrayList<F>();//可以
objs =  new ArrayList<Integer>();//可以
//可以接收，但是objs不能add，因为无法知晓实际元素的实力类型
//objs.add(new S());// 报错,
//objs.add(new F());// 报错
//objs.add(new Object());// 报错
```

② ? extends E
	向下限定，E及其子类

```java
ArrayList<? extends F> fs =  new ArrayList<S>();
fs =  new ArrayList<F>();//可以,fs引用能向下接收子类元素的集合
fs =  new ArrayList<Object>();// 报错 因为Object 是f的父类
//同理不能add
fs.add(new F());// 报错,
fs.add(new Object());// 报错,
fs.add(new S());// 报错,
```

③ ? super E
	向上限定，E及其父类

```java
ArrayList<? super F> fs =  new ArrayList<F>();//fs引用何以向上接收F即其父类为的元素的集合
//fs.add(new Object());//报错
fs.add(new F());// 可以
fs.add(new S());// 可以
```

> 总觉的除了向上限定的通配以外毫无用处，向下限定和不限定都是能接收，不能使用添加、修改操作，是我现在还理解不了祖师爷的精妙

> 一个类型变量或通配符可以有多个限定，例如：
>
> T extends Comparable & Serializable
>
> 限定类型用“&”分隔，而逗号用来分隔类型变量。
>
> 在Java的继承中，可以根据需要拥有多个接口超类型，但限定中之多有一个类。如果用一个类左为限定，它必须是限定列表中的第一个。

## 关于自然顺序（泛型通配应用）

Java自然顺序, 就是实现了Comparable的compareTo方法的比较结果, 就是java的自然顺序

```java
// 对于MySet这个类型存储的数据T : 仅要求满足一个条件, 他是Comparable一个子类
public class Demo {
    public static void main(String[] args) {
        //由于泛型通配的限定，User不实现接口就报错
        MySet<User> set = new MySet<>();
    }
}
class MySet<T extends Comparable<T>>{
    public void add(T t){
        // t拿来做比较大小,再存储
    }
}
class User implements Comparable<User>{
    String name;
    String age;
    @Override
    public int compareTo(User o) {
        return 0;
    }
}
```

## 泛型的擦除

在Java 中的泛型, 仅存在于编译之前, 当编译的时候统统会被擦除, 变成Object类型,  并且对泛型使用的代码代码遍历时, 会产生类型强转。

可反编译字节码后查看编译器为我们做的事。

> 原始类型用第一个限定的类型变量来替换，如果没有给定限定就用Object替换。
>
> class Interval<T extends Serializable & Coparable>
>
> Comparable和Serializable谁在前擦除泛型后用谁替换，如用Serializable替换T后，编译器在必要时要向Comparable插入强制类型转换。为了提高效率，应该将标签（tagging）接口（即没有方法的接口）放在边界列表的末尾。



## 实例化类型变量

Java SE 8 之后最好的办法是提供一个构造器表达式，比较老式的方法是通过反射就是有点繁琐

实例化泛型

```Java
//Supplier<T>是一个函数式接口，表示一个无参数而且返回类型为T的函数
import java.util.function.Supplier;
public class Demo {
    public static void main(String[] args) {
        Pair<String> p = Pair.makPair(String::new);
    }
}
class Pair<T> {
    private T first = null;
    private T second = null;

    public static <T> Pair<T> makPair(Supplier<T> constr) {
        return new Pair<>(constr.get(), constr.get());
    }
}
//反射要传入Class<T> cl,用Class.newInstance来构造泛型对象
```

实例化泛型数组

```java
import java.util.function.IntFunction;
public class Demo{
    public static void main(String[] args) {
        String[] strings = Pair.minmax(String[]::new, "hi", "there");
    }
}
class Pair<T> {
    private T first = null;
    private T second = null;

    public static <T extends Comparable<T>> T[] minmax(IntFunction<T[]> constr, T... ts) {
        T[] apply = constr.apply(2);
        ...
        return apply;
    }
}
//反射用Array.newInstance
```

增强for循环(foreach)

增强for概述
简化数组和Collection集合的遍历

格式：

```
for(元素数据类型 变量 : 数组或者Collection集合) {
使用变量即可，该变量就是元素
}
```

好处：简化遍历

注意事项：增强for的目标要判断是否为null

> public interface Iterable<T> 实现这个接口的对象，允许使用foreach循环。

可变长参数

可变参数概述
	定义方法的时候不知道该定义多少个参数，我们就可以使用可变长参数。

格式
	修饰符 返回值类型 方法名(数据类型…  变量名){}
注意：
	这里的变量其实是一个数组
	可变长参数只能位于最后
	一个方法不能有多个可变长参数

Arrays工具类中的一个方法(数组→ 集合)
public static <T> List<T> asList(T... a)

Eg:

```java
String [] strs = {“a”, “b”, “c”};
List<String> list = Arrays.asList(strs);
```

# 数据结构

Java 应用业务逻辑的, 处理数据, 临时存储数据,  → 集合类(在java中批量性的临时存储数据) 

集合类: 数据容器
底层结构: 数组  链表  

数据结构:  集合,  线性表,   树,   // 图（目前没有研究图的精力） 

线性表: 一个有序序列, 除了头尾元素之外每一个元素, 都有唯一的前驱和后继

操作受限的线性表: 栈和队列

## 线性表

逻辑结构

线性表：n个数据元素的有序序列。

首先，线性表中元素的个数是有限的。
其次，线性表中元素是有序的。

那这个”序”指的是什么呢？

如果以ai表示数据元素，则线性表可以记为 {a1, … , ai-1, ai, ai+1, … , an}

表中, ai-1在 ai 之前，同时ai+1 在 ai 之后，我们称ai-1是ai的直接前驱，ai+1是ai的直接后继。

除表头和表尾元素外，其它元素都有唯一前驱和唯一后继，其唯一前驱或唯一后继确定了该元素在线性表中的位置。

因此，线性表中，每个数据元素都有一个确定的位序，这个确定的位序我们称之为索引。

表头元素有唯一后继，无前驱，表尾元素有唯一前驱，无后继。

实现

- 顺序映像 

- 非顺序映像



# 栈

栈是一种”操作受限”的线性表，体现在只能在一端插入删除数据，符合FILO的特性。





栈的实现

栈的API:

- 入栈 (push)：在栈顶添加元素，O(1)

- 出栈 (pop)：从栈顶删除元素，O(1)

- 查看栈顶元素 (peek)：访问栈顶元素但不弹出，O(1)

- 判空 (isEmpty)：判断栈是否为空, 方便遍历，O(1)

实现：

顺序映像(数组：初始化和扩容)

```java
/**
 * 使用数组实现一个栈集合类
 * 数据容器
 * 数组
 * 栈
 */
public class MySatckArray<T> {
    private int MAX_CAPACITY = Integer.MAX_VALUE - 8; // 允许的最大值
    private Object []  arr;
    private int size;
    public MySatckArray() {
        this.arr = new Object[3];//Java集合一般是10或者16,扩容一般是1.5或2倍
    }
    public  MySatckArray(int initCapacity) {
        // 参数检验
        if (initCapacity < 1  || initCapacity > MAX_CAPACITY)throw new IllegalArgumentException("initCapacity is Illegal");
        // 创建一个给定长度的数组
        arr = new Object[initCapacity];
    }
    public boolean push(T t){//压栈
        // 判断数组存储的元素是否已经存满了
        if (arr.length == size){// 数组已经存满了
            int newLen = getLen();// 获取一个新的数组长度
            grow(newLen);// 扩容
        }
        arr[size++] = t;
        return true;
    }
    // 扩容数组 : 旧数组里面存储的内容转移到新数组里面
    private void grow(int newLen) {
        Object [] objs = new Object[newLen];
        for (int i = 0; i < arr.length; i++) {
            objs[i] = arr[i];
        }
  //也可以直接用arr = Arrays.copyOf(this.arr, newlen);
        arr = objs;
    }
    private int getLen() {//扩容长度
        // 获取旧长度
        int oldLen = arr.length;
        //  获取一个新长度
        int newLen = (oldLen * 2);
        if (newLen < 0 || newLen > MAX_CAPACITY){
            newLen = MAX_CAPACITY;
        }//可以直接在最开始判断size==MAX_CAPACITY抛异常
        if (oldLen == newLen) throw new RuntimeException("stack is full");
        return newLen;
    }
    public T pop(){//弹栈
        // 判断栈是否为空
        if (isEmpty()) throw new RuntimeException("stack is empty");
        T oldValue = (T)arr[size - 1];
        size--;
        return oldValue;
        //直接return (T)arr[--size]也行
    }
    public T peek(){//查看栈顶
        // 判断栈是否为空
        if (isEmpty()) throw new RuntimeException("stack is empty");
        return (T)arr[size - 1];
    }
    public boolean isEmpty(){
        return size == 0;
    }
    public int size(){
        return size;
    }
}
```

非顺序映像(链表)

```java
/**
 * 使用链表实现一个栈集合
 * 数据容器
 * 链表
 * 栈
 */
public class MyStackLinked<T> {
    private Node top;
    private int size;
    // 入栈: push
    public boolean push(T value){
        // 不希望存储null值
        if (value == null) return false;
        // 头插法
        top = new Node(value , top);
        size++;
        return true;
    }
    // 出栈: pop
    public T pop(){
        // 先判断有没有元素
        if (isEmpty())throw new RuntimeException("stack is empty");
        T oldValue = top.value;
        top = top.next;
        size--;
        return oldValue;
    }
    // 查看栈顶元素:  peek
    public T peek(){
        // 先判断有没有元素
        if (isEmpty())throw new RuntimeException("stack is empty");
        return top.value;
    }
    public boolean isEmpty(){
        return size == 0;
    }
    public int size(){
        return size;
    }
    class Node{//内部类只用用外围类的泛型
        T value;
        Node next;
        public Node(T value, Node next) {
            this.value = value;
            this.next = next;
        }
    }
}
```

栈列的应用

应用场景：

1. 函数调用栈

2. 反序字符串

   实现reNumber(str)方法,反转字符串

   ```java
   private static String reNumber(String str) {
           MySatckArray<Character> stack = new MySatckArray<>();
           for (int i = 0; i < str.length(); i++) {
               stack.push(str.charAt(i));
           }
           // 上述所有的单个字符已经入栈
           StringBuffer buffer = new StringBuffer();
           while (!stack.isEmpty()){
               Character pop = stack.pop();
               buffer.append(pop);
           }
           return buffer.toString();
       }
   ```

3.   括号匹配问题 
     
     实现judgeBracket(str)方法来判断括号匹配
     
     ```java
     // {}[] ()
         private static boolean judgeBracket(String str) {
             MyStackLinked<Character> stack = new MyStackLinked<>();
             for (int i = 0; i < str.length(); i++) {
                 char c = str.charAt(i);
                 if (c == '{'){
                     stack.push('}');
                 }else if (c == '('){
                     stack.push(')');
                 }else if (c == '['){
                     stack.push(']');
                 } else if (c == ']' || c == '}' || c == ')'){
                     Character pop = stack.pop();
                     if (pop == c){
     
                     }else {
                        // 不相等
                        return false;
                     }
                 }
             }
             return stack.isEmpty();
         }
     ```
     
     
     
4. 编译器利用栈实现表达式求值

   ```
   1, 遇到操作数--> 输出
   2, 遇到右括号 
      让栈元素弹出输出
      直到弹出左括号为止
   3, 遇到操作符
      从栈中弹出元素, 直到遇到栈中更低优先级的操作符
      弹出完成, 该操作符入栈
      如果有右括号, 才弹出左括号
   4, 栈中元素完全弹出
   
   中缀表达式:  1 + 2 * 3 – 72 
   前缀表达式:   - + 123 *72
   后缀表达式:   123 * + 72 *-
   怎么把中缀转化为前缀和后缀? 栈
   ```

   中缀表达式转换成前缀表达式和后缀表达式的极其简单方法

   ```
   a+b*c-(d+e)
   第一步：按照运算符的优先级对所有的运算单位加括号~
           式子变成拉：((a+(b*c))-(d+e))
   第二步：转换前缀与后缀表达式
           前缀：把运算符号移动到对应的括号前面
                 则变成拉：-( +(a *(bc)) +(de))
                 把括号去掉：-+a*bc+de  前缀式子出现
           后缀：把运算符号移动到对应的括号后面
                 则变成拉：((a(bc)* )+ (de)+ )-
                 把括号去掉：abc*+de+-  后缀式子出现
                 
   或者根据中缀表达式画出二叉树，然后根据后序遍历，即可得出后缀表达式，前序遍历即可得出前缀表达式
   ```

   > 后缀表达法，又称为逆波兰（Reverse Polish Notation ,RPN ），在四则混合运算的程序设计中用到

5. 浏览器的前进后退功能

6. 利用栈实现 DFS: depth-first-search  深度优先遍历



# 队列

队列也是一种”操作受限”的线性表，体现在一端插入数据在另一端删除数据，特性是FIFO。



> 在java阻塞队列用的还是相对而言(Stack) 还是比较常用的, 一般都处于一些代码/第三方插件的底层代码

队列的实现

队列的API:

- 入队 (enqueue)：在队尾添加元素，O(1)

- 出队 (dequeue)：从队头删除元素，O(1)

- 判空 (isEmpty)：判断队列是否为空，方便遍历，O(1)

- 长度(size)

- 查看队头元素(peek)


实现：

- 顺序映像

  ```java
  /**
   *  实现一个队列
   *  集合类: 数据容器
   *  数组
   *  队列
   */
  public class MyQueueArray<T> {
      private int MAX_CAPACITY = Integer.MAX_VALUE - 8;
      private Object[] arr;// 队列所持有的底层数组
      private  int size;// 元素数量
  
      private int head;// 队头标记
      private int end;// 队尾标记
  
      public MyQueueArray(){
          arr = new Object[10];
      }
      public MyQueueArray(int initCapacity){
          if (initCapacity < 1 || initCapacity > MAX_CAPACITY)throw new IllegalArgumentException("initCapacity = "+ initCapacity);
          arr = new Object[initCapacity];
      }
      // 入队列: offer
      public boolean offer(T t){
          // 判断数组是否是满的
          if (size == arr.length){
              int newLen = getLen();
              grow(newLen);
          }
          // 可以存储
         if (isEmpty()){
  
         }else {
             end = (end + 1) % arr.length;//这里就不能堆size取余，走到者size就不等于arr.length，而且无论如何都不能用size取模
         }
  
          arr[end] = t;
          size++;
  
          return true;
      }
      private void grow(int newLen) {
          Object[] objects = new Object[newLen];
  		//这时size还==arr.length
          // 把旧数组元素中的内容转移到新数组
          for (int i = 0; i < arr.length; i++) {
              int index = (head + i) % arr.length;
              objects[i] = arr[index];
          }
          //TODO: 除了把新数组, 赋值给arr, 还要转移头和尾的标记
          arr = objects;//这之后size != arr.length
          head = 0;
          end = size - 1;
      }
      private int getLen() {//这时size == arr.length
          // 获取旧长度
          int oldLen = arr.length;
          //  获取一个新长度
          int newLen = (oldLen * 2);
          if (newLen < 0 || newLen > MAX_CAPACITY){
              newLen = MAX_CAPACITY;
          }
          if (oldLen == newLen) throw new RuntimeException("stack is full");
  
          return newLen;
      }
      // 出队列: poll
      public T poll(){
          if (isEmpty()) throw new RuntimeException("queue is empty");
  
          T oldValue = (T)arr[head];
  
          // head 后移1位然后和数组长度取余
          head = (head + 1) % arr.length;
          size--;
  
          if (isEmpty()){// 如果删除的是最后一个元素, 要特殊处理
              head = 0;
              end = 0;
          }
          return oldValue;
      }
      // 查看队头元素方法: peek
      public T peek(){
          if (isEmpty()) throw new RuntimeException("queue is empty");
  
          return (T)arr[head];
      }
      public boolean isEmpty(){
          return size == 0;
      }
      public int size(){
          return size;
      }
  }
  ```

  

- 非顺序映像

- ```java
  /**
   * 用链表来实现一个队列:
   */
  public class MyQueue<E> {
  
      Node  top;// 头结点
      Node end;// 尾结点
      int size;
  
      // offer: 入队列
      // poll: 出队列
      // peek: 查看队头元素
  
      /**
       * 入队列操作
       * @param e 要入队列的元素
       * @return  返回添加是否成功
       */
      public boolean offer(E e){
          // 创建一个新节点
          Node node = new Node(e, null);
  
  
          if (size == 0){// 代表着是一个空链表
              end = node;
              top = node;
              size++;
              return true;
          }
  
          // 让原本链表的尾结点的下一个结点, 指向这个新结点
          end.next = node;
          // 尾结点后移
          end = node;
          size++;
          return true;
      }
  
      /**
       * 出队列操作
       * @return 被出队列的元素
       */
      public E poll(){
          if (size == 0) {// 空链表
              return null;
          }
  
          E oldValue = top.value;
  
          top = top.next;
          // 如果原本链表中仅有一个元素, 删除元素, 需要把头尾结点都置空
          if (size == 1) end = null;
          size--;
          return oldValue;
      }
      /**
       * 队列头元素
       * @return 队列头元素
       */
      public E peek(){
          if (size == 0) {// 空链表
              return null;
          }
          return top.value;
      }
      public boolean isEmpty(){
          return size == 0;
      }
  
      public int size(){
          return size;
      }
      class Node{
          E value;
          Node next;
  
          public Node(E value, Node next) {
              this.value = value;
              this.next = next;
          }
      }
  }
  ```

  

  ```java
  private static final int DEFAULT_CAPACITY = 10;
  private static final int MAX_CAPACITY = Integer.MAX_VALUE - 8;
  // 属性
  private Object[] elements;
  private int size;
  private int front;
  private int rear;
  
  ```

队列的应用

普通队列的应用场景是很有限的，一般在工程中用到的是阻塞队列。

1. 阻塞队列：常用于生产者-消费者模型中。
2. 当队列满的时候，入队列就阻塞。
3. 当队列空的时候，出队列就阻塞。

队列应用场景：

1. 缓存
2. 利用队列实现 BFS:breadth first search 广度优先搜索/ 遍历



# 树

## 概念

与线性表表示的一一对应的线性关系不同，树表示的是数据元素之间更为复杂的非线性关系。

直观来看，树是以分支关系定义的层次结构。树在客观世界中广泛存在，如人类社会的族谱和各种社会组织机构都可以用树的形象来表示。

简单来说，树表示的是1对多的关系。

定义（逻辑结构）：

树(Tree)是n( n>=0 )个结点的有限集合，没有结点的树称为空树，在任意一颗非空树中：

有且仅有一个特定的称为根(root)的结点

当n>1的时，其余结点可分为 m( m>0 ) 个互不相交的有限集T1，T2，..., Tm，其中每一个集合 Ti 本身又是一棵树，并且称之为根的子树。

> 注意：树的定义是一个递归定义，即在树的定义中又用到树的概念。



比如，这颗树，其中A是根，其余结点分成3个互不相交的子集：
T1={B, E, F, K, L}
T2={C, G}
T3={D, H, I, J}
T1, T2, T3 都是 A 的子树，且其本身也是一棵树。

比如T1, 其根为B, 其余结点分为两个互补相交的子集：
T11={E, K, L}
T12={F}
T11和T12都是T1的子树，且其本身也是一棵树。



基本术语

- 一个结点的子树的根，称为该结点的孩子(儿子)，相应的该结点称为子树的根的父亲。

- 没有孩子的结点称为树叶，又叫叶子结点。

- 具有相同父亲的结点互为兄弟。

- 用类似的方法可以定义祖父和孙子的关系。

- 从结点n1 到 nk 的路径定义为节点 n1 n2 … nk 的一个序列，使得对于 1 <= i < k，节点 ni是 ni+1 的父亲。这条路径的长是为该路径上边的条数，即 k-1。从每一个结点到它自己有一条长为 0 的路径。注意，在一棵树中从根到每个结点恰好存在一条路径。

- 如果存在从n1到n2的一条路径，那么n1是n2的一位祖先 ，而n2是n1的一个后裔。如果n1 != n2，那么n1是n2的真祖先, 而n2是n1的真后裔。

> 在一棵树中从根到每个结点恰好存在一条路径：
>
> 如果从n1到n2有一条路径，那么这条路径就是唯一的。

- 结点的层级从根开始定义，根为第一层，根的孩子为第二层。若某结点在第i层，则其孩子就在i+1层。

- 对任意结点ni，ni的深度为从根到ni的唯一路径的长。因此，根的深度为0。

- ni 的高是从ni 到一片树叶的最长路径的长。因此，所有树叶的高都为0。

- 一颗树的高等于它根的高。一颗树的深度等于它最深的树叶的深度; 该深度总是等于这棵树的高。

性质：如果一棵树有n个结点，那么它有n-1条边。
概念： 度，指某个结点孩子的数目。



## 树的实现

实现树的一种方法可以是在每一个结点除数据外还要有一些链，使得该结点的每一个儿子都有一个链指向它。

然而，由于每个结点的儿子数可以变化很大，并且事先不知道，因此，在数据结构中建立到各子结点的直接链接是不可行的，因为这样会产生太多浪费的空间。

实际上解决办法很简单：将每个节点的所有儿子都放在树节点的链表中。

```java
class TreeNode {
    Object element;
    TreeNode firstChile;
    TreeNode nextSibling;
}
```



图中向下的箭头指向firstChild的链，而水平箭头是指向nextSibling的链。因为null链太多了，所以没有把他们画出来。



对普通的树的处理: 

希望它更容易存储, 又不是非常浪费内存空间

1. 把一个结点的第一个孩子, 作为他的left子结点
2. 把一个结点的兄弟结点, 作为这个节点的right结点



如果把一个普通的树转化为二叉树, 它更容易存储, 浪费内存空间情况又不过于严重

二叉树：一个节点最多有两个孩子，并且这两个孩子右严格的左右划分

```java
class TreeNode {
    T t;
    TreeNode left;
    TreeNode right;
}
```



## 树的应用

树的应用很多。用法之一是包括UNIX和DOS在内的许多常用操作系统中的目录结构。

下图是UNIX文件系统中一个典型的目录。



> Unix, Linux： 树
>
> Windows:   森林

# 二叉树

二叉树基础学习

二叉树按层遍历

二叉数专栏

二叉树是一棵树，它的特点是每个结点至多有两棵子树。并且，子树有左右之分，其次序不能颠倒（有序）。

二叉树有以下5种基本形态：



特殊的二叉树：完全二叉树、满二叉树和完美二叉树



Q1: 完美二叉树既是完全二叉树又是满二叉树？

Q2: 如果一棵树既是完全二叉树又是满二叉树，那么它是完美二叉树？



二叉树具有以下重要性质：

- 二叉树在第i层至多有2i-1个节点 （2的i次方-1）

- 层次为k的二叉树至多有2k-1个节点（2的k次方-1）

- 对任何一颗二叉树T，如果其叶子节点数为n0 , 度为2的节点数为n2，则n0 = n2 + 1

- 具有n个节点的完全二叉树，树的高度为log2n (向下取整)。

- 如果对一颗有n个结点的完全二叉树的结点按层序从1开始编号，则对任意一结点有：
        如果编号i为1，则该结点是二叉树的根;
        如果编号i > 1，则其双亲结点编号为 parent(i) = i/2,			
            若 2i > n 则该结点没有左孩子，否则其左孩子的编号为 2i,
            若 2i + 1 > n 则该结点没有右孩子，否则其右孩子的编号为 2i + 1。

父子关系满足一个特点:  2倍和2倍+1关系

根据这个特性: 可以保证用一个一维数组存储一个二叉树
但是, 要保证, 这个树足够饱满. (一旦产生一个”稀疏树”, 那么用一维数组存储二叉树, 会比较浪费内存空间)

> 稀疏树:  相对概念(相对来说, 层级比较多, 结点相对比较少)

> 通俗的说有环的树就是图，树是一个特殊的图。

## 二叉树的存储结构

顺序映像

二叉树的顺序映像，还是用数组来存储数据元素，那么如何表示数据元素之间的关系呢？

我们可以将一棵树，按照完全二叉树进行编号，将编号为i的元素存储到数组索引为i的地方。



缺点：当树比较稀疏的时候，将极大的浪费内存空间。在最坏的情况下，一棵只有 k 个结点的单支树，却需要一个长度为 2k（2的k次方） 的数组来存储。

> 一般情况，我们只会用顺序映像存储完全二叉树



非顺序映像

二叉树的非顺序映像，是以链表的形式来存储数据元素以及数据元素之间的关系。

```java
class TreeNode {
    TreeNode leftChild;
    Object element;
    TreeNode rightChile;
}
```



链表的形式非常灵活，因此我们一般都采用非顺序映像来实现二叉树。

## 二叉树的遍历

遍历对线性结构来说，是一个容易解决的问题，但是对于二叉树则不然。因为二叉树是一种非线性结构，每个结点都有可能有两颗子树，因而需要寻找一种规律，以便使二叉树上的结点能排列在一个线性队列上，从而便于遍历。

### 深度优先遍历

我们再来回顾一下二叉树的递归定义，可知，二叉树由3部分组成：根，左子树和右子树，因此如果能遍历这三个部分，便是遍历了整个二叉树。

假如以L, D, R分别表示左子树，根结点和右子树，则可能有DLR, LDR, LRD, DRL, RDL, RLD这六种遍历方案。

若限定先左后右，则只有DLR, LDR, LRD 这3种情况，分别称之为先 (根) 序遍历，中(根)序遍历，和后 (根) 序遍历。三者的区别主要在于访问根结点的先后顺序。



### 广度优先遍历

广度优先遍历又叫层级遍历。简单来说，就是从上到下，从左到右依次遍历。



### 二叉树的建树

有些情况下，我们已知的是二叉树的某个或某些遍历序列。我们需要根据这些遍历序列，
构建出一棵”相等”的二叉树，这个过程就叫做二叉树的建树。

Q1: 如果我们只知道前序，中序，后序中的某一种，能否构建出一棵二叉树？如果能，为什么？

能创建一个树, 不能创建一个唯一的树.

Q2:如果我们只知道前序，中序，后序中的某两种，能否构建出一棵二叉树？如果能，为什么？

能不创建一个唯一的树: 看情况(前中, 中后)  前后不可以

前序和后序: 确定根节点是谁

中序: 如果确定根节点在哪, 根节点的左边一定是左子树的结点, 根节点的右边一定是右子树的结点





# BST

详解二叉树（基础与BST）

二叉搜索树

又叫二叉排序树。要求树中的结点可以按照某个规则进行比较。

- 左子树中所有结点的key比根结点的key小，并且左子树也是二叉搜索树。
- 右子树中所有结点的key比根结点的key大，并且右子树也是二叉搜索树。



Q1: BST 能存储null吗？为什么？

Q2: BST 能存储key相同的对象吗？为什么？如果不能，可以改进吗？

#1：可以在结点添加一个count属性。

#2:  拉链法, 在结点添加一个next指针域。

#3  左子树 <= (右子树 >=)



实现

- 查找：先取根结点，如果它等于我们要查找的数就返回；如果查找的数据比根节点小，就在左子树中递归查找；如果要查找的数据比根结点大，那么就在右子树中递归查找。

- 插入：如果要插入的数据比结点大，并且结点的右子树为空，就将新数据直接插到右孩子的位置；如果不为空，就再递归遍历右子树，查找插入位置。同理，如果要插入的数据比结点小，并且结点的左子树为空，就将新数据插入到左孩子的位置；如果不为空，就再递归遍历左子树，查找插入位置。

- 删除：分三种情况处理

  a. 如果要删除结点没有孩子，那么直接将该结点删除就行了。

  b. 如果要删除结点只有一个孩子，那么需要就父亲结点对应的指针，指向孩子结点。

   c. 如果要删除结点有两个孩子，那么我们可以找到这个结点的右子树中最小结点 (或者左子树中最大结点)，把它替换到要删除的结点上，然后再删除掉这个最小结点。

Q：查找，插入和删除操作的时间复杂度分别是多少？O(h)

Q：普通的BST最终都会倾斜，我们能否对其改进，实现自平衡的BST？

自平衡的二叉搜索树：
    avl (任意一个结点，左子树和右子树的高度之差不超过1)
    红黑树 (树的高度是log(n))

> 不要轻易使用递归
>
> 不要轻易使用递归
>
> 一定要用的话，做项目: 跑一下: 数据量提上来, 测一下内存会拉升到多少.

## 代码实现二叉搜索树

```java
import java.util.*;
/**实现一个二叉搜索树: left 小, right 大
 * 链表:
 * 二叉搜索树:
 * 集合类:
 * 要求存储的元素实现自然顺序, 因为存储的元素要比较大小
 */
public class BSTdemo {
    public static void main(String[] args) {
        MyBSTree<Integer> bst = new MyBSTree<>();
        bst.add(1);
        bst.add(100);
        bst.add(-100);
        bst.add(50);
        bst.add(-10);
        bst.add(-50);
        bst.add(-150);
        bst.add(150);
        bst.add(200);
        bst.add(170);
        //1, -100, -150, -10, -50, 100, 50, 150, 200, 170
        List<Integer> listPreOrder = bst.preOrderStack();
        System.out.println(listPreOrder);
        //-150, -100, -50, -10, 1, 50, 100, 150, 170, 200
        List<Integer> listInOrder = bst.inOrderRecursion();//中根 递归
        System.out.println(listInOrder);
        //-150, -50, -10, -100, 50, 170, 200, 150, 100, 1
        List<Integer> listPostOrder = bst.postOrderStack();//后根 栈
        System.out.println(listPostOrder);
        //-150, -50, -10, -100, 50, 170, 200, 150, 100, 1
        List<Integer> listGoodPostOrder = bst.goodPostOrderStack();
        System.out.println(listGoodPostOrder);
        //1, -100, 100, -150, -10, 50, 150, -50, 200, 170
        List<Integer> levelOrder = bst.levelOrderQueue();//层级遍历
        System.out.println(levelOrder);
    }
}
class MyBSTree<T extends Comparable<T>> {
    private Node root;
    private int size;
    // 递归实现添加方法
    public boolean addByRecursion(T t) {
        if (t == null) throw new IllegalArgumentException("Illegal args : null");
        int oldSize = size;
        root = addByRecursion(root, t);// 递归添加
        return oldSize < size;
    }
    private Node addByRecursion(Node root, T t) {
        if (root == null) {// 出口
            size++;
            return new Node(t, null, null);
        }
        // root不是null , 比较t 和 root 存储的值是否相等
        int compare = t.compareTo(root.value);
        if (compare > 0) {// t 大 交给root的right子树处理(添加)
            addByRecursion(root.right, t);
        } else if (compare < 0) {// t 小 交给root的left子树处理(添加)
            addByRecursion(root.left, t);
        } else {
            return root;// 相等, 重复值
        }
        return root;
    }
    // 递归实现删除方法
    public boolean removeByRecursion(T t) {
        if (t == null) throw new IllegalArgumentException("Illegal args : null");//bst不存null
        if (isEmpty()) throw new RuntimeException("BSTree is empty");//空树警告
        int oldSize = size;
        root = removeByRecursion(root, t);
        return oldSize > size;
    }
    private Node removeByRecursion(Node root, T t) {
        if (root == null) return null;//出口之一，不存在要删除的元素。

        int compare = t.compareTo(root.value);
        if (compare > 0) {
            root.right = removeByRecursion(root.right, t);
        } else if (compare < 0) {
            root.left = removeByRecursion(root.left, t);
        } else {
            // 相等 , 删除的就是这个root
            if (root.hasLeft() && root.hasRight()) {//root是双分支结点 先替换再删除
                Node mid = root.right;
                while (mid != null) {
                    mid = mid.left;
                }
                root.value = mid.value;
                root.right = removeByRecursion(root.right, mid.value);
            } else {// root是单分支或者叶子结点
                Node ch = root.hasLeft() ? root.left : root.right;
                size--;
                return ch;
            }
        }
        return root;
    }
    //添加结点
    public boolean add(T t) {
        if(t == null) throw new IllegalArgumentException("Illegal args : null");//不存null，没法比较大小
        if(isEmpty()) {//空树情况
            root = new Node(t, null, null);
            size++;
            return true;
        }
        //到这里一定不是空树
        Node mid = root;// 用来标记要查找的位置
        Node midFa = null;// 遍历结点的父节点
        int compare = 0;
        // 让存储的值, 和当前遍历的位置的值, 比较大小
        // 如果t结果大, t在mid 的 right
        // 如果t的结果小, t在mid的left
        while (mid != null) {
            compare = t.compareTo(mid.value);
            if (compare > 0) {
                midFa = mid;
                mid = mid.right;
            } else if (compare < 0) {
                midFa = mid;
                mid = mid.left;
            } else {
                // t = mid.value
                // 相等怎么处理
                // 理论:
                // 1, 拉链法:该节点成为一串飘起的链子
                // 2, 计数法：该节点多了个计数属性表示重复的数量
                // 3, 修整的BST: 如果又添加了一个重复元素, 直接添加到left 或者right子树上
                // 实际操作: 不能存储重复值: (重复, 自然顺序一样)
                return false;
            }
        }
        //找到了，midFa为添加节点的父结点
        Node newNode = new Node(t, null, null);
        if (compare > 0) {
            midFa.right = newNode;
        } else {
            midFa.left = newNode;
        }
        size++;
        return true;
    }
    public boolean remove(T t) {
        if (t == null) throw new IllegalArgumentException("Illegal args : null");//bst不存null
        if (isEmpty()) throw new RuntimeException("BSTree is empty");//空树警告
        // 流程
        // 1, 先找到要删除的结点
        // 2, 判断这个要删除的结点是不是双分支结点
        //       如果是双分支结点, 转化为(替换再删除) 删除叶子或者单分支
        // 3, 删除叶子或者单分支
        //    (要么本来删除的元素就是叶子或者单分支,  要么是经过转化的叶子或者单分支)

        // 找到这个要删除的结点
        Node mid = root;//记录遍历结点(最终标记道要删除的结点)
        Node midFa = null;// (最终要标记到要删除结点的父结点)
        while (mid != null) {
            int compare = t.compareTo(mid.value);
            if (compare > 0) {
                midFa = mid;
                mid = midFa.right;// t在mid的right上
            } else if (compare < 0) {
                midFa = mid;
                mid = mid.left;// t在mid的left上
            } else {
                break;//找到
            }
        }
        // 上述循环有两个条件可以跳出: 找到和没找到
        if (mid == null) return false; // 这个树中就没有这个要删除的元素(没找到)
        // 找到了
        // mid 要删除的结点
        // midF 要删除结点的父结点

        // 判断要删除的结点是不是双分支结点(如果是, 要替换)
        if (mid.hasLeft() & mid.hasRight()) {
            Node min = mid.right;
            Node minFa = mid;
            while (min.hasLeft()) {
                minFa = min;
                min = min.left;
            }
            mid.value = min.value;//被删出结点被右子树最小值替换
            mid = min; // 重新标记要删除的结点
            midFa = minFa;
        }
        // 删除叶子 or 单分支
        // 获得叶子或者单分支的子节点
        Node ch = (mid.hasLeft()) ? mid.left : mid.right;//替代品
        //特殊情况：如果删除的是根 且是单分支
        if (midFa == null) {
            root = ch;
            size--;
            return true;
        }
        // 查看删除的结点是其父节点的那个子结点
        if (mid == midFa.left) {
            midFa.left = ch;
        } else {
            midFa.right = ch;
        }
        size--;
        return true;
    }
    public boolean contains(T t) {
        if (t == null) throw new IllegalArgumentException("Illegal args : null");
        if (isEmpty()) throw new RuntimeException("BSTree is empty");
        // 查找
        Node mid = root;
        if (mid != null) {
            int compare = t.compareTo(mid.value);
            if (compare > 0) {
                mid = mid.right;
            } else if (compare < 0) {
                mid = mid.left;
            } else {
                return true;//相等 包含
            }
        }
        // 到这一步: mid = null --> 没找到
        return false;
    }
    // 用栈实现先序遍历
    public List<T> preOrderStack() {
        ArrayList<T> list = new ArrayList<>();
        Stack<Node> stack = new Stack<>();
        // 1, 根节点先入栈
        stack.push(root);
        // 2, 循环
        while (!stack.isEmpty()) {
            Node pop = stack.pop();//先弹出先添加到列表
            list.add(pop.value);
            // 出栈一个元素, 遍历
            if(pop.hasRight()) stack.push(pop.right);//先右进栈底部
            if(pop.hasLeft()) stack.push(pop.left);//再左进栈顶部，因为左要先输出
        }
        return list;
    }
    // 用递归实现先序遍历: 根, 左子树,  右子树
    public List<T> preOrderRecursion() {
        ArrayList<T> list = new ArrayList<>();
        preOrderRecursion(root, list);
        return list;
    }
    private void preOrderRecursion(Node root, List<T> list) {
        if (root == null) return;
        list.add(root.value);// 遍历根
        preOrderRecursion(root.left, list);// 遍历左子树
        preOrderRecursion(root.right, list);// 遍历右子树
    }
    // 中序遍历: 栈
    public List<T> inOrderStack() {
        ArrayList<T> list = new ArrayList<>();
        Stack<Node> stack = new Stack<>();
        // 1, 定一个中间结点, 赋值根节点
        Node mid = root;
        // 栈中元素 :
        // mid标记:

        // -150  -100  -50  -10 1  50  100  150  170 200
        // 大循环
        while (!stack.isEmpty() || mid != null) {
            // 小循环: 入栈left序列
            while (mid != null) {
                stack.push(mid);
                mid = mid.left;
            }
            // 出栈, 遍历
            Node pop = stack.pop();
            list.add(pop.value);
            // 标记转移到出栈遍历元素的right
            mid = pop.right;
        }
        return list;
    }
    //中序遍历递归方法
    public List<T> inOrderRecursion() {
        ArrayList<T> list = new ArrayList<>();
        inorderRecursion(this.root, list);
        return list;
    }
    private void inorderRecursion(Node root, List<T> list) {
        if(root == null) return;
        if(root.hasLeft()) inorderRecursion(root.left, list);
        list.add(root.value);
        if(root.hasRight()) inorderRecursion(root.right, list);
    }
    //我的愚蠢的后序栈遍历方法栈实现, 和先序极类似(头插)
    public List<T> postOrderStack() {//弹出根留下小弟才不会导致死循环，用标记的办法死循环我破解不了
        ArrayList<T> list = new ArrayList<>();
        Stack<Node> stackTemp = new Stack<>();
        Stack<Node> stack = new Stack<>();
        stack.push(root);
        while (!stack.isEmpty()) {
            Node pop = stack.pop();//先头
            stackTemp.push(pop);//利用栈的特性先头，再右，再左，倒叙进栈，出栈就是顺序了
            if(pop.hasLeft()) stack.push(pop.left);//再左
            if(pop.hasRight()) stack.push(pop.right);//再右，这样右会先弹出
        }
        while (!stackTemp.isEmpty()) {
            list.add(stackTemp.pop().value);
        }
        return list;
    }
    //参考代码，优秀的后续遍历用栈实现，是我想太多
    public List<T> goodPostOrderStack() {
        ArrayList<T> list = new ArrayList<>();
        Stack<Node> stack = new Stack<>();
        stack.push(root);
        while (!stack.isEmpty()) {
            Node pop = stack.pop();//先头
            list.add(0, pop.value);//一直从头插入，效果是到过来，没必要用两个栈了
            if(pop.hasLeft()) stack.push(pop.left);//再左
            if(pop.hasRight()) stack.push(pop.right);//再右，这样右会先弹出
        }
        return list;
    }
    //后续遍历，递归实现
    public List<T> postOrderRecursion() {
        ArrayList<T> list = new ArrayList<>();
        postOrderRecursion(root, list);
        return list;
    }
    private void postOrderRecursion(Node root, List<T> list) {
        if (root == null) return;
        postOrderRecursion(root.left, list);
        postOrderRecursion(root.right, list);
        list.add(root.value);
    }
    //  层级遍历: 广度遍历, 广度优先搜索Broad First Search
    public List<T> levelOrderQueue() {
        ArrayList<T> list = new ArrayList<>();
        ArrayDeque<Node> queue = new ArrayDeque<>();
        queue.offer(root);//让根先入队列
        while (!queue.isEmpty()) {
            Node poll = queue.poll();
            list.add(poll.value);//出列就赶紧把孩子节点都顺序入队列，最后的效果就是一层一层的排队了
            if (poll.hasLeft()) queue.offer(poll.left);//先左
            if (poll.hasRight()) queue.offer(poll.right);//后右进队列
        }
        return list;
    }
    // 中序:  -150  -100  -50  -10  1  50  100  150  170  200
    // 后序:  -150  -50  -10  -100  50  170  200  150  100  1
    //根据中序和后序建树
    public void buildTree(List<T> inOrder, List<T> postOrder) {
        root = recursionBuildTree(inOrder, postOrder);//递归建树
        size = inOrder.size();
    }
    //递归，根据中序和后序建树
    private Node recursionBuildTree(List<T> inOrder, List<T> postOrder) {
        // 出口
        if (inOrder.size() == 0) return null;
        if (inOrder.size() == 1) return new Node(inOrder.get(0), null, null);
        // 在后序中找到根节点
        T rootValue = postOrder.get(postOrder.size() - 1);
        // 根节点在中序的下标
        int rootIndex = inOrder.indexOf(rootValue);
        // 根据根节点在中序进行左右子树划分

        // 左子树中序:  0 ~ index -1
        // 左子树后序: 0 ~ index -1
        // 右子树的中序: index + 1 ~ size -1
        // 右子树的后序: index ~ size -2

        // subList切割方法: 包左不包右
        List<T> leftInOrder = inOrder.subList(0, rootIndex);
        List<T> leftPostOrder = postOrder.subList(0, rootIndex);

        List<T> rightInOrder = inOrder.subList(rootIndex + 1, inOrder.size());
        List<T> rightPostOrder = postOrder.subList(rootIndex, postOrder.size() - 1);

        Node rootNode = new Node(rootValue, null, null);
        rootNode.left = recursionBuildTree(leftInOrder, leftPostOrder);
        rootNode.right = recursionBuildTree(rightInOrder, rightPostOrder);
        return rootNode;
    }
    // 求一个二叉树的高度
    public int getHeight() {
        //参数检查
        if (isEmpty()) return -1;
        return  getHeight(root);
    }
    private int getHeight(Node node) {
        if (node == null) return -1;//递归到空已经在叶子结点以下-1层了，返回-1；叶子结点是0
        int leftHeight = getHeight(node.left);
        int rightHeight = getHeight(node.right);
        int maxChildHeight = (leftHeight > rightHeight) ? leftHeight : rightHeight;
        return maxChildHeight + 1;//当前结点高度是最大孩子高度+1
    }
    public int size() {
        return size;
    }
    public boolean isEmpty() {
        return size == 0;
    }
    class Node {
        private  T value;
        private  Node left;
        private Node right;
        public Node(T value, Node left, Node right) {
            this.value = value;
            this.left = left;
            this.right = right;
        }
        public boolean hasLeft() {
            return left != null;
        }
        public boolean hasRight() {
            return right != null;
        }
    }
}
```



# 2-3-4树

在普通的二叉查找树上进行了扩展，它允许有多个键(1~3个)
树保持完美平衡

完美平衡？根到每个叶子结点的路径都是一样长。



学红黑树之前，先谈谈2-3-4树



结点类型

每个结点可以拥有1, 2, 或者3个键。

- 2-node：1个键，两个孩子
- 3-node：2个键，三个孩子
- 4-node：3个键，四个孩子



特点：动态地添加和删除元素时，能保持树的完美平衡



2-3-4树 —— 查找

查找

- 和当前结点的所有的键进行比较
- 如果当前结点中没有，就找到对应的区间
- 依据链接找到下一个结点 (递归)





2-3-4树 —— 插入

插入

- 查找键应该插入的位置 (树底)





插入

- 查找键应该插入的位置 (树底)
- 2-node：转换成3-node



插入

- 查找键应该插入的位置 (树底)
- 2-node：转换成3-node
- 3-node：转换成4-node



插入

- 查找键应该插入的位置 (树底)
- 2-node：转换成3-node
- 3-node：转换成4-node
- 4-node：咋办呢？





2-3-4树 —— 4结点分裂

我们需要分裂4结点，为新插入的结点腾出空间。



小问题：

如果父节点也是4-node，又该怎么办呢？

- 两种解决方案：
  Bottom-up 自底向上
  Top-down  自顶向下



Top-down: 
确保当前结点不是 4-node，预留空间给新元素。

沿着查找路径向下分裂4-node
在底部插入元素

Case 1: 根结点是 4-node



Case 2: 父节点是2-node



Case 3: 父节点是3-node



不变式：当前结点不是4-node

结果：
     1. 4-node 的父亲不是 4-node。
          2. 到达的叶子结点要么是2-node，要么是3-node。



Note：这些变换都是局部变换，不会影响到无关的其他结点。



局部变换只会影响局部的一些结点。







举个例子







2-3-4树——性能分析

主要性质：2-3-4树是一棵完美平衡的树。



树的高度

- 最坏情况: lg N  [全部是2-node]
- 最好情况: log4N = ½ lg N	[全部是4-node]
- 100万个结点高度在[10, 20]
- 10亿个结点高度在[15, 30]

2-3-4树保证了树的高度为 O(lgN) !



2-3-4树——实现

直接实现？

- 为2-node, 3-node, 4-node 编写不同的结点类
- 不同的结点类之间需要相互转换
- 不好统一不同的case

```java
private void insert(Key key, Val val)
{
    Node x = root;
    while (x.getTheCorrectChild(key) != null)
    {
        x = x.getTheCorrectChild(key);
        if (x.is4Node()) x.split();
    }
    if (x.is2Node()) x.make3Node(key, val);
    else if (x.is3Node()) x.make4Node(key, val);
    return x;
}
```

可以实现，但是代码复杂度太高，我们期待更简单的实现！



# LLRB Trees

Red-black trees

1. 用 BST 来表现 2-3-4 树
2. 用”内部的”红色边来表示 3-node 和 4-node



2-3-4 树能够被表示成 BST，它们之间有一种对应关系！但是它们这种对应不是1-1的。



> 算法导论中关于红黑树的定义：
>
> 一棵红黑树是满足下面红黑性质的二叉搜索树：
>
> 1.每个结点或者是红色的，或者是黑色的
>
> 2.根结点是黑色的
>
> 3.叶结点 (Nil) 是黑色的
>
> 4.如果一个结点是红色的，则它的两个子结点都是黑色的 （4-node 只有一种编码方式）
>
> 5.对每个结点，从该结点到其所有后代叶结点的简单路径上，均包含相同数目的黑色结点。(黑高平衡， 2-3-4树是一个完美平衡的树)

面试问题： 什么是红黑树, 红黑树的特点, 红黑树怎么保证黑高平衡的, 红黑树的核心操作是啥?

二叉 红黑 红不连续 （研究左倾的红黑树）

```
红黑树是一个特殊的二叉树
左倾红黑树

近似的认为红黑树是一个自平衡的二叉搜索树
这个说法不准确，因为确切的说，红黑树是实现，自平衡的二叉搜索树是算法和逻辑。

自平衡的二叉搜索树:  二叉搜索树的一个改进版本, 在二叉搜索树的基础上, 要求任一个结点, 它的左右子树的高度相差不能超过1.  (怎么保证: 手段 → 旋转)

二叉搜索树有哪些缺点: 在不断的添加和删除的过程中, 有可能导致一个二叉搜索树变成稀疏树, 效率降低 
二叉搜索树有哪些优点: 有大小的二叉树.  

```

Left-leaning red-black trees

1. 用 BST 来表现 2-3-4 树
2. 用”内部的”红色边来表示 3-node 和 4-node
3. 3-node 的红色边是左倾的



2-3-4 树能够被表示成 BST，它们之间有一种对应关系！它们这种对应是1-1的！



在普通的BST结点类中添加表示颜色的属性color。

```java
public class BST<Key extends Comparable<Key>, Value>
{
    private static final boolean RED = true;//constant
    private static final boolean BLACK = false;//constant
    private Node root;
    private class Node
    {
        Key key;
        Value val;
      	Node left, right;
        boolean color;//color of incomming link
        Node(Key key, Value val, boolean color)
        {
            this.key = key;
            this.val = val;
            this.color = color;
               
        }
    }
    public Value get(Key key)
    {
        //Search method.
    }
    public void put(Key key, Value val)
    {
        //Insert method.
    }
    //helper method to test node color
    private boolean isRed(Node x)
    {
        if (x == null) return false;//Nil和根视为黑，这里null则是nil
        return x.color == Red;
    }
}
```



LLRB—— 查找

查找

和基本的BST查找代码一模一样。

```java
public Value get(Key key)
{
    Node x = root;
    while (x != null)
    {
        int cmp = key.compartTo(x.key);
        if (cmp ==0) return x.val;
        else if (cmp < 0) x = x.left;
        else if (cmp > 0) x = x.right;
    }
    return null;
}
```





Rotations

不过在讲插入之前，我们来看下基本的树的局部变换——旋转。

```java
private Node rotateLeft(Node h)
{
    Node x = h.right;
    h.right = x.left;
    x.left = h;
    x.color = x.left.color;
    x.left.color = RED;//直接变红的思考见下面
    return x;
}
//这里之所以直接变红而不是先用引用保存原x的颜色再交换，画图想了下是应该不管x原来是什么旋转之后的h都需要直接变红才能保证黑高平衡，因为旋转之后，根到x右子树nil的黑节点数不变，但是根到旋转后的h的nil的路径已经凭空多了一条边，需要让h旋转后无条件变红,而不是想当然的交换。当然仅按照视觉效果来看的话，本来就是在对一条需要调整的红色边进行旋转（目前掌握的知识没听过需要对黑色变进行旋转的），旋转之后也是红色，这么想也没毛病，这样看来，交换也可以，至少因为在选择边做旋转操作时就定了是红边，不会出现交换完多了一条黑边。
```

```java
private Node rotateRight(Node h)
{
    Node x = h.left;
    h.left = x.right;
    x.right = h;
    x.color = x.right.color;
    x.right.color = RED;//这里直接变红的原因我理解的同上左旋一样
    return x;
}
```





在LLRB中，我们需要通过左旋和右旋操作来保证LLRB的性质！

回顾下LLRB的性质

a. 满足查找树的性质
b. 保证黑高平衡



LLRB —— 插入

回顾下 2-3-4 树的插入

- 沿着查找路径，自顶向下分解 4-node，确保当前结点不是 4-node
- 在底部插入新结点

Note: 分解 4-node 的操作都是局部变换。



LLRB 与 2-3-4 树是 1-1 对应的，所以它插入的思路也是一样的。



分裂 4-node，可以通过一个简单的颜色反转来实现。

```java
private Node colorFlip(Node h)
{
    h.color = !h.color;
    h.left.color = !h.left.color;
    h.right.color = !h.right.color;
    return h;
}
```



Note:

- 这也是一个局部变换
- 保持了黑高的平衡
- 将红色链接传递给了父结点
- 相当于在父结点中插入一个新的结点
- 在父结点中插入新结点的情形和在底部插入新结点的情形是一模一样的



我们先来考察在底部插入新结点的情形。

父节点要么是 2-node, 要么是 3-node，总共有 2 + 3 = 5 种情况。



插入新结点，会造成右倾的3-node，和连续的红链接 (不规范的4-node)。我们需要通过旋转操作来更正这些链接。

```
> 对途中连续的红链接有感：
> 把左倾红黑树按照234数去理解的话能想明白，这里插入后的连续红链接听起来只是字面上违背了红黑树的原理，但如果把这整棵红黑树看成234树会发现，末端插入后形成的连续红链接实际上对应的是在234的末端插入时直接插入到Nil了，由于234树本来是完美平衡向上增长的，连续红节点意味着让234树向下涨了一层，就从根本破坏了这棵234树。所以旋转之后的结果其实是把这多出来的一层融入到原来的底层去。每当发生这种情况都这样做，对应的就是保证了234树的永远向上增长。
```

我们再捋一捋LLRB的插入过程：

- 自顶向下，沿查找路径分解4-node
- 在底端添加新结点
- 自底向上，通过旋转操作来更正非法的 3-node 和 4-node (分解4-node 和添加新结点都可能产生)。

更正非法的 3-node 和 4-node 有三种情况，我们统一成两个步骤。

1. 左旋任意的红色右链接。

   

2. 如果有两条连续的左倾红色链接，右旋上面的红色链接

   



```
> 自下而上，每发现一条链接有问题就单独修复，即使是连续的红链接，但都是一条一条执行更正，遇到一个解决一个，相当于身处问题链中不知，却的确分解蚕食了整个问题。
```

```java
//版本1
private Node insert(Node h, Key key, Value val)
{
    if (h == null)//insert at the bottom
        return new Node(key, val, RED);
    //split 4-nodes on the way down
    if (isRed(h.left) && isRed(h.red))
        colorFlip(h);
    //standard BST insert code
    int cmp = key.compareTo(h.key);
    if (cmp == 0) h.val = val;
    else if (cmp < 0)
        h.left = insert(h.left, key, val);
    else
        h.right = insert(h.right, key, val);
    //fix right-leaning reds on the way up
    if (isRed(h.right))
        h = rotateLeft(h);
    //fix two reds in a row on teh way up
    if (isRed(h.left) && isRed(h.left.left))
        h = rotateRight(h);
    
    return h;
}
/**
这版本自上而下遇到4结点就分裂，保证向下递归到目标点时路径上没有4结点，但是插入之后，一边回归一边修复，做了两件事：1是左旋右倾红链接，右旋两条连续左倾红链接的上部。
这并没有什么问题，就算出现两条连续左倾红链接，右旋上半部分，修复之后，不过是出现了4结点，即左右两个红链接，然后在回归上一层。相当于每次插入只有底层插入出有可能出现4结点，但是并不影响目前对红黑树的定义，没说不能有4结点。
当然其实在修复连续左倾红链接之后再把分裂4结点的变色操作执行一遍更好，这样就连底层也没有了4结点，回归的时候如果由于下层变色影响了上层也会再回归的时候修复。逻辑没问题，但同样的代码写两遍，冗余。
其实效果上就是把这个本来对应234树的红黑树变成了23树，因为按照这个逻辑，这棵树上是不会再有4节点了，相应的每次插入向下递归的同时也根本遇不到4结点，则对于4结点分裂的代码就没有必要放到最上面了，而是插入之后修复的最后一种情况来检查修复可能出现的4结点，并一直回归检查。
*/
/**
判断是不是23树条件：
1.右子树不能红，应该分裂
2.左不能连续红
对照上面自下而上修复4结点，实际上就是让这棵树成为了23数。（右红和左连续红都是4结点的显示）
*/
/**
最后的结果的外在表现无疑是棵23树，但本质上是棵没被分裂了4结点的234树。之所以这样说是因为一开是把左倾红黑树对应为234树来梳理，所谓的向上分裂时对应234树的结点满了装不下了才分裂的。但如果一开始就对应为23树，3结点就已经满了，逻辑上遇到就要转化为2结点在做插入，但实际上时直接插入即使变为4结点也直接插入在做修复。即使不修复4结点并不影响黑高平衡。老实说我觉的分裂了4结点严格左倾，就是变好看了，强迫症福音，但是效率上有没有提高呢我感觉逻辑上是没有的。
*/
/**
上面再分析插入过程中说自顶向下遇到4结点分裂，作为234树对应红黑树的引子是没有问题的，更具上面的体会和下面的版本2，其实实际应用中根本就没有这一步，或者说可以有但是没有必要，因为版本二只要插入回归时就会修剪为23树，任何时候递归往下其实时不会遇到4结点的也就没有了多此一举的必要。
*/

//版本2
private Node insert(Node h, Key key, Value val)
{
    if (h == null)//insert at the bottom
        return new Node(key, val, RED);
   
    //standard BST insert code
    int cmp = key.compareTo(h.key);
    if (cmp == 0) h.val = val;//这里的操作我想拒绝，因为外层调用这个递归后是用root.size判断是否添加成功，这里如果做修改动作，是不会改变总size，这是算成功插入了还是没有成功插入呢，就很尴尬，除非在外围类在维护一个标记用于这种情况，这样即使对外提供个replace的方法也能复用这块的代码
    else if (cmp < 0)
        h.left = insert(h.left, key, val);
    else
        h.right = insert(h.right, key, val);
    //fix right-leaning reds on the way up
    if (isRed(h.right))
        h = rotateLeft(h);
    //fix two reds in a row on teh way up
    if (isRed(h.left) && isRed(h.left.left))
        h = rotateRight(h);
    //split 4-nodes on the way up
     if (isRed(h.left) && isRed(h.red))
        colorFlip(h);
    
    return h;
}
```



LLRB —— 删除最大值

在讲一般的删除之前，我们讲讲删除的一种简单情况，删除最大值。

思路：

- 沿着最右边的分支向下查找
- 如果最大结点是3-node, 或者4-node——直接删除 (不影响2-3-4树的完美平衡)



- 如果最大结点是2-node —— 怎么办？



回想一下插入算法是怎么做的。

插入算法为了保证不在4-node中插入新结点，会自顶向下分解4-node，确保当前结点不是4-node, 为新结点预留空间。

同样的，删除最大值算法思路：确保当前结点不是2-node。



当前结点不是根结点





我们再来看看根结点的情况：

1. 根节点不是2-node。与前面分析的一样。
2. 根结点是2-node。





对于 2-3 树而言，删除最大值的策略。

- 不变式: 保证当前结点不是2-node。
- 必要的时候，我们可以引入4-node
- 在最底端删除最大值
- 沿查找路径自底向上fixUp()。

实现：

- 遇到左倾的红色链接，右旋
- 不变式：当前结点不是2-node
- 在最底端删除





1. 右旋红色链接

   

2. 如果右孩子是2-node, 我们需要从它的兄弟结借结点。这有两种情况。

   右孩子是 2-node：h.right AND h.right.left both BLACK 

   // if(!isRed(h.right) && !isRed(h.right.left))

   Case 1: 左孩子是 2-node (h.left.left is BLACK)

   

   Case 2: 左孩子是 3-node (h.left.left is RED)

   
   
   
   
   ```java
   //右孩子是二节点的转化
   private Node moveRedRight(Node h)
   {
       colorFlip(h);//case1
       if (isRed(h.left.left//case2
       {
           h = rotateRight(h);
           colorFlip(h);
       }      
       return h;
   }
   ```
   
   ```java
   //删除后自底向上修复
   private Node fixUp(Node h)
   {
       //rotate-left right-leaning reds
       if (isRed(h.right))
           h = rotateLeft(h);
       //rotate-right red-red pairs
       if (isRed(h.left) isRed(h.left.left))
           h = rotateRight(h);
       //split 4-nodes
       if (isRed(h.left) && isRed(h.right))
           colorFlip(h);
       return h;
   }
   ```
   
   ```java
   //删除最大值
   public void deleteMax()
   {
       root = deleteMax(root);
       root.color = BLACK;
   }
   private Node deleteMax(Node h)
   {
       //lean 3-nodes to the right
       if (isRed(h.left))
           h = rotateRight(h);
       //remove node on bottom level (h must be RED by invariant)此处h右结点为null只有一个情况，h左结点也为null，h左结点为红上一步就转成功了，这步就肯定不是null了，h左结点为黑就不平衡了，当h是根节点容易理解，就算不是根节点坠入了这个递归h肯定是个红结点，h下面右一个为null说明已经跌落到底了，左边还有黑结点nil高度差就超过1了
       if (h.right == null)
           return null;
       //borrow from sibling if neccessary,h.right为2-nades，h.left不一定，moveRedRight(h)方法里会分两种情况处理
       if (!isRed(h.right) && !isRed(h.right.left))
           h = moveRedRight(h);
       //move down one level
       h.right = deleteMax(h.right);
       //fix right-leaning red links and eliminate 4-nodes on the way up
       return fixUp(h);
   }
   ```
   
   



```
> 我理解的为什么h.right AND h.right.left both BLACK就确定h.right是2-node，因为这是左倾红黑树，对应的234树3-node红边是左倾的，意味某一个根节点到其子节点如果只有一条红边那么就一定是左倾的，所以左孩子为黑则对应234树为2-node，再能推断出右孩子为红对应到234树的这个根为4-node，左孩子红有孩子黑对应234树这个根为3-node点。
> 上图来看，最大值反正会在最右边，遇到左倾红链接右旋保证了最大值在底端被删掉不影响黑高平衡。
```

LLRB —— 删除最小值

删除最小值的策略和删除最大值的策略是一致的，只是有些许不同。

- 不变式: 保证当前结点不是2-node。
- 必要的时候，我们可以引入4-node
- 在最底端删除最小值
- 沿查找路径自底向上fixUp()。

实现：

- 不变式：当前结点不是2-node

- 在最底端删除

  



我们讨论的是 2-3 树模型，因此是没有红色的右链接的，故不需要左旋。

如果左孩子是2-node (!h.left.isRed() && !h.left.left.isRed())，
我们需要从兄弟中借结点，这分两种情况。

Case 1: 右孩子是 2-node (h.right.left is BLACK)



Case 2: 右孩子是 3-node (h.right.left is RED)



```java
//左孩子是二节点的转化
private Node moveRedLeft(Node h)
{
    colorFlip(h);//case1
    if (isRed(h.right.left))//case2
    {
        h.right = rotateRight(h.right);
        h = rotateLeft(h);
        colorFlip(h);
    }
    return h;
}
```





```java
//删除最小值
public void deleteMin()
{
    root = deleteMin(root);
    root.color = BLACK;
}
private Node deleteMin(Node h)
{
    //remove node on bottom level (h must be RED by invariant),左为null一定是最左且最小的红结点，因为要么左红要么左黑但左左红，否则递归是不会放行的，左黑左左黑会被转化后放行，走到左为null就是走到头了。不要想左为null能确定是最小的但右边有可能有黑，该黑可能还有子树，放弃吧，想想黑高平衡，这一顿瞎想左边的Nil和右边如果有黑的话其之下的Nil相差都多少了。
    if (h.left == null)
        return null;
    //push red link down if necessary
    if (!isRed(h.left) && !isRed(h.left.left))
        h = moveRedLeft(h);
    //move down one level
    h.left = deleteMin(h.left);
    //fix right-leaning red links and eliminate 4-nades on teh way up
    return fixUp(h);
}
```



LLRB —— 删除

我们先试试用删除最大最小值的思路去删除任意结点。

- 查找要删除的结点
- 如果要删除的结点是3-node或者是4-node，那么直接删除不会影黑高平衡？
- 如果是2-node
  - 自顶向下变换树
  - 保证当前结点不是2-node

问题：如果待删不是叶子结点，是不能直接删除的！
             有太多种情况需要考虑！

像BST一样，其实我们可以将问题转换成deleteMin().

```java
h.key = min(h.right);
h.value = get(h.right, h.key);
h.right = deleteMin(h.right);
```





删除算法的要点：当前结点或者它的孩子结点中的某一个是 RED.

- 查询路径往左: 左孩子不是2-node，moveRedLeft()
- 查询路径往右: 右孩子不是2-node，moveRedRight()
- 在底端删除结点
- fixup()

## TODO 删除存疑：不存在key的出口和连点空指针异常

```java
//删除算法
private Node delete(Node h, Key key)
{
    int cmp = key.compartTo(h.key);
    //LEFT
    if (cmp < 0)
    { //push red left if necessary
        if (!isRed(h.left) && !isRed(h.left.left))
            h = moveRedLeft(h);
        //move down (left)
        h.left = delete(h.left, key);
    }
    else//RIGTH or EQUAL
    {
        //ortate to push red right
        if (isRed(h.left)) = leanRight(h);
        //EQUAL (at bottom) delete node,只有这种情况不会下走了所以判断要加cmp==0，因为完全有可能不存在要删除的即右为null但cmp不为0,这有点问题我没明白，无论是cmp<0还是cmp>=0都没发现不存在可删除元素的出口。h.left.left这种不会空指针异常吗，比如就一个根结点。
        /**但这是LLBR，到这步右边如果为null了那么左边一定是null，我还是没看出来这里有不存在可删除key的出口
        */
        if (cmp == 0 && (h.right == null))
            return null;
        //push red right if necessary
        if (!isRed(h.right) && !isRed(h.right.left))
            h = moveRedRight(h);
        //EQUAL (not at botom)
        if (cmp == 0)
        {
            //replace current node with successor key, value
            h.key = min(h.right);
            h.value = get(h.right, h.key);
            //delete successor
            h.right = deleteMin(h.right);
        }
        else h.right = delete(h.right, key);//move down (right)
    }
    //fix fight-leaning red links and eliminate 4-nodes on the way up
    return fixUp(h);
}
```

## 代码实现左倾红黑树

```java
import java.util.ArrayList;
import java.util.List;

//我的左倾红黑树实现
public class MyLLRBTree<Key extends Comparable<Key>, Value> {
    private static final boolean RED = true;
    private static final boolean BLACK = false;
    private Node root;
//  由于结点都维护了size所以外围类不应该在维护size
    //增
    public boolean put(Key key, Value val) {
        if (key == null) throw new IllegalArgumentException("Illegal args, key = null");
        if (val == null) throw new IllegalArgumentException("Illegal args, val = null");
        int oldSize = size();
        root = insert(root, key, val);
        //TODO: 检查 23树 黑高平衡 ？->要是逻辑都没问题就应该查不出问题，有必要检查吗，这会降低效率。话说真就逻辑出错查出来不平衡里面数据就坏掉了
        check();//检查 23树身份认证 黑高平衡认证
//        root.color = BLACK; //这样完全有可能空指针，黑化树根应抽取为方法
        blackenRoot();//把根黑化，如果能够的话。添加也是需要黑化的，有可能原来size为0，有可能修复回归时把根部变红了
        return oldSize < size();
    }
    private Node insert(Node root,Key key,Value val) {
        if (root == null) {//递归出口
            /*size++; 修复会更新结点size值直到根*/
            return new Node(key, val, null, null, RED, 1);
        }
        int compare = key.compareTo(root.key);
        if (compare > 0) {
            root.right = insert(root.right, key, val);
        } else if (compare < 0) {
            root.left = insert(root.left, key, val);
        } else {
            //相等不允许，因为如果给与修改val值的话size也不会变，不能用size判断是否添加成功了。
            //且对于修改应该是单独的方法提供，不符合add的身份
        }
        return fixUp(root);//边修复边回归
    }
    //删最大，其实删最大和山最小应该不暴露给外界，但是对内部操作很有用
    public void removeMax() {
        checkEmpty();
        root = removeMax(root);
        blackenRoot();//无论如何修正根颜色
    }

    private Node removeMax(Node h) {
        if (isRed(h.left)) {//有的话把做左红链右旋
            h = rotateRight(h);
        }
        if (h.right == null) {//这里不用size--因为修复会更新每个结点的size值直到根
            return null;//一定是最大值，对应h.left必为nil，为黑则黑高不平衡
        }
        if (!isRed(h.right) && !isRed(h.right.left)) {//如果右结点为2-nodes。不要担心h.right.left会报空指针，见removeMin的感想，至少走到这h.right一定存在
            h = moveRedRight(h);//借结点
        }
        h.right = removeMax(h.right);//能走到这经过上面的处理就可以递归下放了
        return fixUp(h);//修复回归，应该是最后一步
    }
    //删最小
    public void removeMin() {
        checkEmpty();
        root = removeMin(root);
        blackenRoot();//黑化根部
    }
    private Node removeMin(Node h) {//调用前查了空，至少第一次进来不会是Null
        //不用想当然的左旋右红链接，因为这是左倾红黑树，初次进来是不会有右红链接的
        if (h.left == null) {
            //这里不用size--因为修复会更新每个结点的size值直到根
            return null;//一定为最小值，对应的h.right必为nil，为黑则黑高不平衡，为红同上不可能
        }
        if (!isRed(h.left) && !isRed(h.left.left)) {//单独判断h.left为2-nodes的情况
            h = moveRedLeft(h);//左边为黑2-nodes就借结点，什么你在想h.left.left可能是null,nil也是黑的呀，至少到这里h.left肯定有。到这里我也才悟了为什么要用个isRed方法判断红黑，就是h.left.left完全可能就是Nil，用h.left.left就会空指针异常
        }
        h.left = removeMin(h.left);//到这里可以放心交给下层，走到这要么h红，要么h.left红
        return fixUp(h);
    }
    //删除 按Key
    public boolean remove(Key key) {
        if (key == null) throw new IllegalArgumentException("Illegal args, key = null");
        checkEmpty();
        int oldSize = size();
        root = remove(root, key);
        blackenRoot();//黑化根部
        return oldSize > size();
    }
    //TODO:参考代码感觉默认为传入的key是已存在的
    private Node remove(Node h, Key key) {//调用处判空了，第一次绝对不是Null
        //想过把找不到情况的Null出口放在这，不在>0或<0的下一行出，但是借结点的判断走到底层就会空指针了，我选择放弃。
        int compare = key.compareTo(h.key);
        if (compare < 0) {
            if (h.left == null) return h;//出口1，即使不存在，就原样返回。TODO:问老师，参考代码找不到绝对出口，找不到的话下一行h.left.left会报空指针
            if (!isRed(h.left) && !isRed(h.left.left)) {//左为2-nodes就给借结点
                h = moveRedLeft(h);
            }
            //这里不需要判断如果借结点成功后新的h.key和key再做比较的结果，借成功意味着h要么只是跌落融合的本来的h,要么是原h.right.left,只会更大，不会变小
            h.left = remove(h.left, key);
        } else {//等于0的情况确实要和小于0或者大于0合并解决，因为如果有不能直接删，要转化为删除最大值或最小值不影响黑高
            //这个代码块中有两个可能的旋转，
            if (isRed(h.left)) {//1号旋转
                h = rotateRight(h);//这里如果有把左红链接右旋，下面h.right不会为null
            }
            //if (key.compareTo(h.key) == 0 && h.right == null) return null; //这么判断有问题，没有了key根本不存在的出口，会导致后面的代码空指针比如h.right.left的判断,如果不存在的key最大，且总会走到h.right==null。参考代码这么写一方面是因为上面有可能旋转了才再次重新比较，但是老实说如果旋转成功，成功后的h只会比原本的h小。
            //按上下两条分析，这里不用重新比较，只有原compare为0且1号旋转不了新的key.compareTo(h.key)才为0
            if (h.right == null) {//找不到应该不改结构原样返回，这是尝试过1号旋转后判定h.right为nil，此时h.left铁定为nil，到头了，compare不相等也没机会了，也要给出口了，而且这个次如果重新比用key.compareTo(h.key) == 0,应该只有等（压根1号旋转没执行）和>0（1号旋转成功，h变为h.left，当前key相应变小了
                //而且如果h.right为nil，说明1号旋转没执行，compare值不变，当前h是终点
                return compare == 0 ? null : h;//出口2，TODO:问老师，参考代码应该是只有找到才能出去，找不到下一行也该是空指针
            }
            if (!isRed(h.right) && !isRed(h.right.left)) {//2号旋转（可能），右为2-nodes就给借结点
                h = moveRedRight(h);
            }
            //如果借成功，h可能是跌落融合的本来的h，也可能是原h.left（h.left.left为红就会上浮顶落原h）。
            //能走到这里两个旋转操作肯定执行了1个，这里就要再重新比较了，上面不重新比较有解释，其实都重新比较也可以。这里compare为0只有一种情况，1不转2仅反转颜色但不转，这种情况老compare和新compare是一样的，但是为了排除转了的情况这里要重新比较，单独处理这种转不动了,不会往下走而是开始替换右子树最小值的情况
            if (key.compareTo(h.key) == 0) {//其实老compare为0没有意义，上面实在h.right=null找到绝对出口的情况下不用多余判断了，这里即使老compare为0也该交给下级递归，其实只要新compare为0老compare是必定为0的，1号和2号都没有转，只是把新compare为0走不下去了就该特殊处理了
                Node successor = min(h.right);
                h.key = successor.key;
                h.val = successor.val;
                h.right = removeMin(h.right);
            } else {
                h.right = remove(h.right, key);
            }
        }
        return fixUp(h);
    }
    //参考思路
    /*private Node remove(Node h, Key key) {
        int compare = key.compareTo(h.key);
        if (compare < 0) {
            if (!isRed(h.left) && !isRed(h.left.left)) {//如上猜想报了空指针，用了小于最小key测试
                h = moveRedLeft(h);
            }
            h.left = remove(h.left, key);
        } else {
            if (isRed(h.left)) {
                h = rotateRight(h);
            }
            if (key.compareTo(h.key) == 0 && h.right == null) {
                return null;
            }
            if (!isRed(h.right) && !isRed(h.right.left)) {//如上猜想报了空指针：用了超过最大key测试
                h = moveRedRight(h);
            }
            if (key.compareTo(h.key) == 0) {
                Node successor = min(h.right);
                h.key = successor.key;
                h.val = successor.val;
                h.right = removeMin(h.right);
            } else {
                h.right = remove(h.right, key);
            }
        }
        return fixUp(h);
    }*/
    //查找 按key
    public Value get(Key key) {
        if (key == null) throw new IllegalArgumentException("Illegal args, key = null");
        checkEmpty();
        Node mid = root;
        while (mid != null) {
            int compare = key.compareTo(mid.key);
            if (compare > 0) {
                mid = mid.right;
            } else if (compare < 0) {
                mid = mid.left;
            } else {
                return mid.val;
            }
        }
        return null;//没有就返回Null
    }
    //查找 按value 不应该有这种方法，不符合树的身份
    private Key get(Value val) {
        if (val == null) throw new IllegalArgumentException("Illegal args, val = null");
        checkEmpty();
        Key k = get(root, val);
        return k;
    }
    private Key get(Node root, Value val){
        if (root == null) return null;
        if (val.equals(root.val)) return root.key;
        Key lk = get(root.left, val);
        if (lk != null) return lk;
        return get(root.right, val);
    }
    //查找 子树最小结点
    private Node min(Node h) {
        while (h.hasLeft()) {
            h = h.left;
        }
        return h;
    }
    //右倾红边左旋
    private Node rotateLeft(Node h) {
        Node x = h.right;
        h.right = x.left;
        x.left = h;
        return updateColorAndSizeAfterRotate((Node) h, (Node) x);
    }
    //左倾红边右旋
    private Node rotateRight(Node h) {
        Node x = h.left;
        h.left = x.right;
        x.right = h;
        return updateColorAndSizeAfterRotate(h, x);
    }
    private Node updateColorAndSizeAfterRotate(Node h, Node x) {
        x.color = h.color;//别忘了要变色
        h.color = RED;
        x.size = h.size;//别忘了要修改结点x的size
        updateSize(h);//别忘了要修改结点h的size
        return x;
    }
    //三色反转 (浮上分裂或跌落融合)
    private Node colorFlip(Node h) {
        h.color = !h.color;
        h.left.color = !h.left.color;
        h.right.color = !h.right.color;
        return h;
    }
    private Node moveRedRight(Node h) {//给右2-nodes借结点
        colorFlip(h);
        if (isRed(h.left.left)) {//如果原来左左是红要多右旋一次
            h = rotateRight(h);
            colorFlip(h);
        }
        return h;
    }
    private Node moveRedLeft(Node h) {
        colorFlip(h);
        if (isRed(h.right.left)) {//如果原来右左是红要先右旋一次h.right再左旋h
            h.right = rotateRight(h.right);
            h = rotateLeft(h);
            colorFlip(h);//反转后没有右倾红链，相当于把原来的右左上浮，原来的h跌落左下融合
        }
        return h;
    }
    //回归修复
    private Node fixUp(Node h) {
        //发现右红边左旋
        if (isRed(h.right)) {
            h = rotateLeft(h);
        }
        //发现连续做红边，先右旋上红边再三色反转
        if (isRed(h.left) && isRed(h.left.left)) {
            h = rotateRight(h);
//            h = colorFlip(h);//逻辑上是要有这一步，但单独放到下面更好
        }
        if (isRed(h.left) && isRed(h.right)) {//分裂放到这里最后检查即可
            h = colorFlip(h);
        }
        h = updateSize(h);//size更新一下
        return h;
    }
    //检查当前树是否为标准LLRB
    private void check() {
        if (isEmpty()) return;//空树不检查
        boolean is23 = is23Tree(root);//判断该树是不是23树(条件: 1,右子不能红:应该分裂 2:左能连续红)
        boolean isBalance = isBalance();//判断该树是不是平衡(获得某一黑叶子节点高, 判断其它叶子是否和这个高相等:通过减减操作)
        if (!is23 || !isBalance) throw new RuntimeException("The current tree is not LLRB tree.");
    }
    private boolean is23Tree(Node h) {//23树认证
        if (h == null) return true;
        if (isRed(h.right)) return false;//过滤了null这里一定不会空指针
        if (isRed(h.left) && isRed(h.left.left)) return false;//这里h.left.left不会空指针，h.left为红一定有left子树,虽然h.left为黑有可能是nil，但不要仅过不了isRed(h.left)这一关的
        boolean leftIs23Tree = is23Tree(h.left);
        boolean rightIs23Tree = is23Tree(h.right);
        return leftIs23Tree && rightIs23Tree;
    }
    private boolean isBalance() {//黑高平衡认证//调用处已经判断了根是否为Null
        //计算根节点的高度
        Node x = root;
        int height = 0;
        while (x != null) {
            if (!isRed(x)) {
                height++;
            }
            x = x.left;
        }
        return isBalance(root, height);
    }

    private boolean isBalance(Node h, int height) {//黑高平衡检查
        if (h == null) return height == 0;//由调用处的计算高度，跌落到这nil是高度为0的
        if (!isRed(h)) {
            height--;
        }
        boolean leftIsBalance = isBalance(h.left, height);//过滤了Null这里以下一定不会空指针
        boolean rightIsBalance = isBalance(h.right, height);
        return leftIsBalance && rightIsBalance;
    }
    public int size() {//因为结点维护了size值，所以不应该在外围类在维护一个size
        return isEmpty() ? 0 : root.size;
    }
    private int sizeOf(Node h) {//因为修复h.size = h.left.size + h.right.size + 1;完全可能空指针
        return h == null ? 0 : h.size;
    }
    public boolean isEmpty() {//外围类没有维护size所以通过root的状况判断
        return root == null;
    }
    private boolean isRed(Node h) {
        if (h == null) return false;//nil默认为黑
        return h.isRed();
    }
    private Node updateSize(Node h) {//h.size = h.left.size + h.right.size + 1;完全可能空指针
        h.size = sizeOf(h.left) + sizeOf(h.right) + 1;//size修正，按目前的逻辑h不会是null，h==null都提前返回了，执行不到修正size
        return h;
    }
    private void checkEmpty() {
        if (isEmpty()) throw new RuntimeException("LLRBTree is empty");
    }
    private void blackenRoot() {//把根黑化，如果能够的话
        if (!isEmpty()) {
            root.color = BLACK;
        }
    }
    public List<Key> preOrder() {//前序遍历
        ArrayList<Key> list = new ArrayList<>();
        preOrder(root, list);
        return list;
    }
    private void preOrder(Node h, List<Key> list) {
        if (h == null) return;
        list.add(h.key);
        preOrder(h.left, list);
        preOrder(h.right, list);
    }
    public List<Key> inOrder() {//中遍历
        ArrayList<Key> list = new ArrayList<>();
        inOrder(root, list);
        return list;
    }
    private void inOrder(Node h, List<Key> list) {
        if (h == null) return;
        preOrder(h.left, list);
        list.add(h.key);
        preOrder(h.right, list);
    }
    private class Node {
        private Key key;
        private Value val;
        private Node left;
        private Node right;
        private boolean color;
        private int size;
        public Node(Key key, Value val, Node left, Node right, boolean color, int size) {
            this.key = key;
            this.val = val;
            this.left = left;
            this.right = right;
            this.color = color;
            this.size = size;
        }
        private int size(){
            return size;
        }
        private boolean hasLeft() {
            return left != null;
        }
        private boolean hasRight() {
            return right != null;
        }
        private boolean isRed(){//这个方法多余了，因为外围类中有时候需要判断的结点完全可能是nil结点，所以外围类中给出了不会空指针异常的判断方法
            return color;
        }
    }
}
```

测试

```java
import java.util.HashMap;
import java.util.List;

public class LLRBDemo {
    public static void main(String[] args) {
        //话说hashmap底层是链表为什么搞了那么多容量相关的设置
        HashMap<Integer, String> map = new HashMap<>();
        MyLLRBTree<Integer, String> llrb = new MyLLRBTree<>();
        llrb.put(1, "1啦");
        llrb.put(100, "100啦");
        llrb.put(-100, "-100啦");
        llrb.put(50, "50啦");
        llrb.put(-10, "-10啦");
        llrb.put(-50, "-50啦");
        llrb.put(-150, "-150啦");
        llrb.put(150, "150啦");
        llrb.put(200, "200啦");
        llrb.put(170, "170啦");

        System.out.println(llrb.get(300));
        System.out.println("size = " + llrb.size());
        showLLBR(llrb);

//        llrb.removeMax();
//        llrb.removeMin();
        llrb.remove(1);
        System.out.println("size = " + llrb.size());
        showLLBR(llrb);

        System.out.println(llrb);//本行debug看树结构用

    }
    //方便看结构
    private static void showLLBR(MyLLRBTree<Integer, String> llrb) {
        List<Integer> preOrderList = llrb.preOrder();//前根
        System.out.println("前根 ： " + preOrderList);
        List<Integer> inOrderList = llrb.inOrder();//中根
        System.out.println("中根 ： " + inOrderList);
    }
}
```

## TODO 检查check()的必要性



# B树

B树，又称多路平衡查找树，B树中所有结点的孩子结点数的最大值又称为B树的阶，
通常用m表示。一棵m阶B树或为空树，或为满足如下特性的m叉树：

1. 树中每个结点至多有m棵子树（即至多含有m-1个关键字）

2. 若根结点不是叶子结点(null)，则至少有两棵子树 (null)

3. 除根结点外的所有非叶结点至少有┌m/2┐棵子树（即至少含有┌m/2┐ -1个关键字）

4. 所有非叶子结点的结构如下

   

   其中，Ki (i=1, 2, …, n) 为结点的关键字，且满足K1 < K2 < … < Kn，Pi (i=1, 2, …, n) 为指向子树根结点的指针，且指针Pi-1所指子树中所有结点的关键字均小于Ki，Pi 所指子树中所有结点的关键字均大于Ki, n (┌m/2┐ -1 <= n <= m-1) 为结点中关键字的个数。

5. 所有叶子结点都出现在同一层次上，并且不带信息。（完美平衡）

> B树阶：每一个结点最大的度。
> 根节点：度[2, m]
> 其余结点: 度[m/2, m]
> 查找树
> 完美平衡



比如这就是一棵3阶B树。当然，通常B树的阶都很大 (几百甚至几千)。

有发现什么吗？
2-3树就是3阶B树，2-3-4树就是4阶B树！[2, 4]

这意味着红黑树其实就是一棵特殊的3阶或者4阶B树!



# 常见的排序算法

## 插入排序

插入排序的思想是每次将一个待排序的记录按其关键字大小插入到前面已经排好序的子序列中, 直到全部记录插入完成.

eg:



```java
public int[] sort(int[] arr )  {

        // 下标为1的位置开始遍历，因为前面只有一个元素
        for (int i = 1; i < arr.length; i++) {

            // 记录遍历到的插入数据
            int tmp = arr[i];

            // 从有序序列最右边的开始比较大小，找到比其小的数
            int j = i;
            while (j > 0 && tmp < arr[j - 1]) {
                arr[j] = arr[j - 1];
                j--;
            }
			arr[j] = tmp;
        }
        return arr;
    }
```



## 希尔排序

先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录"基本有序"时，再对全体记录进行依次直接插入排序.

eg:



```java
public int[] sort(int[] arr)  {
        // 排序数组长度
        int length = arr.length;
        int temp;

        // 初始步长为数组长度的一半, 每次迭代步长减半
        for (int step = length / 2; step >= 1; step /= 2) {

            // 根据步长遍历序列排序
            for (int i = step; i < length; i++) {
                temp = arr[i];
                
                // 分组的直接插入排序
                int j = i - step;
                while (j >= 0 && arr[j] > temp) {
                    arr[j + step] = arr[j];
                    j -= step;
                }
                arr[j + step] = temp;
            }
        }

        return arr;
    }
```



## 冒泡排序

它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果顺序错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素列已经排序完成.

eg:



```java
//参考写法
public int[] sort(int[] arr) {
        
        for (int i = 1; i < arr.length; i++) {
            // 标记全部有序。
            boolean flag = true;
            // 每一趟遍历都从0开始 遍历到arr.length - i
            // (每一趟也都会产生一个最大值在尾部有序)
            for (int j = 0; j < arr.length - i; j++) {
                // 前后比较, 有序跳过, 无序交换
                if (arr[j] > arr[j + 1]) {
                    int tmp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = tmp;

                    flag = false;
                }
            }
            // 已经全部有序, 跳出
            if (flag) break;
        }
        return arr;
    }

//我自己写的冒泡排序,对比下是我想的太少了，参考写法加了有序标记之后，会在已经有序的情况下跳出，备注改进
    public static void bubbleSort(int[] arr) {
        for (int i = arr.length - 1; i > 0; i--) {
            //在这设flag,假设初始有序，即最好的情况式进来遍历1遍就直接跳出循环
            for (int j = 0; j < i; j++) {
                if(arr[j] > arr[j + 1]) {
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                    //调整一次就设置无序，即使调整一次就完成，但计算机看不出来，它要第二次遍历进不来才能确认。
                }
            }
            //确认有序break终止
        }
    }
```



## 快速排序

通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列.

eg:



```java
 public int[] sort(int[] arr) {

        // 递归排序
        return quickSort(arr, 0, arr.length - 1);
    }

    private int[] quickSort(int[] arr, int left, int right) {
        if (left < right) {
            // 把arr划分左右两块, 保证元素满足大小情况:
            // 0 ~ partitionIndex-1  <  partitionIndex+1  ~ right
            int partitionIndex = partition(arr, left, right);
            // 递归0 ~ partitionIndex-1, 使其有序
            quickSort(arr, left, partitionIndex - 1);
            // 递归partitionIndex+1  ~ right, 使其有序
            quickSort(arr, partitionIndex + 1, right);
        }
        return arr;
    }

    private int partition(int[] arr, int left, int right) {
        // 以最left为基准值
        int pivot = arr[left];
        // 从左向右, 从右向左; 相向而行, 直到相遇
        while (left < right){
            // 从右向左, 直到找到小于基准值的值
            while (left < right && arr[right] >= pivot){
                --right;
            }
            // 交换找到的这个小于基准值的值(换到前面)
            arr[left] = arr[right];

            // 从左向右, 直到找到大于基准值的值
            while (left < right && arr[left] <= pivot){
                ++left;
            }
            // 交换找到的这个大于于基准值的值(换到后面)
            arr[right] = arr[left];
        }
        // 确定这个基准值, 在该序列的位置
        // 右侧大于基准值
        // 左侧小于基准值
        arr[left] = pivot;
        return left;
    }
```



## 选择排序

第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零.

eg:



```java
public int[] sort(int[] arr) {
        for (int i = 0; i < arr.length - 1; i++) {
            int min = i;

            // 获取最小值位置
            for (int j = i + 1; j < arr.length; j++) {
                if (arr[j] < arr[min]) {
                    min = j;
                }
            }

            // 把最小值交换到i的位置
            if (i != min) {
                int tmp = arr[i];
                arr[i] = arr[min];
                arr[min] = tmp;
            }
        }
        return arr;
    }

```



## 堆排序

堆积是一个满足-----子结点的键值总是小于(大于)它的父节点的近似完全二叉树的结构.
其中又分为两种堆积方式：
	大顶堆：每个节点的值都大于或等于其子节点的值
	小顶堆：每个节点的值都小于或等于其子节点的值

eg:



```java
public int[] sort(int[] arr) {

        int len = arr.length;
        // 建堆操作
        buildMaxHeap(arr, len);

        // 遍历堆
        for (int i = len - 1; i > 0; i--) {
            // 把根节点(当前未遍历元素最大值)移到后面(交换), 表示该元素是当前无序序列的最大值
            swap(arr, 0, i);
            len--;
            // 保证经过交换的堆, 满足堆积性质
            heapify(arr, 0, i);
        }
        return arr;
    }

    private void buildMaxHeap(int[] arr, int len) {
        // 从len/2的位置向前遍历到0, 保证都满足'堆积'性质
        for (int i = (int) Math.floor(len / 2); i >= 0; i--) {
            // 让i极其子树满足堆积性质
            heapify(arr, i, len);
        }
    }

    private void heapify(int[] arr, int i, int len) {
        // 找到i的左右子节点位置
        int left = 2 * i + 1;
        int right = 2 * i + 2;
        // 记录最大值元素位置
        int largest = i;

        // 判断左子节点是否小于根节点
        if (left < len && arr[left] > arr[largest]) {
            largest = left;
        }
        // 判断右子节点是最大节点
        if (right < len && arr[right] > arr[largest]) {
            largest = right;
        }

        // 如果最大节点不是根节点, 说明需要把最大值交换到根节点
        // 交换之后, 要保证被交换的根节点要符合'堆积'兴致(递归处理)
        if (largest != i) {
            swap(arr, i, largest);
            heapify(arr, largest, len);
        }
    }

    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
```



## 归并排序

把一个待排序的序列分为多个子序列,  然后使每个子序列有序，再合并若干子序列, 重复上书过程, 直到不断合并得到一个有序序列 .

若将两个有序表合并成一个有序表，称为二路归并 .

eg:



```java
  public  int[] sort(int[] arr){
        return sort(arr,0, arr.length - 1);
    }
    private int[] sort(int[] arr,  int left,  int right){
        // 获取左右中间位置
        int mid = (left + right) / 2;

        if(left < right){
            // 左序列排序 left ~ mid
            sort(arr,left, mid);
            // 右序列排序 mid + 1 ~ right
            sort(arr,mid+1,  right);

            //合并左右有序序列
            merge(arr,  left,  mid, right );
        }
        return arr;
    }

    private void merge(int[] arr,  int left, int mid, int right) {
        // 定义一个新数组
        int[] temp = new int[right - left + 1];
        // 左有序序列起点
        int i= left;
        // 右有序序列起点
        int j = mid+1;
        int k=0;

        //遍历比较, 选取小值存放到新数组
        while(i <= mid && j <= right){
            if(arr[i]<=arr[j]){
                temp[k++] = arr[i++];
            }else{
                temp[k++] = arr[j++];
            }
        }

        // 左边剩余的数据存到新数组
        while(i<=mid){
            temp[k++] = arr[i++];
        }
        // 右边剩余的数据存到新数组
        while(j <= right){
            temp[k++] = arr[j++];
        }

        // 把新数组中的有序序列,转移到旧数组
        for(int x=0; x < temp.length; x++){
            arr[x + left] = temp[x];
        }
    }
```



## 排序的比较

各种排序算法的对比





# 集合类



回顾

正式讲课之前，我们先来搞明白几个问题：

1. 什么是数据结构?
   数据结构是相互之间存在一种或多种特定关系的数据元素的集合。

2. 数据结构和JAVA有什么关系?（数据结构在JAVA上的表现）
   数据结构本身和JAVA没有任何关系,
   只不过JAVA中有多种集合、数组、等集合性质的多对象存储结构,
   有时候我们希望更便捷,更具有逻辑性的操作这些集合或者数组数据
   所以,我们根据数据结构的组织方式, 构建了一些特殊的JAVA集合类
   用于描述了一些JAVA对象的底层数据的组成关系

3. 数据结构的种类和JAVA中的集合类别有哪些?



1. 为什么需要集合类？
       很多情况下，我们需要对一组对象进行操作。而且很可能事先并不知道到底有多少个对象。为了解决这个问题呢，Java 就提供了集合类供我们使用。(存储更多类型问题, 扩容问题, 内存空间浪费问题, 数据查找问题, 数据删除问题等等)

2. 集合类的特点
        a. 只能存储引用数据类型
        b. 可以自动地调整自己的大小


3. 数组和集合类都是容器，它们有何不同？
        a. 数组可以存储基本数据类型的数据，集合不可以。
        b. 数组的长度是固定的，集合可以自动调整自己的大小。
        c. 数组的效率高，相对来说集合效率比较低。
        d. 数组没有API，集合有丰富的API。



数据结构

数据结构是相互之间存在一种或多种特定关系的数据元素的集合。

公式：数据结构=数据+结构

数据：用类型表示

结构：在任何问题中，数据元素都不是孤立存在的，它们之间都存在着某种关系，这种数据元素相互之间的关系称为结构。

元素之间，通常有以下四种基本结构：

- 集合

- 线性结构

- 树形结构

- 图或网状结构



数据结构=数据+结构

集合：结构中的数据元素之间除了同属于一个集合的关系之外，别无其他关系。这里的集合和数学中集合的概念是一致的。
线性结构：结构中的数据元素之间存在一个对一个的关系。
树形结构：结构中的数据元素之间存在一个对多个的关系。
图或网状结构：结构中的数据元素之间，存在多个对多个的关系。



逻辑结构&物理结构

前面分类中定义的关系，描述的是数据元素间的逻辑关系，因此又称为逻辑结构。

但是仅仅知道数据元素间的逻辑关系是不够的，因为我们得实现自己的数据结构。
因此，我们得关注数据结构在计算机底层是如何表示的？

数据结构在计算机中的表示，称为数据的物理结构，又称为存储结构或者映像。

数据的表示很简单。

结构的表示可以分为两种：顺序存储结构 (顺序映像) 和 链式存储结构 (非顺序映像)。

- 顺序映像：借助元素在存储器中的相对位置来表示数据元素之间的逻辑关系。(数组)

- 非顺序映像：借助指示元素存储地址的”指针”，来表示数据元素的逻辑关系。(链表)



>  java集合类角度 → 自己实现的集合类: 作为数据容器而存在
> 底层结构  → 数组 , 链表,  数组+链表
> 数据结构 → 表现形式



集合类的特点

​	a. 只能存储引用数据类型 

​	b. 可以自动地调整自己的大小

数组和集合类都是容器，它们有何不同

​	a. 数组可以存储基本数据类型的数据，集合类不可以。

​	b. 数组的长度是固定的，集合可以自动调整自己的大小。

​	c. 数组的效率高，相对来说集合效率比较低。

​	d. 数组没有API，集合有丰富的API。 

Se 常问: String,  HashMap,  多线程,  流



## 有条理地描述问题

注意1: 集合类工作每天都在用. 
注意2: 面试基本必问集合类 . 
注意3: 有条理的回答.  

1. 这个集合类是谁的子类
2. 这个集合类实现什么数据结构(代表什么数据结构)
3.  底层结构是什么
4. 如果底层结构是数组: 初始容量, 扩容机制是什么
5.  是否允许重复元素
6. 能不能存储null元素
7. 是否有序
8.  线程是否安全

加锁 – 慢
颗粒度问题:  颗粒度太细. 
后端, java , spring  

接口只是一个规范定义者: EE 三层架构

# Collection



## Collection 概述

Collection 层次结构中的根接口。Collection 表示一组对象，这些对象也称为 collection 的元素。一些 collection 允许有重复的元素，而另一些则不允许。一些 collection 是有序的，而另一些则是无序的。



Java集合类的分类: 两大类 : Collection集合类, Map集合类
Collection:
		List:
			ArrayList (\*\*\*\*)
			LinkedList (\*\*\*)
			Vector → Stack
        Queue
			Deque (\*)
				ArrayDeque (\*)
				LinkedList
			BlcokingQueue 
				…
		Set
			HashSet (\*\*\*)
			LinkedHashSet(\*\*\*)
			TreeSet (\*\*)

Map: key-value数据
	HashMap （\*\*\*\*)
	LinkedHashMap （\*\*\*)
	TreeMap (\*\*)



Collection的特点

1. Collection是Collection集合体系的顶级接口
2.  一些 Collection的子实现 允许有重复的元素，而另一些 Collection的子实现则不允许。
3. 一些 Collection的子实现 允许存储null，而另一些 Collection的子实现则不允许存储null。
4. 一些 Collection的子实现 有序，而另一些 Collection的子实现无序。

接口定义规范: 不负责实现.
接口具体子类来实现



## Collection接口的API

- boolean add(E e)

- boolean remove(Object o)

- void clear()

- boolean contains(Object o)

- boolean isEmpty()

- int size()

- boolean addAll(Collection c)

- boolean removeAll(Collection c)

- boolean containsAll(Collection c)

- boolean retainAll(Collection c)

- Object[] toArray()
  将集合转换成数组

- Iterator iterator()

  迭代器，集合的专用遍历方式

- <T> T[] toArray(T[] a)

  返回包含此 collection 中所有元素的数组；返回数组的运行时类型与指定数组的运行时类型相同。

  泛型的toArray方法注意

  1. 可以传任何类型的数组, 但是如果穿进来数组, 不能存储原本的元素, 报错

     比如集合类存储的是String, 可以传Integer类型的数组, 但是会报错

  2. 如果我们传的数组和元素个数一样长, 传进去的数组和返回数组是一个数组

  3. 如果我们传的数组比元素个数还要长, 传进去的数组和返回数组是一个数组, 只不过在元素的后一个位置添加一个null(标记结束, 有问题), 别的位置不会覆盖
      因为有的集合实现类是允许添加null的，比如原来末尾就有一个Null，这时候拷贝完成会再null后面再添加一个Null，老实说我知道最后一个Null是方法给添加的标记，但是这好吗，感觉不到祖师爷的精妙。万一我传入的数组在这个被添加null即size()位置是有元素的，这就很尴尬了，这个用做标记结尾的Null实际上覆盖了一个我可能需要的数据，有点微妙，小心使用。

  4. 如果我们传的数组比元素个数还要小, 传进去的数组和返回数组不是一个数组,只是类型相等, 返回的数组是重新创建的

  



## Iterator接口

- 它是对集合进行迭代的迭代器
- 依赖于集合对象存在

- boolean hasNext()

  向后还有没有元素可以遍历
  如果仍有元素可以迭代，则

- E next()

  向后遍历元素

  返回迭代的下

- void remove()

  删除刚刚遍历的元素

  从迭代器指向的 collection 中移除迭代器返回的最后一个元素（可选操作）。

  > 注意: 对于删除操作, 删除的仅仅是刚刚遍历过的元素, 意味着, 不能做连续的删除, 不能在遍历之前删除
  > Iterator主要是用来做遍历, 删除是一个非常非常非常次要功能



Iterator 接口原理

我们用过了 Iterator 的 API，发现我们是通过集合的 iterator() 方法获取 Iterator 接口对象的，它肯定是 Iterator 的子类对象，那它具体是什么类型的呢？

- 为什么Iterator接口要定义成一个接口？而不是一个类？

- 看看源码是如何实现的。

> 成员内部类、静态嵌套类、局部内部类、匿名内部类 。

```
所有集合类结构不一样, 意味着 遍历方式不一样, iterator遍历的方式也不一样, 所以Iterator类型应该是个接口(仅定义遍历规范), 具体实现由不同的集合类根据自己组织数据的方式分别实现
由于集合类的存储的数据, 不应该被外界感知, 遍历的方式(获取这些数据), 应该是个内部类
```



### ConcurrentModificationException

- 现象

- 原因

  产生的原因: 为了避免在多线程情况下, 一个线程在使用iterator遍历Collection集合类, 而另一个线程在对这个Collection集合类进行添加或者删除操作, 导致遍历结果出现问题, 产生了并发修改异常(如果一个线程在做添加和删除, 而另一个线程在做iterator遍历, 那么iterator遍历会立马抛出一个并发修改异常)

  标记改变次数
  Modcount

  在单线程的情况下, 如果在iterator迭代的过程中, 我们使用了源集合类的添加,删除方法, 来修改源集合类, 那么在iterator迭代的过程中modCount != expectedModCount
  会不相等, 也会产生并发修改异常

- 注意事项

  1. 用迭代器对集合遍历的时候，不要使用集合的API对集合进行修改
    2. 使用集合对象的时候，不要使用while循环，可以使用for循环，最好使用foreach循环。



并发修改异常分析

```java
class Collection具体实现子类{  
    int modCount;// 记录修改次数
    
    add(){
        modCount++;
    }
    remove(){
         modCount++;
    }
    
    iterator(){
        new Itr();
    }
    
    class Itr  (Iterator子类){
        int expModCount = modCount;
        
        hasNext(){
            // 判断: expModCount == modCount;
        }
        next(){
            // 判断: expModCount == modCount;
        }
        remove(){
            // 判断: expModCount == modCount;
        }     
    }   
}

//一个Collection对象, 被两个线程持有

```

### Foreach/增强的for循环/加强的for循环:

Jdk1.5

增强for概述 简化数组和Collection集合的遍历 

格式： 

for(元素数据类型 变量 : 数组或者Collection集合) { 

使用变量即可，该变量就是元素 

}  

好处：简化遍历  注意事项：增强for的目标要判断是否为null

Java的for循环, 底层就是iterator迭代(也不要瞎做改变modCound的事)

数组也可以使用增强的for循环, 但是数组能使用是jvm做的适配, 和iterator迭代没有关系



# List

List接口概述

- 有序的 collection（也称为序列）。此接口的用户可以对列表中每个元素的插入位置进行精确地控制。用户可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。

- 与 set 不同，列表通常允许重复的元素。更确切地讲，列表通常允许满足 e1.equals(e2) 的元素对 e1 和 e2，并且如果列表本身允许 null 元素的话，通常它们允许多个 null 元素。



1.  他是Collection的’线性表’子接口.(List定义了线性表的规范) (接口用来定义规范)
2.  List有序
3. 允许存储null
4. 允许存储重复元素





## List接口API

- void add(int index,E element)
- E remove(int index)
- E get(int index)
- E set(int index,E element)
- ListIterator listIterator()

| boolean       | add(E e)         向列表的尾部添加指定的元素（可选操作）。    |
| ------------- | ------------------------------------------------------------ |
| void          | add(int index, E element)         在列表的指定位置插入指定元素（可选操作）。 |
| boolean       | addAll(Collection<? extends E> c)         添加指定  collection 中的所有元素到此列表的结尾，顺序是指定 collection 的迭代器返回这些元素的顺序（可选操作）。 |
| boolean       | addAll(int index, Collection<? extends E> c)         将指定  collection 中的所有元素都插入到列表中的指定位置（可选操作）。 |
| void          | clear()         从列表中移除所有元素（可选操作）。           |
| boolean       | contains(Object o)         如果列表包含指定的元素，则返回 true。 |
| boolean       | containsAll(Collection<?> c)         如果列表包含指定  collection 的所有元素，则返回 true。 |
| boolean       | equals(Object o)         比较指定的对象与列表是否相等。      |
| E             | get(int index)          返回列表中指定位置的元素。           |
| int           | hashCode()         返回列表的哈希码值。                      |
| int           | indexOf(Object o)         返回此列表中第一次出现的指定元素的索引；如果此列表不包含该元素，则返回 -1。 |
| boolean       | isEmpty()         如果列表不包含元素，则返回  true。         |
| IteratorE     | iterator()         返回按适当顺序在列表的元素上进行迭代的迭代器。 |
| int           | lastIndexOf(Object o)         返回此列表中最后出现的指定元素的索引；如果列表不包含此元素，则返回 -1。 |
| ListIteratorE | listIterator()         返回此列表元素的列表迭代器（按适当顺序）。 |
| ListIteratorE | listIterator(int index)         返回列表中元素的列表迭代器（按适当顺序），从列表的指定位置开始。 |
| E             | remove(int index)         移除列表中指定位置的元素（可选操作）。 |
| boolean       | remove(Object o)         从此列表中移除第一次出现的指定元素（如果存在）（可选操作）。 |
| boolean       | removeAll(Collection<?> c)         从列表中移除指定  collection 中包含的其所有元素（可选操作）。 |
| boolean       | retainAll(Collection<?> c)         仅在列表中保留指定  collection 中所包含的元素（可选操作）。 |
| E             | set(int index, E element)         用指定元素替换列表中指定位置的元素（可选操作）。 |
| int           | size()         返回列表中的元素数。                          |
| ListE         | subList(int fromIndex,  int toIndex)         返回列表中指定的  fromIndex（包括 ）和 toIndex（不包括）之间的部分视图。 |
| Object[]      | toArray()         返回按适当顺序包含列表中的所有元素的数组（从第一个元素到最后一个元素）。 |
| <T> T[]       | toArray(T[] a)         返回按适当顺序（从第一个元素到最后一个元素）包含列表中所有元素的数组；返回数组的运行时类型是指定数组的运行时类型。 |



## Listiterator 类型

1. 他是Iterator的一个子接口( 至少拥有 hashNext  next  remove三个方法)
   public interface ListIterator<E> extends Iterator<E>
2. listIterator 不仅定义了向后遍历的操作(有由于他是Iterator的子接口), 还定义了向前遍历的操作

HashNext:  向后是否可以遍历
Next:  向后遍历
Remove: 删除刚刚遍历过的元素

HasPrevious: 是否可以向前遍历
Previous: 向前遍历

Add() 添加: 添加的遍历位置(可以连续添加)
Set: 修改方法: 修改的是刚刚遍历过的元素的位置

NextIndex:  下一个元素的下标
PreviousIndex:  前一个元素的下标

| void    | add(E e)         将指定的元素插入列表（可选操作）。          |
| ------- | ------------------------------------------------------------ |
| boolean | hasNext()         以正向遍历列表时，如果列表迭代器有多个元素，则返回 true（换句话说，如果 next 返回一个元素而不是抛出异常，则返回 true）。 |
| boolean | hasPrevious()         如果以逆向遍历列表，列表迭代器有多个元素，则返回 true。 |
| E       | next()         返回列表中的下一个元素。                      |
| int     | nextIndex()         返回对 next 的后续调用所返回元素的索引。 |
| E       | previous()         返回列表中的前一个元素。                  |
| int     | previousIndex()         返回对 previous 的后续调用所返回元素的索引。 |
| void    | remove()         从列表中移除由 next 或 previous 返回的最后一个元素（可选操作）。 |
| void    | set(E e)         用指定元素替换 next 或 previous 返回的最后一个元素（可选操作）。 |



## 视图:subList
视图 → 数据库(数据仓库)

集合类的视图方法返回的数据, 还是源数据



# List的子类

## ArrayList

概述

1. List接口一个具体子实现( 它是List接口的数组实现  描述是一个线性表)
2. 底层结构是数组
3.  默认初始容量 : 10(第一添加时候),  扩容机制(扩容为原来的1.5倍)
4. 允许null
5. 允许重复
6. 有序
7. 线程不安全



- 底层数据结构是数组，查询快，增删慢
- 线程不安全，效率高

构造方法

| ArrayList()         构造一个初始容量为 10 的空列表。         |
| ------------------------------------------------------------ |
| ArrayList(Collection<? extendsE> c)         构造一个包含指定  collection 的元素的列表，这些元素是按照该 collection 的迭代器返回它们的顺序排列的。 |
| ArrayList(int initialCapacity)         构造一个具有指定初始容量的空列表。 |

Api

| boolean          | add(Ee)         将指定的元素添加到此列表的尾部。             |
| ---------------- | ------------------------------------------------------------ |
| void             | add(int index,Eelement)         将指定的元素插入此列表中的指定位置。 |
| boolean          | addAll(Collection<? extendsE> c)         按照指定 collection  的迭代器所返回的元素顺序，将该 collection 中的所有元素添加到此列表的尾部。 |
| boolean          | addAll(int index,Collection<? extendsE> c)         从指定的位置开始，将指定  collection 中的所有元素插入到此列表中。 |
| void             | clear()         移除此列表中的所有元素。                     |
| Object           | clone()         返回此 ArrayList 实例的浅表副本。            |
| boolean          | contains(Objecto)         如果此列表中包含指定的元素，则返回 true。 |
| void             | ensureCapacity(int minCapacity)         如有必要，增加此 ArrayList 实例的容量，以确保它至少能够容纳最小容量参数所指定的元素数。 |
| E                | get(int index)         返回此列表中指定位置上的元素。        |
| int              | indexOf(Objecto)         返回此列表中首次出现的指定元素的索引，或如果此列表不包含元素，则返回 -1。 |
| boolean          | isEmpty()         如果此列表中没有元素，则返回 true          |
| int              | lastIndexOf(Objecto)         返回此列表中最后一次出现的指定元素的索引，或如果此列表不包含索引，则返回 -1。 |
| E                | remove(int index)         移除此列表中指定位置上的元素。     |
| boolean          | remove(Objecto)         移除此列表中首次出现的指定元素（如果存在）。 |
| protected   void | removeRange(int fromIndex,  int toIndex)         移除列表中索引在 fromIndex（包括）和 toIndex（不包括）之间的所有元素。 |
| E                | set(int index,Eelement)         用指定的元素替代此列表中指定位置上的元素。 |
| int              | size()         返回此列表中的元素数。                        |
| Object[]         | toArray()         按适当顺序（从第一个到最后一个元素）返回包含此列表中所有元素的数组。 |
| <T> T[]          | toArray(T[] a)         按适当顺序（从第一个到最后一个元素）返回包含此列表中所有元素的数组；返回数组的运行时类型是指定数组的运行时类型。 |
| void             | trimToSize()         将此 ArrayList 实例的容量调整为列表的当前大小。 |



### ArrayList源码分析

```java
        ArrayList<String> list = new ArrayList<>();
        list.add("zs");
        System.out.println(list);
```

```java
class ArrayList{   
    
    Object[] elementData;// 底层数组
    int size;// 标记存储元素的数量
    
    private static final int DEFAULT_CAPACITY = 10;
    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;
    
    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};
    
    
     public ArrayList(Collection<? extends E> c) {
        elementData = c.toArray();
        if ((size = elementData.length) != 0) {
            // c.toArray might (incorrectly) not return Object[] (see 6260652)
            if (elementData.getClass() != Object[].class)
                elementData = Arrays.copyOf(elementData, size, Object[].class);
        } else {
            // replace with empty array.
            this.elementData = EMPTY_ELEMENTDATA;
        }
    }
    
    public ArrayList() {
        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
    }
    
    
     public void add(int index, E element) {
        rangeCheckForAdd(index);

        ensureCapacityInternal(size + 1);  // Increments modCount!!
        System.arraycopy(elementData, index, elementData, index + 1,
                         size - index);
        elementData[index] = element;
        size++;
    }
    
   public boolean add(E e) {
       //                       1
        ensureCapacityInternal(size + 1);  // Increments modCount!!
        elementData[size++] = e;
        return true;
    }
    
    //                                             1
    private void ensureCapacityInternal(int minCapacity) { 
        //  真
        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
            
            // minCapacity =  10
            // 							10             1
            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
        }

        ensureExplicitCapacity(minCapacity);
    }
    
    //                                       10
    private void ensureExplicitCapacity(int minCapacity) {
        modCount++;

        //   10         -  0 > 0  真
        if (minCapacity - elementData.length > 0)
            grow(minCapacity);
    }
    
     private void grow(int minCapacity) {
        // oldCapacity 旧容量 0
        int oldCapacity = elementData.length;
         // newCapacity 新容量  = 1.5旧容量  0
        int newCapacity = oldCapacity + (oldCapacity >> 1);
         
         // 0    - 10 < 0
        if (newCapacity - minCapacity < 0)
            // newCapacity = 10
            newCapacity = minCapacity;
        if (newCapacity - MAX_ARRAY_SIZE > 0)
            newCapacity = hugeCapacity(minCapacity);
         
        //  Arrays.copyOf : 复制数组
        elementData = Arrays.copyOf(elementData, newCapacity);
    }
}
```



Iterator

Iterator():  Collection
ListIterator():  List

> 此类的 iterator 和 listIterator 方法返回的迭代器是快速失败的：在创建迭代器之后，除非通过迭代器自身的 remove 或 add 方法从结构上对列表进行修改，否则在任何时间以任何方式对列表进行修改，迭代器都会抛出 ConcurrentModificationException。因此，面对并发的修改，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险。
>
> 注意，迭代器的快速失败行为无法得到保证，因为一般来说，不可能对是否出现不同步并发修改做出任何硬性保证。快速失败迭代器会尽最大努力抛出 ConcurrentModificationException。因此，为提高这类迭代器的正确性而编写一个依赖于此异常的程序是错误的做法：迭代器的快速失败行为应该仅用于检测 bug。

由以上原因在看源码能看出，不管迭代器内部怎么在执行next或者previous方法前判断，源码时判断了两次，其实在多线成环境下也是不一定能抛出异常的，modCound完全可能在二次检查之后被改变，天知道什么时候被CPU调度插队了，所以尤其时源码中第二次以外围类持有数组的长度和cursor的暂存值i比较我是一脸懵的，目前体会不到祖师爷的精妙之处。因为就算再连续做几次判断，都不如保证迭代的环境没有线程干扰。

### ArrayList源码分析: iterator

```java
		ArrayList<String> list = new ArrayList<>();
        list.add("zs");
        list.add("ls");
        list.add("wu");
        list.add("zl");

        Iterator<String> iterator = list.iterator();
        while (iterator.hasNext()){
            System.out.println(iterator.next());
        }
```

```java
//游标代码中虽然指向元素，逻辑上理解为指向元素之间（画图时清晰）
class ArrayList{
    
    Object [] elementData;// 底层数组
    int size;
    int modCount;// 标记修改次数
    
    public Iterator<E> iterator() {
        return new Itr();
    }
    private class Itr implements Iterator<E> {
        int cursor;       // 标记的下一次要遍历的元素
        int lastRet = -1; // 刚刚遍历过的元素位置
        int expectedModCount = modCount;// 标记修改次数

        public boolean hasNext() {
            return cursor != size;
        }

        @SuppressWarnings("unchecked")
        public E next() {
            checkForComodification();
            int i = cursor;
            if (i >= size)
                throw new NoSuchElementException();
            Object[] elementData = ArrayList.this.elementData;
            if (i >= elementData.length)
                throw new ConcurrentModificationException();
            cursor = i + 1;
            return (E) elementData[lastRet = i];
        }

        public void remove() {
            if (lastRet < 0)
                throw new IllegalStateException();
            checkForComodification();

            try {
                ArrayList.this.remove(lastRet);
                cursor = lastRet;
                lastRet = -1;
                expectedModCount = modCount;
            } catch (IndexOutOfBoundsException ex) {
                throw new ConcurrentModificationException();
            }
        }

        final void checkForComodification() {
            if (modCount != expectedModCount)
                throw new ConcurrentModificationException();
        }
    }
 
}
```



### ArrayList源码分析: listiterator

```java
		ArrayList<String> list = new ArrayList<>();
        list.add("zs");
        list.add("ls");
        list.add("wu");
        list.add("zl");

       ListIterator<String> iterator = list.listIterator();
        while (iterator.hasNext()){
            System.out.println(iterator.next());
        }
```

```java
class ArrayList{
    
    Object [] elementData;// 底层数组
    int size;
    int modCount;// 标记修改次数
    
    public ListIterator<E> listIterator(int index) {
        if (index < 0 || index > size)
            throw new IndexOutOfBoundsException("Index: "+index);
        return new ListItr(index);
    }
    public ListIterator<E> listIterator() {
        return new ListItr(0);
    }
    // 一个实体类是另外一个实体类的子类, 那么一定是子类想复用父类的变量/结构/方法
   private class ListItr extends Itr implements ListIterator<E> {
       int cursor;       // 标记的下一次要遍历的元素
        int lastRet = -1; // 刚刚遍历过的元素位置
        int expectedModCount = modCount;// 标记修改次数
       
        ListItr(int index) {
            cursor = index;
        }
       
       
        public boolean hasNext() {
            return cursor != size;
        }

        @SuppressWarnings("unchecked")
        public E next() {
            checkForComodification();
            int i = cursor;
            if (i >= size)
                throw new NoSuchElementException();
            Object[] elementData = ArrayList.this.elementData;
            if (i >= elementData.length)
                throw new ConcurrentModificationException();
            cursor = i + 1;
            return (E) elementData[lastRet = i];
        }

        public void remove() {
            if (lastRet < 0)
                throw new IllegalStateException();
            checkForComodification();

            try {
                ArrayList.this.remove(lastRet);
                cursor = lastRet;
                lastRet = -1;
                expectedModCount = modCount;
            } catch (IndexOutOfBoundsException ex) {
                throw new ConcurrentModificationException();
            }
        }
 

        final void checkForComodification() {
            if (modCount != expectedModCount)
                throw new ConcurrentModificationException();
        }

        public boolean hasPrevious() {
            return cursor != 0;
        }

        public int nextIndex() {
            return cursor;
        }

        public int previousIndex() {
            return cursor - 1;
        }

        @SuppressWarnings("unchecked")
        public E previous() {
            checkForComodification();
            int i = cursor - 1;
            if (i < 0)
                throw new NoSuchElementException();
            Object[] elementData = ArrayList.this.elementData;
            if (i >= elementData.length)
                throw new ConcurrentModificationException();
            cursor = i;
            return (E) elementData[lastRet = i];
        }

        public void set(E e) {
            if (lastRet < 0)
                throw new IllegalStateException();
            checkForComodification();

            try {
                ArrayList.this.set(lastRet, e);
            } catch (IndexOutOfBoundsException ex) {
                throw new ConcurrentModificationException();
            }
        }

        public void add(E e) {
            checkForComodification();

            try {
                int i = cursor;
                ArrayList.this.add(i, e);
                cursor = i + 1;
                lastRet = -1;
                expectedModCount = modCount;
            } catch (IndexOutOfBoundsException ex) {
                throw new ConcurrentModificationException();
            }
        }
    }

   
    private class Itr implements Iterator<E> {
        int cursor;       // 标记的下一次要遍历的元素
        int lastRet = -1; // 刚刚遍历过的元素位置
        int expectedModCount = modCount;// 标记修改次数

        public boolean hasNext() {
            return cursor != size;
        }

        @SuppressWarnings("unchecked")
        public E next() {
            checkForComodification();
            int i = cursor;
            if (i >= size)
                throw new NoSuchElementException();
            Object[] elementData = ArrayList.this.elementData;
            if (i >= elementData.length)
                throw new ConcurrentModificationException();
            cursor = i + 1;
            return (E) elementData[lastRet = i];
        }

        public void remove() {
            if (lastRet < 0)
                throw new IllegalStateException();
            checkForComodification();

            try {
                ArrayList.this.remove(lastRet);
                cursor = lastRet;
                lastRet = -1;
                expectedModCount = modCount;
            } catch (IndexOutOfBoundsException ex) {
                throw new ConcurrentModificationException();
            }
        }

        final void checkForComodification() {
            if (modCount != expectedModCount)
                throw new ConcurrentModificationException();
        }
    }
   
}
```



SubList

视图方法

### ArrayList源码分析: subList方法(视图)

```java
        ArrayList<String> list = new ArrayList<>();
        list.add("zs");
        list.add("ls");
        list.add("wu");
        list.add("zl");
        
        List<String> list1 = list.subList(0, 3);
        System.out.println(list1);
```

```java
class ArrayList{
    
    Object [] elementData;// 底层数组
    int size;
    
    public List<E> subList(int fromIndex, int toIndex) {
        subListRangeCheck(fromIndex, toIndex, size);
        
        
        return new SubList(this, 0, fromIndex, toIndex);
    }
    
    
    private class SubList extends AbstractList<E> implements RandomAccess {
        private final AbstractList<E> parent; //  ArrayList对象
        private final int parentOffset;// 起始位置
        private final int offset;
        int size;// 存储的元素数量

        SubList(AbstractList<E> parent,
                int offset, int fromIndex, int toIndex) {
            this.parent = parent;
            this.parentOffset = fromIndex;
            this.offset = offset + fromIndex;
            this.size = toIndex - fromIndex;
            this.modCount = ArrayList.this.modCount;
        }

        public E set(int index, E e) {
            rangeCheck(index);
            checkForComodification();
            E oldValue = ArrayList.this.elementData(offset + index);
            ArrayList.this.elementData[offset + index] = e;
            return oldValue;
        }

        public E get(int index) {
            rangeCheck(index);
            checkForComodification();
            return ArrayList.this.elementData(offset + index);
        }

        public int size() {
            checkForComodification();
            return this.size;
        }

        public void add(int index, E e) {
            rangeCheckForAdd(index);
            checkForComodification();
            parent.add(parentOffset + index, e);
            this.modCount = parent.modCount;
            this.size++;
        }

        public E remove(int index) {
            rangeCheck(index);
            checkForComodification();
            
            
            E result = parent.remove(parentOffset + index);
            this.modCount = parent.modCount;
            this.size--;
            return result;
        }

        protected void removeRange(int fromIndex, int toIndex) {
            checkForComodification();
            parent.removeRange(parentOffset + fromIndex,
                               parentOffset + toIndex);
            this.modCount = parent.modCount;
            this.size -= toIndex - fromIndex;
        }

        public boolean addAll(Collection<? extends E> c) {
            return addAll(this.size, c);
        }

        public boolean addAll(int index, Collection<? extends E> c) {
            rangeCheckForAdd(index);
            int cSize = c.size();
            if (cSize==0)
                return false;

            checkForComodification();
            parent.addAll(parentOffset + index, c);
            this.modCount = parent.modCount;
            this.size += cSize;
            return true;
        }

        public Iterator<E> iterator() {
            return listIterator();
        }

        public ListIterator<E> listIterator(final int index) {
            checkForComodification();
            rangeCheckForAdd(index);
            final int offset = this.offset;

            return new ListIterator<E>() {
                int cursor = index;
                int lastRet = -1;
                int expectedModCount = ArrayList.this.modCount;

                public boolean hasNext() {
                    return cursor != SubList.this.size;
                }

                @SuppressWarnings("unchecked")
                public E next() {
                    checkForComodification();
                    int i = cursor;
                    if (i >= SubList.this.size)
                        throw new NoSuchElementException();
                    Object[] elementData = ArrayList.this.elementData;
                    if (offset + i >= elementData.length)
                        throw new ConcurrentModificationException();
                    cursor = i + 1;
                    return (E) elementData[offset + (lastRet = i)];
                }

                public boolean hasPrevious() {
                    return cursor != 0;
                }

                @SuppressWarnings("unchecked")
                public E previous() {
                    checkForComodification();
                    int i = cursor - 1;
                    if (i < 0)
                        throw new NoSuchElementException();
                    Object[] elementData = ArrayList.this.elementData;
                    if (offset + i >= elementData.length)
                        throw new ConcurrentModificationException();
                    cursor = i;
                    return (E) elementData[offset + (lastRet = i)];
                }

                @SuppressWarnings("unchecked")
                public void forEachRemaining(Consumer<? super E> consumer) {
                    Objects.requireNonNull(consumer);
                    final int size = SubList.this.size;
                    int i = cursor;
                    if (i >= size) {
                        return;
                    }
                    final Object[] elementData = ArrayList.this.elementData;
                    if (offset + i >= elementData.length) {
                        throw new ConcurrentModificationException();
                    }
                    while (i != size && modCount == expectedModCount) {
                        consumer.accept((E) elementData[offset + (i++)]);
                    }
                    // update once at end of iteration to reduce heap write traffic
                    lastRet = cursor = i;
                    checkForComodification();
                }

                public int nextIndex() {
                    return cursor;
                }

                public int previousIndex() {
                    return cursor - 1;
                }

                public void remove() {
                    if (lastRet < 0)
                        throw new IllegalStateException();
                    checkForComodification();

                    try {
                        SubList.this.remove(lastRet);
                        cursor = lastRet;
                        lastRet = -1;
                        expectedModCount = ArrayList.this.modCount;
                    } catch (IndexOutOfBoundsException ex) {
                        throw new ConcurrentModificationException();
                    }
                }

                public void set(E e) {
                    if (lastRet < 0)
                        throw new IllegalStateException();
                    checkForComodification();

                    try {
                        ArrayList.this.set(offset + lastRet, e);
                    } catch (IndexOutOfBoundsException ex) {
                        throw new ConcurrentModificationException();
                    }
                }

                public void add(E e) {
                    checkForComodification();

                    try {
                        int i = cursor;
                        SubList.this.add(i, e);
                        cursor = i + 1;
                        lastRet = -1;
                        expectedModCount = ArrayList.this.modCount;
                    } catch (IndexOutOfBoundsException ex) {
                        throw new ConcurrentModificationException();
                    }
                }

                final void checkForComodification() {
                    if (expectedModCount != ArrayList.this.modCount)
                        throw new ConcurrentModificationException();
                }
            };
        }

        public List<E> subList(int fromIndex, int toIndex) {
            subListRangeCheck(fromIndex, toIndex, size);
            return new SubList(this, offset, fromIndex, toIndex);
        }

        private void rangeCheck(int index) {
            if (index < 0 || index >= this.size)
                throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
        }

        private void rangeCheckForAdd(int index) {
            if (index < 0 || index > this.size)
                throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
        }

        private String outOfBoundsMsg(int index) {
            return "Index: "+index+", Size: "+this.size;
        }

        private void checkForComodification() {
            if (ArrayList.this.modCount != this.modCount)
                throw new ConcurrentModificationException();
        }

        public Spliterator<E> spliterator() {
            checkForComodification();
            return new ArrayListSpliterator<E>(ArrayList.this, offset,
                                               offset + this.size, this.modCount);
        }
    }
  
}
```





## Vector

1. Vector是List一个数组实现(表示一个线性表)
2.  默认初始容量 10,  扩容机制: (如果有增量, 扩增量个, 没有增量的话扩为原来的2倍)
3. 允许null, 允许重复, 有序
4. 线程安全
5. (大多数集合类都是jdk1.2的时候出现的) , vector是jdk1.0出现的
6. 增量(扩容)



- 底层数据结构是数组，查询快，增删慢
- 线程安全，效率低
- Vector 特有的API
  - public void addElement(E obj)
  - public E elementAt(int index)
  - public Enumeration elements()



构造方法

| Vector()         构造一个空向量，使其内部数据数组的大小为 10，其标准容量增量为零。 |
| ------------------------------------------------------------ |
| Vector(Collection<? extendsE> c)         构造一个包含指定  collection 中的元素的向量，这些元素按其 collection 的迭代器返回元素的顺序排列。 |
| Vector(int initialCapacity)         使用指定的初始容量和等于零的容量增量构造一个空向量。 |
| Vector(int initialCapacity,  int capacityIncrement)         使用指定的初始容量和容量增量构造一个空的向量。 |



Vector源码分析

```java
//        1,  Vector是List一个数组实现(表示一个线性表)
//        2,  默认初始容量,  扩容机制
//        3, 允许null, 允许重复, 有序
//        4, 线程安全
//        5, (大多数集合类都是jdk1.2的时候出现的) , vector是jdk1.0出现的
        Vector<String> vector = new Vector<>();

 		Vector<String> vector = new Vector<>(10, 5);    
```

```java
class Vector{
    
    Object[] elementData;// 底层数组
    int capacityIncrement;// 增量
    int elementCount ; // size. 
    
    public Vector() {
        this(10);
    }
    public Vector(int initialCapacity) {
        this(initialCapacity, 0);
    }
    //                   10                    0
    public Vector(int initialCapacity, int capacityIncrement) {
        super();
        if (initialCapacity < 0)
            throw new IllegalArgumentException("Illegal Capacity: "+
                                               initialCapacity);
        this.elementData = new Object[initialCapacity];
        this.capacityIncrement = capacityIncrement;
    }
    
    public synchronized boolean add(E e) {
        modCount++;
        ensureCapacityHelper(elementCount + 1);
        elementData[elementCount++] = e;
        return true;
    }
    
    private void ensureCapacityHelper(int minCapacity) {
        // overflow-conscious code
        if (minCapacity - elementData.length > 0)
            grow(minCapacity);
    }
    
    private void grow(int minCapacity) {
        // oldCapacity : 旧容量
        int oldCapacity = elementData.length;
        // newCapacity : 新容量
        // 没有增量(增量不大于0)  新容量 = 旧容量的2倍
        // 有增量(增量大于0)  新容量 = 旧容量 + 增量
        int newCapacity = oldCapacity + ((capacityIncrement > 0) ?
                                         capacityIncrement : oldCapacity);
        if (newCapacity - minCapacity < 0)
            newCapacity = minCapacity;
        if (newCapacity - MAX_ARRAY_SIZE > 0)
            newCapacity = hugeCapacity(minCapacity);
        elementData = Arrays.copyOf(elementData, newCapacity);
    }
    
}
```

## Stack

概述

1. Stack是Vector的子类
2. 底层复用的Vector的数组（初始容量10， 扩容机制2倍）
3. Stack 作为一个栈存在 
4. 有序， 允许null， 允许重复
5. 线程安全（效率低）
6. 不要使用从Vector继承来的方法（语法没有任何问题， 但是我们使用的时候，希望stack作为一个栈而存在， 而不是线性表）
7.  jdk也不推荐使用Stack，如果我们需要使用栈的话， jdk推荐我们使用Deque用来充当一个栈 



Stack源码分析

```java
//        1, Stack是Vector的子类
//        2, 底层复用的Vector的数组（初始容量10， 扩容机制2倍）
//        3, Stack 作为一个栈存在
//        4，有序， 允许null， 允许重复
//        5， 线程安全
        Stack<String> stack = new Stack<>();
```

```java
class Stack<E> extends Vector<E>{   
    public E push(E item) {
        addElement(item);
        return item;
    }  
}

class Vector{
    Object [] elementData;
    int elementCount;    
}
```



## LinkedList 

概述

1. LinkedList是List的子类, 还是Deque的子类(主要是List的子类)

2.  LinkedList是List的链表实现

3. 允许null, 允许重复, 有序

4.  线程不安全

5.  LinkedList可以作为一个线性表,  还可以作为一个队列, 作为一个双端队列, 作为栈

   ```
   Offer poll
   Offerfirst offerlast
   Push  pop
   ...
   ```

   

- 底层数据结构是链表，查询慢，增删快
- 线程不安全，效率高
- LinkedList 特有的API
  - public void addFirst(E e)及addLast(E e)
  - public E getFirst()及getLast()
  - public E removeFirst()及public E removeLast()

构造方法

| LinkedList()         构造一个空列表。                        |
| ------------------------------------------------------------ |
| LinkedList(Collection<? extendsE> c)         构造一个包含指定  collection 中的元素的列表，这些元素按其 collection 的迭代器返回的顺序排列。 |

Api

| boolean         | add(Ee)         将指定元素添加到此列表的结尾。               |
| --------------- | ------------------------------------------------------------ |
| void            | add(int index,Eelement)         在此列表中指定的位置插入指定的元素。 |
| boolean         | addAll(Collection<? extendsE> c)         添加指定 collection  中的所有元素到此列表的结尾，顺序是指定 collection 的迭代器返回这些元素的顺序。 |
| boolean         | addAll(int index,Collection<? extendsE> c)         将指定 collection 中的所有元素从指定位置开始插入此列表。 |
| void            | addFirst(Ee)         将指定元素插入此列表的开头。            |
| void            | addLast(Ee)         将指定元素添加到此列表的结尾。           |
| void            | clear()         从此列表中移除所有元素。                     |
| Object          | clone()         返回此 LinkedList 的浅表副本。               |
| boolean         | contains(Objecto)         如果此列表包含指定元素，则返回 true。 |
| Iterator<E>     | descendingIterator()         返回以逆向顺序在此双端队列的元素上进行迭代的迭代器。 |
| E               | element()         获取但不移除此列表的头（第一个元素）。     |
| E               | get(int index)         返回此列表中指定位置处的元素。        |
| E               | getFirst()         返回此列表的第一个元素。                  |
| E               | getLast()         返回此列表的最后一个元素。                 |
| int             | indexOf(Objecto)         返回此列表中首次出现的指定元素的索引，如果此列表中不包含该元素，则返回 -1。 |
| int             | lastIndexOf(Objecto)         返回此列表中最后出现的指定元素的索引，如果此列表中不包含该元素，则返回 -1。 |
| ListIterator<E> | listIterator(int index)         返回此列表中的元素的列表迭代器（按适当顺序），从列表中指定位置开始。 |
| boolean         | offer(Ee)         将指定元素添加到此列表的末尾（最后一个元素）。 |
| boolean         | offerFirst(Ee)         在此列表的开头插入指定的元素。        |
| boolean         | offerLast(Ee)         在此列表末尾插入指定的元素。           |
| E               | peek()         获取但不移除此列表的头（第一个元素）。        |
| E               | peekFirst()         获取但不移除此列表的第一个元素；如果此列表为空，则返回 null。 |
| E               | peekLast()         获取但不移除此列表的最后一个元素；如果此列表为空，则返回 null。 |
| E               | poll()         获取并移除此列表的头（第一个元素）            |
| E               | pollFirst()         获取并移除此列表的第一个元素；如果此列表为空，则返回 null。 |
| E               | pollLast()         获取并移除此列表的最后一个元素；如果此列表为空，则返回 null。 |
| E               | pop()         从此列表所表示的堆栈处弹出一个元素。           |
| void            | push(Ee)         将元素推入此列表所表示的堆栈。              |
| E               | remove()         获取并移除此列表的头（第一个元素）。        |
| E               | remove(int index)         移除此列表中指定位置处的元素。     |
| boolean         | remove(Objecto)         从此列表中移除首次出现的指定元素（如果存在）。 |
| E               | removeFirst()         移除并返回此列表的第一个元素。         |
| boolean         | removeFirstOccurrence(Objecto)         从此列表中移除第一次出现的指定元素（从头部到尾部遍历列表时）。 |
| E               | removeLast()         移除并返回此列表的最后一个元素。        |
| boolean         | removeLastOccurrence(Objecto)         从此列表中移除最后一次出现的指定元素（从头部到尾部遍历列表时）。 |
| E               | set(int index,Eelement)         将此列表中指定位置的元素替换为指定的元素。 |
| int             | size()         返回此列表的元素数。                          |
| Object[]        | toArray()         返回以适当顺序（从第一个元素到最后一个元素）包含此列表中所有元素的数组。 |
| <T> T[]         | toArray(T[] a)         返回以适当顺序（从第一个元素到最后一个元素）包含此列表中所有元素的数组；返回数组的运行时类型为指定数组的类型。 |



descendingIterator

逆序迭代器，就是个ListItr的包装

```java
class LinkedList{
    
    public Iterator<E> descendingIterator() {
        return new DescendingIterator();
    } 
    
    
     private class DescendingIterator implements Iterator<E> {
        private final ListItr itr = new ListItr(size());
        public boolean hasNext() {
            return itr.hasPrevious();
        }
        public E next() {
            return itr.previous();
        }
        public void remove() {
            itr.remove();
        }
    }  
}
```



练习：

1. 去重
2. 请用ArrayList实现栈数据结构，并测试。

3.   集合的嵌套遍历
4.   获取10个1-20之间的随机整数，要求集合中的数不能重复。

```java
public interface MyList<E> extends Iterable<E> {
    boolean add(E e);
    void add(int index, E element);
    void clear();
    boolean contains(Object o);
    E get(int index);
    int indexOf(Object o);
    int lastIndexOf(Object o);
    boolean isEmpty();
    MyIterator<E> iterator();
    MyIterator<E> iterator(int index);
    E remove(int index);
    boolean remove(Object o);
    E set(int index, E element);
    int size();
}
public interface MyIterator<E> extends Iterator<E> {
    boolean hasNext();
    E next();
    boolean hasPrevious();
    E previous();
    int nextIndex();
    int previousIndex();
    void add(E e);
    void remove();
    void set(E e);
}

```



# Queue

概述

1. Queue他是collection的一个子接口(队列子接口)
2. Queue所描述的数据结构是一个队列
3. 有序
4. 允许重复元素
5. 不允许存储null(LinkedList除外)

对于Queue的poll操作, 如果删除一个元素, 没有元素可以删除, 他就返回一个null来标记

Api

| boolean | add(E e)         将指定的元素插入此队列（如果立即可行且不会违反容量限制），在成功时返回 true，如果当前没有可用的空间，则抛出  IllegalStateException。 |
| ------- | ------------------------------------------------------------ |
| E       | element()         获取，但是不移除此队列的头。               |
| boolean | offer(E e)         将指定的元素插入此队列（如果立即可行且不会违反容量限制），当使用有容量限制的队列时，此方法通常要优于  add(E)，后者可能无法插入元素，而只是抛出一个异常。 |
| E       | peek()         获取但不移除此队列的头；如果此队列为空，则返回 null。 |
| E       | poll()         获取并移除此队列的头，如果此队列为空，则返回 null。 |
| E       | remove()         获取并移除此队列的头。                      |



# Deque

概述

1. Deque是Queue一个子接口
2. 他是双端队列子接口(  Deque不仅可以作为队列存在, 作为双端队列, 可以作为栈)
3.  有序
4. 允许重复元素
5. 不允许null



Api

int size() 
          返回此双端队列的元素数。

boolean add(E e) 
          将指定元素插入此双端队列所表示的队列（换句话说，此双端队列的尾部），如果可以直接这样做而不违反容量限制的话；如果成功，则返回 true，如果当前没有可用空间，则抛出 IllegalStateException。 
void addFirst(E e) 
          将指定元素插入此双端队列的开头（如果可以直接这样做而不违反容量限制）。 
void addLast(E e) 
          将指定元素插入此双端队列的末尾（如果可以直接这样做而不违反容量限制）。 
boolean contains(Object o) 
          如果此双端队列包含指定元素，则返回 true。 		  

E element() 
          获取，但不移除此双端队列所表示的队列的头部（换句话说，此双端队列的第一个元素）。 
E getFirst() 
          获取，但不移除此双端队列的第一个元素。 
E getLast() 
          获取，但不移除此双端队列的最后一个元素。	   

E remove() 
          获取并移除此双端队列所表示的队列的头部（换句话说，此双端队列的第一个元素）。 
boolean remove(Object o) 
          从此双端队列中移除第一次出现的指定元素。 
E removeFirst() 
          获取并移除此双端队列第一个元素。 		  
E removeLast() 
          获取并移除此双端队列的最后一个元素。 
boolean removeFirstOccurrence(Object o) 
          从此双端队列移除第一次出现的指定元素。 
boolean removeLastOccurrence(Object o) 
          从此双端队列移除最后一次出现的指定元素。 

​		  

boolean offer(E e) 
          将指定元素插入此双端队列所表示的队列（换句话说，此双端队列的尾部），如果可以直接这样做而不违反容量限制的话；如果成功，则返回 true，如果当前没有可用的空间，则返回 false。 

E poll() 
          获取并移除此双端队列所表示的队列的头部（换句话说，此双端队列的第一个元素）；如果此双端队列为空，则返回 null。 
E peek() 
          获取，但不移除此双端队列所表示的队列的头部（换句话说，此双端队列的第一个元素）；如果此双端队列为空，则返回 null。 

boolean offerFirst(E e) 
          在不违反容量限制的情况下，将指定的元素插入此双端队列的开头。 
boolean offerLast(E e) 
          在不违反容量限制的情况下，将指定的元素插入此双端队列的末尾。 
E peekFirst() 
          获取，但不移除此双端队列的第一个元素；如果此双端队列为空，则返回 null。 
E peekLast() 
          获取，但不移除此双端队列的最后一个元素；如果此双端队列为空，则返回 null。 

E pollFirst() 
          获取并移除此双端队列的第一个元素；如果此双端队列为空，则返回 null。 
E pollLast() 
          获取并移除此双端队列的最后一个元素；如果此双端队列为空，则返回 null。 
		  



E pop() 
          从此双端队列所表示的堆栈中弹出一个元素。 

void push(E e) 
          将一个元素推入此双端队列所表示的堆栈（换句话说，此双端队列的头部），如果可以直接这样做而不违反容量限制的话；如果成功，则返回 true，如果当前没有可用空间，则抛出 IllegalStateException。 

 

Iterator<E> descendingIterator() 
          返回以逆向顺序在此双端队列的元素上进行迭代的迭代器。 

Iterator<E> iterator() 
          返回以恰当顺序在此双端队列的元素上进行迭代的迭代器。



# ArrayDeque

概述

1. ArrayDeque是Deque的子实现(双端队列/ 普通队列/ 栈)
2. 底层是一个数组(循环数组)
3. 默认的初始容量 16 , 扩容机制(扩容机制 扩为原来的2倍)
4. 允许重复, 有序, 不允许null
5.  线程不安全
6.  给定一个长度(数组长度), 但是ArrayDeque的底层数组未必是你给定的长度, 大于给定值的一个最小的2的幂值

```
10 -> 16
20 -> 32
100 -> 128
40 -> 64

方便位运算: 
(tail = (tail + 1) & (elements.length - 1))


(tail = (tail + 1) % (elements.length))
20 -> 4 
16 -> 1111
20->10100
& ->00100  -> 4

```



构造方法

| ArrayDeque()         构造一个初始容量能够容纳  16 个元素的空数组双端队列。 |
| ------------------------------------------------------------ |
| ArrayDeque(Collection<? extends E> c)         构造一个包含指定  collection 的元素的双端队列，这些元素按 collection 的迭代器返回的顺序排列。 |
| ArrayDeque(int numElements)         构造一个初始容量能够容纳指定数量的元素的空数组双端队列。 |



## ArrayDeque的源码分析

```java
//        1, ArrayDeque是Deque的子实现(双端队列)
//        2, 底层是一个数组(循环数组)
//        3, 默认的初始容量, 扩容机制
//        4, 允许重复, 有序, 不允许null
//        5, 线程不安全
        ArrayDeque<String> deque = new ArrayDeque<>();
        deque.offer("zs");
        //...
        deque.offer("ls");
```

```java
class ArrayDeque{
    
    Object [] elements;
    
     public ArrayDeque() {
        elements = new Object[16];
    }
    
    public boolean offer(E e) {
        return offerLast(e);
    }
    
    public boolean offerLast(E e) {
        addLast(e);
        return true;
    }
    
    public void addLast(E e) {
        if (e == null)
            throw new NullPointerException();
        elements[tail] = e;// 把元素添加到尾部
        
        if ( (tail = (tail + 1) & (elements.length - 1)) == head)
            doubleCapacity();
    }
    
    private void doubleCapacity() {
        assert head == tail;
        int p = head;
        int n = elements.length;
        int r = n - p; // number of elements to the right of p
        
        
        // newCapacity 新容量  n旧容量  = 2 旧容量
        int newCapacity = n << 1;
        if (newCapacity < 0)
            throw new IllegalStateException("Sorry, deque too big");
        
        Object[] a = new Object[newCapacity];
        
        System.arraycopy(elements, p, a, 0, r);
        System.arraycopy(elements, 0, a, r, p);
        elements = a;
        head = 0;
        tail = n;
    }  
}
```



ArrayDeque源码分析

```java
		ArrayDeque<String> deque = new ArrayDeque<>(10);
        deque.offer("zs");
        deque.offer("ls");

```

```java
class ArrayDeque{
    
    Object[] elements;
      private static final int MIN_INITIAL_CAPACITY = 8;
    
    //                     10
    public ArrayDeque(int numElements) {
        allocateElements(numElements);
    }
    //                                    10
    private void allocateElements(int numElements) {
        
        // initialCapacity = 8
        int initialCapacity = MIN_INITIAL_CAPACITY;
      
        if (numElements >= initialCapacity) {
            // initialCapacity = 10
            initialCapacity = numElements;
            
            // 第一步: 
            //initialCapacity :  1010
            // >>> 1		  :  0101
            //                :  1111
            initialCapacity |= (initialCapacity >>>  1);
            // 第一步: 
            //initialCapacity :  1111
            // >>> 2		  :  0011
            //                :  1111
            initialCapacity |= (initialCapacity >>>  2);
            initialCapacity |= (initialCapacity >>>  4);
            initialCapacity |= (initialCapacity >>>  8);
            initialCapacity |= (initialCapacity >>> 16);
            // initialCapacity :  1111 -> 15
            // initialCapacity : 16
            initialCapacity++;

            if (initialCapacity < 0)   // Too many elements, must back off
                initialCapacity >>>= 1;// Good luck allocating 2 ^ 30 elements
        }
        
        // 如果给定长度小于8, 创建一个长度为8的数组
        elements = new Object[initialCapacity];
    }
    
    
}
```

```java
 //                                
    private void allocateElements(int numElements) {
        
        // initialCapacity = 8
        int initialCapacity = MIN_INITIAL_CAPACITY;
      
        if (numElements >= initialCapacity) {
            
            initialCapacity = numElements;
            
            // 第一步: 
            //initialCapacity :  1010000000000000
            // >>> 1		  :  0101000000000000
            //                :  1111000000000000
            initialCapacity |= (initialCapacity >>>  1);
            // 第一步: 
            //initialCapacity :  1111000000000000
            // >>> 2		  :  0011110000000000
            //                :  1111110000000000
            initialCapacity |= (initialCapacity >>>  2);
            initialCapacity |= (initialCapacity >>>  4);
            initialCapacity |= (initialCapacity >>>  8);
            initialCapacity |= (initialCapacity >>> 16);
            // initialCapacity :  1111 -> 15
            // initialCapacity : 16
            initialCapacity++;

            if (initialCapacity < 0)   // Too many elements, must back off
                initialCapacity >>>= 1;// Good luck allocating 2 ^ 30 elements
        }
        
        // 如果给定长度小于8, 创建一个长度为8的数组
        elements = new Object[initialCapacity];
    }



 //                                   8
    private void allocateElements(int numElements) {
        
        // initialCapacity = 8
        int initialCapacity = MIN_INITIAL_CAPACITY;
      
        if (numElements >= initialCapacity) {
            // initialCapacity = 8
            initialCapacity = numElements;
            
            // 第一步: 
            //initialCapacity :  1000
            // >>> 1		  :  0100
            //                :  1100
            initialCapacity |= (initialCapacity >>>  1);
            // 第一步: 
            //initialCapacity :  1100
            // >>> 2		  :  0011
            //                :  1111
            initialCapacity |= (initialCapacity >>>  2);
            initialCapacity |= (initialCapacity >>>  4);
            initialCapacity |= (initialCapacity >>>  8);
            initialCapacity |= (initialCapacity >>> 16);
            // initialCapacity :  1111 -> 15
            // initialCapacity : 16
            initialCapacity++;

            if (initialCapacity < 0)   // Too many elements, must back off
                initialCapacity >>>= 1;// Good luck allocating 2 ^ 30 elements
        }
        
        // 如果给定长度小于8, 创建一个长度为8的数组
        elements = new Object[initialCapacity];
    }
```



# BlockingQueue

阻塞队列:  

1. 如果队列满了, 添加线程等待
2. 如果队列空了, 删除线程等待



概述

1. BlockingQueue是Queue接口的一个’阻塞’的子接口
2. 代表是一个阻塞队列
3. 阻塞队列不能扩容(如果可以扩容, 没有阻塞的必要了)



Api: 阻塞Api

|      | 抛出异常  | 特殊值   | 阻塞   | 超时                  |
| ---- | --------- | -------- | ------ | --------------------- |
| 插入 | add(e)    | offer(e) | put(e) | offer(e,  time, unit) |
| 移除 | remove()  | poll()   | take() | poll(time,  unit)     |
| 检查 | element() | peek()   | 不可用 | 不可用                |

超时: 可以设置一个时间, 在有限的时间内阻塞, 超过设置的时间, 转化为返回特殊值

```
queue.offer("zs", 10 , TimeUnit.SECONDS);//最多等10秒
String poll = queue.poll(3, TimeUnit.SECONDS);//最多等3秒
put(e) 和 take()会一直阻塞
```



# Map

Map接口概述

- 将键映射到值的对象。(我们可以根据键快速地查找到值)

- Map 中键是唯一的 (不能包含重复的键)

- 每个键最多只能映射到一个值。



1. Map接口是Map集合体系的顶级接口
2. Map存储的数据: key-value, 键值对数据
3.  Map不允许存储重复的key
4. 有些Map的只实现是有序, 有些无序
5. 有些Map的子实现允许null key, 有些不允许



Key-value数据具有自我描述性: 用key描述value



问题：map应该提供哪些API?

Map接口API

| void            | clear()         从此映射中移除所有映射关系（可选操作）。     |
| --------------- | ------------------------------------------------------------ |
| boolean         | containsKey(Object key)         如果此映射包含指定键的映射关系，则返回 true。 |
| boolean         | containsValue(Object value)         如果此映射将一个或多个键映射到指定值，则返回 true。 |
| SetMap.EntryK,V | entrySet()         返回此映射中包含的映射关系的 Set 视图。   |
| boolean         | equals(Object o)         比较指定的对象与此映射是否相等。    |
| V               | get(Object key)         返回指定键所映射的值；如果此映射不包含该键的映射关系，则返回 null。 |
| int             | hashCode()         返回此映射的哈希码值。                    |
| boolean         | isEmpty()         如果此映射未包含键-值映射关系，则返回 true。 |
| SetK            | keySet()         返回此映射中包含的键的 Set 视图。           |
| V               | put(K key,  V value)          将指定的值与此映射中的指定键关联（可选操作）。 |
| void            | putAll(Map<? extends K,? extends V> m)         从指定映射中将所有映射关系复制到此映射中（可选操作）。 |
| V               | remove(Object key)         如果存在一个键的映射关系，则将其从此映射中移除（可选操作）。 |
| int             | size()         返回此映射中的键-值映射关系数。               |
| CollectionV     | values()         返回此映射中包含的值的 Collection 视图。    |



## HashMap

- 基于哈希表的Map接口实现。

- 允许null键和null值。

- 不保证映射的顺序，特别是它不保证该顺序恒久不变。

- 不同步。



概述

1. HashMap是Map接口的具体实现

2. 底层结构 : 数组+链表+红黑树  jdk1.8之前(没有红黑树)(存在红黑树的原因, 就是为了避免某一个数组位置的链表过长导致效率降低)

3. 数组默认初始长度16 , 数组扩容 (扩为原来的2 倍)  -> 数组长度永远是2的幂值

4. 不允许存储’’重复’’的key,

5. 允许存储null key.

6. 无序的 

7. 线程不安全

8. HashMap是拥有默认的加载因子, 0.75
   用空间换时间. 
   一个HashMap存储key-value数据量 =  数组长度 * 加载因子
   可以修改加载因子: 希望大家设置 0.5 ~ 1

9. 通过key 得到 存储到数组上的下标位置
   (1)	通过这个key计算 得到一个hash值: (h = key.hashCode()) ^ (h >>> 16) 
   Hashcode 一般是32位
   (2)	让这个hash值和数组长度取模, 得到下标 
   (p = tab[i = (n - 1) & hash]) == null

10. 如果我们创建HashMap的时候给定一个长度, 那么他会创建一个大于等于给定长度的底层数组

11. hashmap取hash值: 移位和异或运算是为了做充分散列(高位参与运算)
    (h = key.hashCode()) ^ (h >>> 16)

12. 什么时候链表转化为红黑树?
    前提条件, 多个不同的key-value数据经过hash计算,再经过取模获得下标, 有可能得到同一个位置, 构成一个链表, 如果链表过长, 会导致效率降低, 所以要转化为红黑树. 多长:  当算上新添加的元素, 超过8个达到9个的时候, 会从链表转化为红黑树

    ```java
    for (int binCount = 0; ; ++binCount) {
    	if ((e = p.next) == null) {
            p.next = newNode(hash, key, value, null);
            if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                treeifyBin(tab, hash);
            	break;
            }
        if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k))))
            break;
        p = e;
    }
    ```

    ​        p

    ​        ↓

    |...|中|...|...|...|...|...|......emementData
      0   中   e   p
      1   中   e   p
      2   中   e   p
      3   中   e   p
      4   中   e   p
      5   中   e   p
      6   中   e   p
      7   <font color=red>中</font>   e   p

    ​        ↑

    ​      null 

13. 有时候红黑树是会转化回链表的:
    
    - A. 不断的删除(并且删除的元素是红黑树上的)

      ```
      if (root == null || root.right == null ||
                      (rl = root.left) == null || rl.left == null) 
      ```
    
      Root: 红黑树的根节点
    
      根节点是不是null;
    
      根节点左右子结点是不是null
    
      根节点的左节点的左节点 是不是null
    
      如果这4个结点有一个为空, 要把树转化会链表
    
    - B. 在扩容的时候也可能导致红黑树转化回链表(红黑树会拆分到两个位置, ) 6
    
      `(e.hash & bit) == 0`
    
      在扩容的时候可能导致红黑树拆分到两个位置, 这两个位置的元素数量如果小于等于6, 要由红黑树转化为链表
    
      ```
      Hash值20:
      10100  → 存储4位置
      10000
      
      →	新位置20
      100000
      
      (e.hash & bit) == 0说明高位为0，保持原位；相与不为0说明高位为1，移到新位置 = 原下标+原数组长度
      ```
    
      
    
14. HashMap的底层数组, 是一个Node类型的数组, 里面存储的是Node类型的结点, 包含四个值: key,  value, hash, next
    `Node<K,V>[] table;`

15. 如果存储的key-value数据, key是重复的, 那么新的key-value数据的value值会覆盖旧key-value数据的value值

16. HashMap怎么定义重复?
    首先key的hash值是否一样, 如果hash值一样, 还要判断两个key-value数据的key是否直接相等或者相equals

17. 如果我们使用一个key, 这个key是一个比较复杂的对象(比如User类型的对象), 如果我们希望判断重复的依据 是两个User对象里面存储的值是否重复, 那么应该重写两个方法

    HashCode 和 equals 方法

18. 如果链表长度超过8达到9 未必一定转化为红黑树?
    如果数组长度小于64会优先选择扩容 

    ```java
    static final int MIN_TREEIFY_CAPACITY = 64;
    if (tab == null || (n = tab.length) < MIN_TREEIFY_CAPACITY)
        resize();
    ```

19. 如果HashMap的底层数组产生扩容, 那么原本下标位置在index位置的元素, 会重新散列, 但是只会散列到两个位置, 1原位置不变, 2, 新位置 = 旧长度+旧下标

20. 在HashMap中一旦添加了某一个key-value数据, (eg: key-User类型), 不要修改它的key, 一旦修改, 这个key-value数据就再也无法操作
    →	如果一个数据存储到HashMap中, 不要再修改(尤其不要通过引用修改里面的内容)



**哈希**

充分散列
什么是hash?  数学概念, 散列
Hash算法(hash散列): MD5, SHA1  , SHA2  复杂的位运算: 上百次
202cb962ac59075b964b07152d234b70  → 123
关键信息的存储(密码/ 身份证号/ 支付密码)
输入敏感
加密: Hash不是加密算法
加密: 解密→对称/非对称



hashmap虽然在插入到某个数量的时候会打乱但并不是真的重新完全打乱。因为hashmap按照2倍扩容，比如原来在x位置，增加的容量为L，扩容后的位置要么在X要么在X+L。这从hash的计算和用二进制取余的方法来看会比较明显，老实说还是对位运算很陌生。



构造方法

| HashMap()         构造一个具有默认初始容量  (16) 和默认加载因子 (0.75) 的空 HashMap。 |
| ------------------------------------------------------------ |
| HashMap(int initialCapacity)         构造一个带指定初始容量和默认加载因子 (0.75) 的空 HashMap。 |
| HashMap(int initialCapacity,  float loadFactor)         构造一个带指定初始容量和加载因子的空 HashMap。 |
| HashMap(Map<? extendsK,? extendsV> m)         构造一个映射关系与指定 Map 相同的新 HashMap。 |



Api

| void                | clear()         从此映射中移除所有映射关系。                 |
| ------------------- | ------------------------------------------------------------ |
| Object              | clone()         返回此 HashMap 实例的浅表副本：并不复制键和值本身。 |
| boolean             | containsKey(Objectkey)         如果此映射包含对于指定键的映射关系，则返回 true。 |
| boolean             | containsValue(Objectvalue)         如果此映射将一个或多个键映射到指定值，则返回 true。 |
| Set<Map.Entry<K,V>> | entrySet()         返回此映射所包含的映射关系的 Set 视图。   |
| V                   | get(Objectkey)         返回指定键所映射的值；如果对于该键来说，此映射不包含任何映射关系，则返回  null。 |
| boolean             | isEmpty()         如果此映射不包含键-值映射关系，则返回  true。 |
| Set<K>              | keySet()         返回此映射中所包含的键的 Set  视图。        |
| V                   | put(Kkey,Vvalue)         在此映射中关联指定值与指定键。      |
| void                | putAll(Map<? extendsK,? extendsV> m)         将指定映射的所有映射关系复制到此映射中，这些映射关系将替换此映射目前针对指定映射中所有键的所有映射关系。 |
| V                   | remove(Objectkey)         从此映射中移除指定键的映射关系（如果存在）。 |
| int                 | size()         返回此映射中的键-值映射关系数。               |
| Collection<V>       | values()         返回此映射所包含的值的 Collection 视图。    |



### HashMap源码分析: 默认初始容量

```java
        HashMap<String, Integer> map = new HashMap<>();
        map.put("zs", 18);// 第一添加数据
        map.put("ls", 18);
        map.put("wu", 18);
        map.put("zl", 18);
```

```java
class HashMap{
    
    final float loadFactor;// 加载因子(饱和度)
    static final float DEFAULT_LOAD_FACTOR = 0.75f;
     transient Node<K,V>[] table;// HashMap底层数组
    int threshold;// 阈值
    static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16
    
    public HashMap() {
        this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted
    }
    
    //             zs      18
    public V put(K key, V value) {
        
        return putVal(hash(key), key, value, false, true);
    }
     static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
    }
    
    //                 3897     zs     18
    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict) {
        
        
        Node<K,V>[] tab; 
        Node<K,V> p;
        int n, i;
        
        // table = null
        // tab = null
        if ((tab = table) == null || (n = tab.length) == 0)
            //  resize(): 扩容方法
            n = (tab = resize()).length;
        
        // n 底层数组长度
        // (n - 1) & hash  --> 取模
        // tab[取模位置]  == null
        if ((p = tab[i = (n - 1) & hash]) == null)
            tab[i] = newNode(hash, key, value, null);
        else {
            Node<K,V> e; K k;
            if (p.hash == hash &&
                ((k = p.key) == key || (key != null && key.equals(k))))
                e = p;
            else if (p instanceof TreeNode)
                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
            else {
                for (int binCount = 0; ; ++binCount) {
                    if ((e = p.next) == null) {
                        p.next = newNode(hash, key, value, null);
                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash);
                        break;
                    }
                    if (e.hash == hash &&
                        ((k = e.key) == key || (key != null && key.equals(k))))
                        break;
                    p = e;
                }
            }
            if (e != null) { // existing mapping for key
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);
                return oldValue;
            }
        }
        ++modCount;
        if (++size > threshold)
            resize();
        afterNodeInsertion(evict);
        return null;
    }
    
    // 
    final Node<K,V>[] resize() {
        // oldTab = table = null
        Node<K,V>[] oldTab = table;
        
        // oldCap  = 0
        int oldCap = (oldTab == null) ? 0 : oldTab.length;
        // oldThr = threshold =  0
        int oldThr = threshold;
        
        // 新长度/ 新阈值
        int newCap, newThr = 0;
        
        
        
        if (oldCap > 0) {
            if (oldCap >= MAXIMUM_CAPACITY) {
                threshold = Integer.MAX_VALUE;
                return oldTab;
            }
            else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&
                     oldCap >= DEFAULT_INITIAL_CAPACITY)
                newThr = oldThr << 1; // double threshold
        }
        else if (oldThr > 0) // initial capacity was placed in threshold
            newCap = oldThr;
        else {              
            // newCap =  DEFAULT_INITIAL_CAPACITY = 16
            newCap = DEFAULT_INITIAL_CAPACITY;
            // newThr =  0.75 *  16 = 12
            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
        }
        
        if (newThr == 0) {
            float ft = (float)newCap * loadFactor;
            newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?
                      (int)ft : Integer.MAX_VALUE);
        }
        
        // threshold = 12
        threshold = newThr;
        @SuppressWarnings({"rawtypes","unchecked"})
        // 创建一个数组: 创建了一个长度为16 的新数组
            Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];
        // 把创建的新数组赋值给table
        table = newTab;
        if (oldTab != null) {
            for (int j = 0; j < oldCap; ++j) {
                Node<K,V> e;
                if ((e = oldTab[j]) != null) {
                    oldTab[j] = null;
                    if (e.next == null)
                        newTab[e.hash & (newCap - 1)] = e;
                    else if (e instanceof TreeNode)
                        ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);
                    else { // preserve order
                        Node<K,V> loHead = null, loTail = null;
                        Node<K,V> hiHead = null, hiTail = null;
                        Node<K,V> next;
                        do {
                            next = e.next;
                            if ((e.hash & oldCap) == 0) {
                                if (loTail == null)
                                    loHead = e;
                                else
                                    loTail.next = e;
                                loTail = e;
                            }
                            else {
                                if (hiTail == null)
                                    hiHead = e;
                                else
                                    hiTail.next = e;
                                hiTail = e;
                            }
                        } while ((e = next) != null);
                        if (loTail != null) {
                            loTail.next = null;
                            newTab[j] = loHead;
                        }
                        if (hiTail != null) {
                            hiTail.next = null;
                            newTab[j + oldCap] = hiHead;
                        }
                    }
                }
            }
        }
        return newTab;
    }


    
}
```





### HashMap源码分析：扩容

```java
class HashMap{
    
      final float loadFactor;// 加载因子(饱和度)
    static final float DEFAULT_LOAD_FACTOR = 0.75f;
     transient Node<K,V>[] table;// HashMap底层数组
    int threshold;// 阈值
    static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16
    int size; // 标记这个HashMAp中存储了多少份Key-value数据
     static final int MAXIMUM_CAPACITY = 1 << 30;
    
    
    public V put(K key, V value) {
        return putVal(hash(key), key, value, false, true);
    }
    
    // 
   final V putVal(int hash, K key, V value, boolean onlyIfAbsent,  boolean evict) {

     Node<K,V>[] tab;
       Node<K,V> p; 
       int n, i;
       
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
        if ((p = tab[i = (n - 1) & hash]) == null)
            tab[i] = newNode(hash, key, value, null);
        else {
            Node<K,V> e; K k;
            if (p.hash == hash &&
                ((k = p.key) == key || (key != null && key.equals(k))))
                e = p;
            else if (p instanceof TreeNode)
                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
            else {
                for (int binCount = 0; ; ++binCount) {
                    if ((e = p.next) == null) {
                        p.next = newNode(hash, key, value, null);
                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash);
                        break;
                    }
                    if (e.hash == hash &&
                        ((k = e.key) == key || (key != null && key.equals(k))))
                        break;
                    p = e;
                }
            }
            if (e != null) { // existing mapping for key
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);
                return oldValue;
            }
        }
        ++modCount;
       
       // 数组: 16
       // threshold = 12
        if (++size > threshold)
            resize();
        afterNodeInsertion(evict);
        return null;
    }

    
    final Node<K,V>[] resize() {
        
        // oldTab = 长度16的数组
        Node<K,V>[] oldTab = table;
        // oldCap = 16
        int oldCap = (oldTab == null) ? 0 : oldTab.length;
        // oldThr = 12
        int oldThr = threshold;
        
        // 新长度, 新阈值
        int newCap, newThr = 0;
        
        
        if (oldCap > 0) {
            if (oldCap >= MAXIMUM_CAPACITY) {
                threshold = Integer.MAX_VALUE;
                return oldTab;
            }// newCap = 2 * oldCap = 32 > 扩为原来的两倍
            else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&
                     oldCap >= DEFAULT_INITIAL_CAPACITY)
                // newThr = 2倍旧阈值 = 24
                newThr = oldThr << 1; // double threshold
        }
        else if (oldThr > 0) // initial capacity was placed in threshold
            newCap = oldThr;
        else {               // zero initial threshold signifies using defaults
            newCap = DEFAULT_INITIAL_CAPACITY;
            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
        }
        if (newThr == 0) {
            float ft = (float)newCap * loadFactor;
            newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?
                      (int)ft : Integer.MAX_VALUE);
        }
        
        // threshold = 24
        threshold = newThr;
        @SuppressWarnings({"rawtypes","unchecked"})
        //  创建一个长度为32的数组
            Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];
        // 赋值给全局table
        table = newTab;
        if (oldTab != null) {
            for (int j = 0; j < oldCap; ++j) {
                Node<K,V> e;
                if ((e = oldTab[j]) != null) {
                    oldTab[j] = null;
                    if (e.next == null)
                        newTab[e.hash & (newCap - 1)] = e;
                    else if (e instanceof TreeNode)
                        ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);
                    else { // preserve order
                        Node<K,V> loHead = null, loTail = null;
                        Node<K,V> hiHead = null, hiTail = null;
                        Node<K,V> next;
                        do {
                            next = e.next;
                            if ((e.hash & oldCap) == 0) {
                                if (loTail == null)
                                    loHead = e;
                                else
                                    loTail.next = e;
                                loTail = e;
                            }
                            else {
                                if (hiTail == null)
                                    hiHead = e;
                                else
                                    hiTail.next = e;
                                hiTail = e;
                            }
                        } while ((e = next) != null);
                        if (loTail != null) {
                            loTail.next = null;
                            newTab[j] = loHead;
                        }
                        if (hiTail != null) {
                            hiTail.next = null;
                            newTab[j + oldCap] = hiHead;
                        }
                    }
                }
            }
        }
        return newTab;
    }
    
}
```



### HashMap源码分析: 重复位置

```java
        HashMap<String, Integer> map = new HashMap<>(10, 0.9f);
        map.put("zs", 18);
        map.put("ls", 18);
// 假如zs 和ls 这两个key经过计算之后, 得到的下标位置一样
```



```java
class HashMap{
    
    public V put(K key, V value) {
        return putVal(hash(key), key, value, false, true);
    }
    
    final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) {
        Node<K,V>[] tab; 
        Node<K,V> p; int n, i;
        
            static final int TREEIFY_THRESHOLD = 8;
        
        
        // 
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
        
        // tab底层数组
        // i =  (n - 1) & hash    -> hash值计算的下标
        // p 就是散列的下标位置
        if ((p = tab[i = (n - 1) & hash]) == null)
            tab[i] = newNode(hash, key, value, null);
        else {
            // 意味着这个下标位置已经存储了内容
            
            Node<K,V> e; 
            K k;
            
            // p 已经存储的元素
            if (p.hash == hash &&((k = p.key) == key || (key != null && key.equals(k))))
                // 满足条件: 那么就认为是重复元素
                e = p;
            
            // 如果走到这一步, 意味着, 数组下标位置第一个元素,和我不重复, 我要接着比较下面的元素是否和我重复
            else if (p instanceof TreeNode)// 判断这个节点(数组下标位置第一个元素)是否是树节点
                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
            else {
                // 如果走到这一步, 意味着,这个下标位置存储的是一个链表,而非红黑树
                // p 最开始标记的是这个链表的头结点
                
                for (int binCount = 0; ; ++binCount) {
                    if ((e = p.next) == null) {
                        // p 遍历的结点
                        p.next = newNode(hash, key, value, null);
                        
                        // binCount >= 7
                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash);// 树化操作: 单链表--转化为--树
                        break;
                    }
                    if (e.hash == hash &&
                        ((k = e.key) == key || (key != null && key.equals(k))))
                        break;
                    p = e;
                }
            }
            if (e != null) { // existing mapping for key
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;// 新value覆盖旧value值
                afterNodeAccess(e);
                return oldValue;
            }
        }
        ++modCount;
        if (++size > threshold)
            resize();
        afterNodeInsertion(evict);
        return null;
    }
    
     Node<K,V> newNode(int hash, K key, V value, Node<K,V> next) {
        return new Node<>(hash, key, value, next);
    }
    
    static class Node<K,V> implements Map.Entry<K,V> {
        final int hash;
        final K key;
        V value;
        Node<K,V> next;

        Node(int hash, K key, V value, Node<K,V> next) {
            this.hash = hash;
            this.key = key;
            this.value = value;
            this.next = next;
        }
    }
    
    
}
```



### HashMap源码分析:给定长度

```java
        HashMap<String, Integer> map = new HashMap<>(10);
        map.put("zs", 18);
```



```java
class HashMap{
    
    threshold = ; // 阈值
    loadFactor = 0.75;// 加载因子
   
    
    public HashMap(int initialCapacity) {
          //  10                  0.75
        this(initialCapacity, DEFAULT_LOAD_FACTOR);
    }
    
    public HashMap(int initialCapacity, float loadFactor) {
        if (initialCapacity < 0)
            throw new IllegalArgumentException("Illegal initial capacity: " +
                                               initialCapacity);
        if (initialCapacity > MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        if (loadFactor <= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException("Illegal load factor: " +
                                               loadFactor);
        
        
        this.loadFactor = loadFactor;
        
        // initialCapacity = 10
        // threshold = 16
        this.threshold = tableSizeFor(initialCapacity);
    }

    
    //                                   10
     static final int tableSizeFor(int cap) {
         // n = 9  -> 1001
        int n = cap - 1;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
         // 1111 -> 15
         
        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
    }
    
     public V put(K key, V value) {
        return putVal(hash(key), key, value, false, true);
    }
    
    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
        
        Node<K,V>[] tab;
        Node<K,V> p; 
        int n, i;
        
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
        if ((p = tab[i = (n - 1) & hash]) == null)
            tab[i] = newNode(hash, key, value, null);
        else {
            Node<K,V> e; K k;
            if (p.hash == hash &&
                ((k = p.key) == key || (key != null && key.equals(k))))
                e = p;
            else if (p instanceof TreeNode)
                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
            else {
                for (int binCount = 0; ; ++binCount) {
                    if ((e = p.next) == null) {
                        p.next = newNode(hash, key, value, null);
                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash);
                        break;
                    }
                    if (e.hash == hash &&
                        ((k = e.key) == key || (key != null && key.equals(k))))
                        break;
                    p = e;
                }
            }
            if (e != null) { // existing mapping for key
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);
                return oldValue;
            }
        }
        ++modCount;
        if (++size > threshold)
            resize();
        afterNodeInsertion(evict);
        return null;
    }
    
    
    
    final Node<K,V>[] resize() {
        
        // oldTab  = null
        Node<K,V>[] oldTab = table;
        // oldCap = 0
        int oldCap = (oldTab == null) ? 0 : oldTab.length;
        
        // threshold = 16
        // 旧阈值 = 16
        int oldThr = threshold;
        
        // 新阈值, 新长度
        int newCap, newThr = 0;
        
        if (oldCap > 0) {
            if (oldCap >= MAXIMUM_CAPACITY) {
                threshold = Integer.MAX_VALUE;
                return oldTab;
            }
            else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&
                     oldCap >= DEFAULT_INITIAL_CAPACITY)
                newThr = oldThr << 1; // double threshold
        }
        else if (oldThr > 0) // initial capacity was placed in threshold
            // 新长度 = 旧阈值
            // newCap = 16
            newCap = oldThr;
        else {               // zero initial threshold signifies using defaults
            newCap = DEFAULT_INITIAL_CAPACITY;
            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
        }
        if (newThr == 0) {
            
            // ft = 16 * 0.75 = 12
            float ft = (float)newCap * loadFactor;
            // newThr = ft = 12
            newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?
                      (int)ft : Integer.MAX_VALUE);
        }
        // threshold = 12
        threshold = newThr;
        @SuppressWarnings({"rawtypes","unchecked"})
        // 创建一个长度为16的数组
            Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];
        table = newTab;
        if (oldTab != null) {
            for (int j = 0; j < oldCap; ++j) {
                Node<K,V> e;
                if ((e = oldTab[j]) != null) {
                    oldTab[j] = null;
                    if (e.next == null)
                        newTab[e.hash & (newCap - 1)] = e;
                    else if (e instanceof TreeNode)
                        ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);
                    else { // preserve order
                        Node<K,V> loHead = null, loTail = null;
                        Node<K,V> hiHead = null, hiTail = null;
                        Node<K,V> next;
                        do {
                            next = e.next;
                            if ((e.hash & oldCap) == 0) {
                                if (loTail == null)
                                    loHead = e;
                                else
                                    loTail.next = e;
                                loTail = e;
                            }
                            else {
                                if (hiTail == null)
                                    hiHead = e;
                                else
                                    hiTail.next = e;
                                hiTail = e;
                            }
                        } while ((e = next) != null);
                        if (loTail != null) {
                            loTail.next = null;
                            newTab[j] = loHead;
                        }
                        if (hiTail != null) {
                            hiTail.next = null;
                            newTab[j + oldCap] = hiHead;
                        }
                    }
                }
            }
        }
        return newTab;
    }

    
}
```



### HashMap源码分析:扩容导致红黑树回转链表

```java
// 知识, 短期没有什么影响, 
        HashMap<String, Integer> map = new HashMap<>(10, 0.9f);
        map.put("zs", 18);
        map.put("ls", 18);
```

```java
class HashMap{
    
    // 基础
    
    public V put(K key, V value) {
        return putVal(hash(key), key, value, false, true);
    }
    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
        Node<K,V>[] tab; Node<K,V> p; int n, i;
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
        if ((p = tab[i = (n - 1) & hash]) == null)
            tab[i] = newNode(hash, key, value, null);
        else {
            Node<K,V> e; K k;
            if (p.hash == hash &&
                ((k = p.key) == key || (key != null && key.equals(k))))
                e = p;
            else if (p instanceof TreeNode)
                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
            else {
                for (int binCount = 0; ; ++binCount) {
                    if ((e = p.next) == null) {
                        p.next = newNode(hash, key, value, null);
                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash);
                        break;
                    }
                    if (e.hash == hash &&
                        ((k = e.key) == key || (key != null && key.equals(k))))
                        break;
                    p = e;
                }
            }
            if (e != null) { // existing mapping for key
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);
                return oldValue;
            }
        }
        ++modCount;
        
        // 添加的元素数目, 大于 阈值
        if (++size > threshold)
            resize();
        afterNodeInsertion(evict);
        return null;
    }
    
    // 底层数组长度为16, 加载因子0.75, 阈值12
    // 添加了13个元素
    
    final Node<K,V>[] resize() {
        // oldTab = 长度为16的数组
        Node<K,V>[] oldTab = table;
        // oldCap = 16
        int oldCap = (oldTab == null) ? 0 : oldTab.length;
        // 
        int oldThr = threshold;
        int newCap, newThr = 0;
        if (oldCap > 0) {
            if (oldCap >= MAXIMUM_CAPACITY) {
                threshold = Integer.MAX_VALUE;
                return oldTab;
            }
            else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&
                     oldCap >= DEFAULT_INITIAL_CAPACITY)
                newThr = oldThr << 1; // double threshold
        }
        else if (oldThr > 0) // initial capacity was placed in threshold
            newCap = oldThr;
        else {               // zero initial threshold signifies using defaults
            newCap = DEFAULT_INITIAL_CAPACITY;
            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
        }
        if (newThr == 0) {
            float ft = (float)newCap * loadFactor;
            newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?
                      (int)ft : Integer.MAX_VALUE);
        }
        
        // threshold = 24
        threshold = newThr;
        @SuppressWarnings({"rawtypes","unchecked"})
        // 32长度的数组
            Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];
        table = newTab;
        
        
        // 代码到这一句, 已经有新数组, 
        // 把旧数组数据转移到新数组
        
        if (oldTab != null) {
            // 遍历旧数组, j 表示数组下标
            for (int j = 0; j < oldCap; ++j) {
                Node<K,V> e;
                
                
                if ((e = oldTab[j]) != null) {
                    oldTab[j] = null;
                    if (e.next == null)
                        newTab[e.hash & (newCap - 1)] = e;
                    else if (e instanceof TreeNode)
                        // 如果遍历的某一个结点是红黑树结点, (拆成两部分)
                        ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);
                    else { // preserve order
                        Node<K,V> loHead = null, loTail = null;
                        Node<K,V> hiHead = null, hiTail = null;
                        Node<K,V> next;
                        do {
                            next = e.next;
                            if ((e.hash & oldCap) == 0) {
                                if (loTail == null)
                                    loHead = e;
                                else
                                    loTail.next = e;
                                loTail = e;
                            }
                            else {
                                if (hiTail == null)
                                    hiHead = e;
                                else
                                    hiTail.next = e;
                                hiTail = e;
                            }
                        } while ((e = next) != null);
                        if (loTail != null) {
                            loTail.next = null;
                            newTab[j] = loHead;
                        }
                        if (hiTail != null) {
                            hiTail.next = null;
                            newTab[j + oldCap] = hiHead;
                        }
                    }
                }
            }
        }
        return newTab;
    }
    
     // this, newTab, j, oldCap
         ///                  此对象           新数组      红黑树在数组的下标     旧数组长度
        final void split(HashMap<K,V> map, Node<K,V>[] tab, int index, int bit) {
            TreeNode<K,V> b = this;
            // Relink into lo and hi lists, preserving order
            TreeNode<K,V> loHead = null, loTail = null;
            TreeNode<K,V> hiHead = null, hiTail = null;
            int lc = 0, hc = 0;
            for (TreeNode<K,V> e = b, next; e != null; e = next) {
                // 
                next = (TreeNode<K,V>)e.next;
                e.next = null;
                if ((e.hash & bit) == 0) {// 旧位置
                    if ((e.prev = loTail) == null)
                        loHead = e;
                    else
                        loTail.next = e;
                    loTail = e;
                    ++lc;// 标记旧位置存储了几个元素
                }
                else {//  新位置
                    if ((e.prev = hiTail) == null)
                        hiHead = e;
                    else
                        hiTail.next = e;
                    hiTail = e;
                    ++hc;// 标记新位置存储了几个元素
                }
            }
            
            //     static final int UNTREEIFY_THRESHOLD = 6;

            if (loHead != null) {
                
                // 小于等于6 -> 由红黑树转化为链表
                if (lc <= UNTREEIFY_THRESHOLD)
                    // untreeify 反树化操作, 由红黑树转化为链表
                    tab[index] = loHead.untreeify(map);
                else {
                    tab[index] = loHead;
                    if (hiHead != null) // (else is already treeified)
                        loHead.treeify(tab);
                }
            }
            if (hiHead != null) {
                if (hc <= UNTREEIFY_THRESHOLD)
                    tab[index + bit] = hiHead.untreeify(map);
                else {
                    tab[index + bit] = hiHead;
                    if (loHead != null)
                        hiHead.treeify(tab);
                }
            }
        }

 static class Node<K,V> implements Map.Entry<K,V> {
        final int hash;
        final K key;
        V value;
        Node<K,V> next;
 }
    
     static class Entry<K,V> extends HashMap.Node<K,V> {
        Entry<K,V> before, after;
        Entry(int hash, K key, V value, Node<K,V> next) {
            super(hash, key, value, next);
        }
    }
    static final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V> {
        TreeNode<K,V> parent;  // red-black tree links
        TreeNode<K,V> left;
        TreeNode<K,V> right;
        TreeNode<K,V> prev;    // needed to unlink next upon deletion
        boolean red;
    }
    
}
```



### HashMap源码分析:删除时由红黑树转化为链表

```java
        HashMap<String, Integer> map = new HashMap<>(10, 0.9f);
        map.put("zs", 18);
        map.put("ls", 18);

        map.remove("zs");
```

```java
class HashMap{
    
     public V remove(Object key) {
        Node<K,V> e;
        return (e = removeNode(hash(key), key, null, false, true)) == null ?
            null : e.value;
    }
    
    final Node<K,V> removeNode(int hash, Object key, Object value,
                               boolean matchValue, boolean movable) {
        Node<K,V>[] tab; Node<K,V> p; int n, index;
        if ((tab = table) != null && (n = tab.length) > 0 &&
            (p = tab[index = (n - 1) & hash]) != null) {
            Node<K,V> node = null, e; K k; V v;
            if (p.hash == hash &&
                ((k = p.key) == key || (key != null && key.equals(k))))
                node = p;
            else if ((e = p.next) != null) {
                if (p instanceof TreeNode)
                    // 删除的是一个树结点
                    
                    // 先获得要删除的树结点
                    node = ((TreeNode<K,V>)p).getTreeNode(hash, key);
                else {
                    do {
                        if (e.hash == hash &&
                            ((k = e.key) == key ||
                             (key != null && key.equals(k)))) {
                            node = e;
                            break;
                        }
                        p = e;
                    } while ((e = e.next) != null);
                }
            }
            if (node != null && (!matchValue || (v = node.value) == value ||
                                 (value != null && value.equals(v)))) {
                if (node instanceof TreeNode)
                    // 把获得的树结点删除node
                    ((TreeNode<K,V>)node).removeTreeNode(this, tab, movable);
                
                
                else if (node == p)
                    tab[index] = node.next;
                else
                    p.next = node.next;
                ++modCount;
                --size;
                afterNodeRemoval(node);
                return node;
            }
        }
        return null;
    }
    
    final void removeTreeNode(HashMap<K,V> map, Node<K,V>[] tab,
                                  boolean movable) {
            int n;
            if (tab == null || (n = tab.length) == 0)
                return;
            int index = (n - 1) & hash;
            TreeNode<K,V> first = (TreeNode<K,V>)tab[index], root = first, rl;
            TreeNode<K,V> succ = (TreeNode<K,V>)next, pred = prev;
            if (pred == null)
                tab[index] = first = succ;
            else
                pred.next = succ;
            if (succ != null)
                succ.prev = pred;
            if (first == null)
                return;
            if (root.parent != null)
                // 获得这个红黑树的根节点
                root = root.root();
            if (root == null || root.right == null ||
                (rl = root.left) == null || rl.left == null) {
                // untreeify : 反树化操作: 由红黑树转化为链表
                tab[index] = first.untreeify(map);  // too small
                return;
            }
            TreeNode<K,V> p = this, pl = left, pr = right, replacement;
            if (pl != null && pr != null) {
                TreeNode<K,V> s = pr, sl;
                while ((sl = s.left) != null) // find successor
                    s = sl;
                boolean c = s.red; s.red = p.red; p.red = c; // swap colors
                TreeNode<K,V> sr = s.right;
                TreeNode<K,V> pp = p.parent;
                if (s == pr) { // p was s's direct parent
                    p.parent = s;
                    s.right = p;
                }
                else {
                    TreeNode<K,V> sp = s.parent;
                    if ((p.parent = sp) != null) {
                        if (s == sp.left)
                            sp.left = p;
                        else
                            sp.right = p;
                    }
                    if ((s.right = pr) != null)
                        pr.parent = s;
                }
                p.left = null;
                if ((p.right = sr) != null)
                    sr.parent = p;
                if ((s.left = pl) != null)
                    pl.parent = s;
                if ((s.parent = pp) == null)
                    root = s;
                else if (p == pp.left)
                    pp.left = s;
                else
                    pp.right = s;
                if (sr != null)
                    replacement = sr;
                else
                    replacement = p;
            }
            else if (pl != null)
                replacement = pl;
            else if (pr != null)
                replacement = pr;
            else
                replacement = p;
            if (replacement != p) {
                TreeNode<K,V> pp = replacement.parent = p.parent;
                if (pp == null)
                    root = replacement;
                else if (p == pp.left)
                    pp.left = replacement;
                else
                    pp.right = replacement;
                p.left = p.right = p.parent = null;
            }

            TreeNode<K,V> r = p.red ? root : balanceDeletion(root, replacement);

            if (replacement == p) {  // detach
                TreeNode<K,V> pp = p.parent;
                p.parent = null;
                if (pp != null) {
                    if (p == pp.left)
                        pp.left = null;
                    else if (p == pp.right)
                        pp.right = null;
                }
            }
            if (movable)
                moveRootToFront(tab, r);
        }


    
}
```











## LinkedHashMap概述

- HashMap的子类

- Map 接口的哈希表和链表实现，具有可预知的迭代顺序.

- 链表定义了迭代顺序，该迭代顺序就是键值对的插入顺序。

- 不同步。



概述

1. LinkedHashMap 是HashMap的一个子类

2. LinkedHashMap 基本上完全复用了HashMap的参数结构方法(数组+链表+红黑树)

3. LinkedHashMap的特点基本遵从于Hashmap

4. LinkedHashMap在HashMap的基础上额外维护了一个双向链表(保存顺序)

5. LinkedHashMap是有序的

6. `//LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder)`

   `//构造一个带指定初始容量、加载因子和'排序模式'的空 LinkedHashMap 实例。`

   默认值是假, 如果设为真,
   如果在排序模式为真的情况下, 一旦我们访问了LinkedHashMap中的数据, 那么这个被访问的数据, 就会在LinkedhashMap所维护的双向链表上移动到最后的位置



| 构造方法摘要                                                 |
| ------------------------------------------------------------ |
| LinkedHashMap()         构造一个带默认初始容量  (16) 和加载因子 (0.75) 的空插入顺序 LinkedHashMap 实例。 |
| LinkedHashMap(int initialCapacity)         构造一个带指定初始容量和默认加载因子 (0.75) 的空插入顺序 LinkedHashMap 实例。 |
| LinkedHashMap(int initialCapacity,  float loadFactor)         构造一个带指定初始容量和加载因子的空插入顺序 LinkedHashMap 实例。 |
| LinkedHashMap(int initialCapacity,  float loadFactor, boolean accessOrder)         构造一个带指定初始容量、加载因子和排序模式的空 LinkedHashMap 实例。 |
| LinkedHashMap(Map<? extendsK,? extendsV> m)         构造一个映射关系与指定映射相同的插入顺序 LinkedHashMap 实例。 |



**Api**

Api基本是复用HashMap实现的方法

| void    | clear()         从该映射中移除所有映射关系。                 |
| ------- | ------------------------------------------------------------ |
| boolean | containsValue(Objectvalue)         如果此映射将一个或多个键映射到指定值，则返回 true。 |
| V       | get(Objectkey)         返回此映射到指定键的值。              |



### LinkedHashMap源码分析:双向链表2

```java
 LinkedHashMap<String, Integer> map = new LinkedHashMap<>();
 map.put("zs", 18);

```

```java
class LinkedHashMap extends HashMap{
    // 创建的到底是一个什么结点类型
     Node<K,V> newNode(int hash, K key, V value, Node<K,V> e) {
        LinkedHashMap.Entry<K,V> p = new LinkedHashMap.Entry<K,V>(hash, key, value, e);
        linkNodeLast(p);
        return p;
    }
    
    
     static class Entry<K,V> extends HashMap.Node<K,V> {
        Entry<K,V> before, after;
        Entry(int hash, K key, V value, Node<K,V> next) {
            super(hash, key, value, next);
        }
    }
}
class HashMap{
    
     static class Node<K,V> implements Map.Entry<K,V> {
        final int hash;
        final K key;
        V value;
        Node<K,V> next;
         
     }
    
    public V put(K key, V value) {
        return putVal(hash(key), key, value, false, true);
    }
    
    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
        Node<K,V>[] tab; Node<K,V> p; int n, i;
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
        if ((p = tab[i = (n - 1) & hash]) == null)
            tab[i] = newNode(hash, key, value, null);
        else {
            Node<K,V> e; K k;
            if (p.hash == hash &&
                ((k = p.key) == key || (key != null && key.equals(k))))
                e = p;
            else if (p instanceof TreeNode)
                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
            else {
                for (int binCount = 0; ; ++binCount) {
                    if ((e = p.next) == null) {
                        p.next = newNode(hash, key, value, null);
                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash);
                        break;
                    }
                    if (e.hash == hash &&
                        ((k = e.key) == key || (key != null && key.equals(k))))
                        break;
                    p = e;
                }
            }
            if (e != null) { // existing mapping for key
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);
                return oldValue;
            }
        }
        ++modCount;
        if (++size > threshold)
            resize();
        afterNodeInsertion(evict);
        return null;
    }

    
}
```



### LinkedHashMap源码分析: toString方法遍历

```java
        LinkedHashMap<String, Integer> map = new LinkedHashMap<>();
        map.put("zs", 18);
        map.put("ls", 18);
        map.put("wu", 18);
        map.put("zl", 18);

        System.out.println(map);// {zs=18, ls=18, wu=18, zl=18}

// 位运算 , 最有路径. 
```

```java
class LinkedhashMap{
    
   public Set<Map.Entry<K,V>> entrySet() {
        Set<Map.Entry<K,V>> es;
        return (es = entrySet) == null ? (entrySet = new LinkedEntrySet()) : es;
    }
    
    
    final class LinkedEntrySet extends AbstractSet<Map.Entry<K,V>> {
        public final int size()                 { return size; }
        public final void clear()               { LinkedHashMap.this.clear(); }
        public final Iterator<Map.Entry<K,V>> iterator() {
            return new LinkedEntryIterator();
        }
        public final boolean contains(Object o) {
            if (!(o instanceof Map.Entry))
                return false;
            Map.Entry<?,?> e = (Map.Entry<?,?>) o;
            Object key = e.getKey();
            Node<K,V> candidate = getNode(hash(key), key);
            return candidate != null && candidate.equals(e);
        }
        public final boolean remove(Object o) {
            if (o instanceof Map.Entry) {
                Map.Entry<?,?> e = (Map.Entry<?,?>) o;
                Object key = e.getKey();
                Object value = e.getValue();
                return removeNode(hash(key), key, value, true, true) != null;
            }
            return false;
        }
        public final Spliterator<Map.Entry<K,V>> spliterator() {
            return Spliterators.spliterator(this, Spliterator.SIZED |
                                            Spliterator.ORDERED |
                                            Spliterator.DISTINCT);
        }
        public final void forEach(Consumer<? super Map.Entry<K,V>> action) {
            if (action == null)
                throw new NullPointerException();
            int mc = modCount;
            for (LinkedHashMap.Entry<K,V> e = head; e != null; e = e.after)
                action.accept(e);
            if (modCount != mc)
                throw new ConcurrentModificationException();
        }
    }
    
     final class LinkedEntryIterator extends LinkedHashIterator
        implements Iterator<Map.Entry<K,V>> {
        public final Map.Entry<K,V> next() { return nextNode(); }
    }
    
    abstract class LinkedHashIterator {
        LinkedHashMap.Entry<K,V> next;
        LinkedHashMap.Entry<K,V> current;
        int expectedModCount;

        LinkedHashIterator() {
            next = head;
            expectedModCount = modCount;
            current = null;
        }

        public final boolean hasNext() {
            return next != null;
        }

        final LinkedHashMap.Entry<K,V> nextNode() {
            LinkedHashMap.Entry<K,V> e = next;
            if (modCount != expectedModCount)
                throw new ConcurrentModificationException();
            if (e == null)
                throw new NoSuchElementException();
            current = e;
            // 核心代码
            next = e.after;
            return e;
        }

        public final void remove() {
            Node<K,V> p = current;
            if (p == null)
                throw new IllegalStateException();
            if (modCount != expectedModCount)
                throw new ConcurrentModificationException();
            current = null;
            K key = p.key;
            removeNode(hash(key), key, null, false, false);
            expectedModCount = modCount;
        }
    }
}

class HashMap{
    
}

abstract class AbstractMap{
    

    public String toString() {
            Iterator<Entry<K,V>> i = entrySet().iterator();
            if (! i.hasNext())
                return "{}";

            StringBuilder sb = new StringBuilder();
            sb.append('{');
            for (;;) {
                Entry<K,V> e = i.next();
                K key = e.getKey();
                V value = e.getValue();
                sb.append(key   == this ? "(this Map)" : key);
                sb.append('=');
                sb.append(value == this ? "(this Map)" : value);
                if (! i.hasNext())
                    return sb.append('}').toString();
                sb.append(',').append(' ');
            }
        }
    
}

```





## TreeMap概述

- 底层的数据结构是红黑树。

- 如果创建对象时，没有传入 Comparator 对象，键将按自然顺序进行排序。

- 如果创建对象时，传入了 Comparator 对象，键将按 Comparator 进行排序。

- 不同步

除了Map接口中定义的方法外，由于TreeMap中的键是大小有序的，因此它还有一些特殊的方法。

- K firstKey()

- K lastKey()

- Map.Entry<K, V> pollFirstEntry();

- Map.Entry<K,V> pollLastEntry();

- K floorKey(K key)

- K ceilingKey(K key)

- K lowerKey(K key)

- K higherKey(K key)

- NavigableMap<K, V> submap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive )



## Properties概述

- Hashtable<Object, Object> 的子类

- Properties 类表示了一个可持久的属性集。

- Properties 可保存在流中或从流中加载。

- Properties 中每个键及其对应值都是一个字符串。

**注意事项：**

- 不要使用Hashtable里面定义的方法添加键值对！因为它们可以插入不是String 类型的数据。

- 如果一个Properties中含有非String的键值对，那么这样的Properties是”不安全”的。调用 store 或者 save 方法将失败。

> 1)底层hash表
> 2)Hashtable 中的方法是Synchronize的, 同步方法
> 不允许null键和值
> 初始长度11 (hashmap初始长度16)
> hashtable扩容是2倍+ 1 (hashmap扩容 2倍)
> Hash值计算不同
> 无红黑树

Properties 的 API:

- String getProperty(String key)

- String getProperty(String key, String defaultValue)

- Object setProperty(String key, String value)

- Set<String> stringPropertyNames();

- void store(OutputStream out, String comments)

- void store(Writer out, String comments)

- void load(InputStream inStream)

- void load(Reader read)

**注意事项：**

- 字节流默认使用 ISO 8859-1 字符编码。



练习：

1. "aababcabcdabcde",获取字符串中每一个字母出现的次数要求结果:a(5)b(4)c(3)d(2)e(1)

2. 给定一个整数数组和一个目标值，找出数组中和为目标值的两个数, 返回它们的索引。
   你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。

比如：nums = [2, 7, 11, 15], target = 9.  
             因为 nums[0] + nums[1] = 2 + 7 = 9. 所以返回 [0, 1].

3. 请设计一个猜数字小游戏，可以试玩5次。试玩结束之后，给出提示：游戏试玩结束，
     请付费。



# Set

概述

一个不包含重复元素的 collection。更确切地讲, set 不包含满足 e1.equals(e2) 的元素对 e1 和 e2, 并且最多包含一个 null 元素。正如其名称所暗示的，此接口模仿了数学上的 set 抽象。

注意事项：Set 集合并不一定都是无序的，有些 Set 集合是有序的。

1.  Set这个接口 Collection的子接口(集合)
2. Set有些子实现有序(LinkedHashSet, TreeSet), 有些子实现无序(HashSet)
3. 有些子实现不允许存储null值(TreeSet), 有些子实现允许存储null值(HashSet, LinkedHashSet)
4. 不允许存储重复元素( ) 

**Api**

| boolean   | add(E e)         如果 set 中尚未存在指定的元素，则添加此元素（可选操作）。 |
| --------- | ------------------------------------------------------------ |
| boolean   | addAll(Collection<? extends E> c)         如果 set 中没有指定 collection 中的所有元素，则将其添加到此 set 中（可选操作）。 |
| void      | clear()         移除此 set 中的所有元素（可选操作）。        |
| boolean   | contains(Object o)         如果 set 包含指定的元素，则返回 true。 |
| boolean   | containsAll(Collection<?> c)         如果此 set 包含指定 collection 的所有元素，则返回 true。 |
| boolean   | equals(Object o)         比较指定对象与此 set 的相等性。     |
| int       | hashCode()         返回 set 的哈希码值。                     |
| boolean   | isEmpty()         如果 set 不包含元素，则返回 true。         |
| IteratorE | iterator()         返回在此 set 中的元素上进行迭代的迭代器。 |
| boolean   | remove(Object o)         如果 set 中存在指定的元素，则将其移除（可选操作）。 |
| boolean   | removeAll(Collection<?> c)         移除 set 中那些包含在指定 collection 中的元素（可选操作）。 |
| boolean   | retainAll(Collection<?> c)         仅保留 set 中那些包含在指定 collection 中的元素（可选操作）。 |
| int       | size()         返回 set 中的元素数（其容量）。               |
| Object[]  | toArray()         返回一个包含 set 中所有元素的数组。        |
| <T> T[]   | toArray(T[] a)         返回一个包含此 set 中所有元素的数组；返回数组的运行时类型是指定数组的类型。 |





## HashSet

概述

- 底层是HashMap

- 它不保证迭代顺序，特别是它不保证该顺序恒久不变 (无序的)。

- 允许存储 null 元素。

- 不同步



1.  HashSet是Set的一个子实现
2.  HashSet底层持有一个HashMap对象(数组+链表+红黑树)
3. HashSet存储元素的特点基本上遵从于HashMap的存储key的特点
4. 无序
5. 不允许重复:  什么是重复(元素hash值一样, 并且, 两个元素知否直接相等或者相equals)
6. 允许null
7. 线程不安全



HashSet 是如何保证元素的唯一性的呢？（Set 存储的元素是作为 Map 的 key，而Map的key是唯一的）

- 查看源码 
- 它依赖于存储元素的两个方法: int hashCode() & boolean equals(Object obj)

<font color=red>注意事项：千万不要修改 HashSet 元素的属性值!</font>



**构造方法**

| HashSet()         构造一个新的空 set，其底层 HashMap 实例的默认初始容量是 16，加载因子是 0.75。 |
| ------------------------------------------------------------ |
| HashSet(Collection<? extends E> c)         构造一个包含指定  collection 中的元素的新 set。 |
| HashSet(int initialCapacity)         构造一个新的空 set，其底层 HashMap 实例具有指定的初始容量和默认的加载因子（0.75）。 |
| HashSet(int initialCapacity,  float loadFactor)         构造一个新的空 set，其底层 HashMap 实例具有指定的初始容量和指定的加载因子。 |



**Api**

| boolean   | add(E e)         如果此 set 中尚未包含指定元素，则添加指定元素。 |
| --------- | ------------------------------------------------------------ |
| void      | clear()         从此 set 中移除所有元素。                    |
| Object    | clone()         返回此 HashSet 实例的浅表副本：并没有复制这些元素本身。 |
| boolean   | contains(Object o)         如果此 set 包含指定元素，则返回 true。 |
| boolean   | isEmpty()         如果此 set 不包含任何元素，则返回 true。   |
| IteratorE | iterator()         返回对此 set 中元素进行迭代的迭代器。     |
| boolean   | remove(Object o)         如果指定元素存在于此  set 中，则将其移除。 |
| int       | size()         返回此 set 中的元素的数量（set 的容量）。     |



### HashSet源码分析

```java
//        1, HashSet是Set的一个子实现
//        2, HashSet底层持有一个HashMap对象(数组+链表+红黑树)
//        3, HashSet存储元素的特点基本上遵从于HashMap的存储key的特点
//        4, 无序
//        5, 不允许重复
//        6, 允许null
//        7, 线程不安全
        HashSet<String> set = new HashSet<>();
        set.add("zs");
 		set.add("ls");
```

```java
class HashSet{
    private transient HashMap<E,Object> map;
    
     // Dummy value to associate with an Object in the backing Map
    // 哑变量:  没有什么特殊作用, 就是单纯的用来填充value(key-value)
    private static final Object PRESENT = new Object();
    
    public HashSet() {
        map = new HashMap<>();
    }
     public HashSet(int initialCapacity) {
        map = new HashMap<>(initialCapacity);
    }

    
    public boolean add(E e) {
        return map.put(e, PRESENT)==null;
    }
    
}
```





## LinkedHashSet

概述

- HashSet 的子类

- 底层是HashMap & 双向链表

- HashMap 保证了元素的唯一性。

- 链表定义了迭代的顺序，按照元素的插入顺序进行迭代。

- 不同步。



1. 他是HashSet的一个子类
2. 底层持有一个LinkedHashMap
3.  基本特点遵从, HashSet, LinkedHashMap
4. 有序
5. 允许null
6. 不允许重复
7. 线程不安全
8. 底层持有一个LinkedHashMap -> 拥有一个双向链表



| 构造方法摘要                                                 |
| ------------------------------------------------------------ |
| LinkedHashSet()         构造一个带默认初始容量  (16) 和加载因子 (0.75) 的新空链接哈希 set。 |
| LinkedHashSet(Collection<? extends E> c)         构造一个与指定  collection 中的元素相同的新链接哈希 set。 |
| LinkedHashSet(int initialCapacity)         构造一个带指定初始容量和默认加载因子 (0.75) 的新空链接哈希 set。 |
| LinkedHashSet(int initialCapacity,  float loadFactor)         构造一个带有指定初始容量和加载因子的新空链接哈希 set。 |



**Api**

是复用父类(HashSet)的api, 自己并没有定义特殊api



理解一下: HashMap  , HashSet, LinkedHashMap, LinkedHashSet 之间的关系

### LinkedHashSet源码分析:在set和map圈的关系

```java
  LinkedHashSet<String> set = new LinkedHashSet<>();
        set.add("zs");
```

```java
class LinkedHashSet{
    
     public LinkedHashSet() {
        super(16, .75f, true);
    }

    
}

class HashSet{
    
    private transient HashMap<E,Object> map;
    
    HashSet(int initialCapacity, float loadFactor, boolean dummy) {
        map = new LinkedHashMap<>(initialCapacity, loadFactor);
    }
   
    
}

class LinkedHashMap{
     public LinkedHashMap(int initialCapacity, float loadFactor) {
        super(initialCapacity, loadFactor);
        accessOrder = false;
    }
    
}

class HashMap{
    
    public HashMap(int initialCapacity, float loadFactor) {
        if (initialCapacity < 0)
            throw new IllegalArgumentException("Illegal initial capacity: " +
                                               initialCapacity);
        if (initialCapacity > MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        if (loadFactor <= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException("Illegal load factor: " +
                                               loadFactor);
        this.loadFactor = loadFactor;
        this.threshold = tableSizeFor(initialCapacity);
    }
}

```



```java
class LinkedHashSet{
    
    private transient HashMap<E,Object> map;
    
    HashSet(int initialCapacity, float loadFactor, boolean dummy) {
        map = new LinkedHashMap<>(initialCapacity, loadFactor);
    }
     public LinkedHashSet() {
        this(16, .75f, true);
    }

    
}


class LinkedHashMap{
    
      
    public HashMap(int initialCapacity, float loadFactor) {
        if (initialCapacity < 0)
            throw new IllegalArgumentException("Illegal initial capacity: " +
                                               initialCapacity);
        if (initialCapacity > MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        if (loadFactor <= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException("Illegal load factor: " +
                                               loadFactor);
        this.loadFactor = loadFactor;
        this.threshold = tableSizeFor(initialCapacity);
    }
    
     public LinkedHashMap(int initialCapacity, float loadFactor) {
        this(initialCapacity, loadFactor);
        accessOrder = false;
    }
    
}


```





## TreeSet

概述

- 底层的数据结构是 TreeMap, TreeMap的底层是红黑树。

- 如果创建对象时，没有传入 Comparator 对象，则根据自然顺序进行排序。
- 如果创建对象时，传入了 Comparator 对象，则根据 Comparator 进行排序。
- 不能存储 null 元素，除非在Comparator中定义的null的比较规则
- 不同步



1. 是Set接口的一个具体(树)实现
2. 它的底层持有一个TreeMap对象
3. 存到TreeSet里面的元素, 相当于存储到TreeMap里面的key
4. TreeSet的基本特点基本遵从于TreeMap的key
5. 大小有序
6. 不允许null
7. 不允许重复(自然顺序: )
8. 线程不安全



TreeSet 是如何保证元素的唯一性的呢？

- 查看源码 

- 它依赖于存储元素的 compareTo(obj) 方法，或者是传入的 Comparator 对象的 compare(o1, o2) 方法

<font color=red>注意事项：千万不要修改 TreeSet 元素的属性值!</font>



**构造方法**

| TreeSet()         构造一个新的空 set，该 set 根据其元素的自然顺序进行排序。 |
| ------------------------------------------------------------ |
| TreeSet(Collection<? extends E> c)         构造一个包含指定  collection 元素的新 TreeSet，它按照其元素的自然顺序进行排序。 |
| TreeSet(Comparator<? super E> comparator)          构造一个新的空  TreeSet，它根据指定比较器进行排序。 |
| TreeSet(SortedSetE s)         构造一个与指定有序 set  具有相同映射关系和相同排序的新 TreeSet。 |



**Api**

除Set接口中定义的方法外，由于TreeSet 中的元素是大小有序的，因此它还有一些特殊的方法。

| boolean               | add(E e)         将指定的元素添加到此 set（如果该元素尚未存在于 set 中）。 |
| --------------------- | ------------------------------------------------------------ |
| boolean               | addAll(Collection<? extends E> c)         将指定  collection 中的所有元素添加到此 set 中。 |
| E                     | ceiling(E e)         返回此 set 中大于等于给定元素的最小元素；如果不存在这样的元素，则返回 null。 |
| void                  | clear()         移除此 set 中的所有元素。                    |
| Object                | clone()         返回 TreeSet 实例的浅表副本。                |
| Comparator<? super E> | comparator()         返回对此 set 中的元素进行排序的比较器；如果此 set 使用其元素的自然顺序，则返回 null。 |
| boolean               | contains(Object o)         如果此 set 包含指定的元素，则返回 true。 |
| IteratorE             | descendingIterator()         返回在此 set 元素上按降序进行迭代的迭代器。 |
| NavigableSetE         | descendingSet()         返回此 set 中所包含元素的逆序视图。  |
| E                     | first()         返回此 set 中当前第一个（最低）元素。        |
| E                     | floor(E e)         返回此 set 中小于等于给定元素的最大元素；如果不存在这样的元素，则返回 null。 |
| SortedSetE            | headSet(E toElement)         返回此 set 的部分视图，其元素严格小于 toElement。 |
| NavigableSetE         | headSet(E toElement,  boolean inclusive)         返回此 set 的部分视图，其元素小于（或等于，如果 inclusive 为 true）toElement。 |
| E                     | higher(E e)         返回此 set 中严格大于给定元素的最小元素；如果不存在这样的元素，则返回 null。 |
| boolean               | isEmpty()         如果此 set 不包含任何元素，则返回 true。   |
| IteratorE             | iterator()         返回在此 set 中的元素上按升序进行迭代的迭代器。 |
| E                     | last()         返回此 set 中当前最后一个（最高）元素。       |
| E                     | lower(E e)         返回此 set 中严格小于给定元素的最大元素；如果不存在这样的元素，则返回 null。 |
| E                     | pollFirst()         获取并移除第一个（最低）元素；如果此 set 为空，则返回 null。 |
| E                     | pollLast()         获取并移除最后一个（最高）元素；如果此 set 为空，则返回 null。 |
| boolean               | remove(Object o)         将指定的元素从 set 中移除（如果该元素存在于此 set 中）。 |
| int                   | size()         返回 set 中的元素数（set 的容量）。           |
| NavigableSetE         | subSet(E fromElement,  boolean fromInclusive, E toElement,  boolean toInclusive)         返回此 set 的部分视图，其元素范围从 fromElement 到 toElement。 |
| SortedSetE            | subSet(E fromElement,  E toElement)         返回此 set 的部分视图，其元素从 fromElement（包括）到 toElement（不包括）。 |
| SortedSetE            | tailSet(E fromElement)          返回此 set 的部分视图，其元素大于等于 fromElement。 |
| NavigableSetE         | tailSet(E fromElement,  boolean inclusive)         返回此 set 的部分视图，其元素大于（或等于，如果 inclusive 为 true）fromElement。 |







