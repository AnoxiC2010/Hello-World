# ③Java语法基础

[TOC]



## 1. 关键字和保留字

> 学习Java的第一步是要认识关键字和保留字



### 1.1 关键字（KeyWord）

> 什么是关键字？关键字有什么特点？

- 关键字是被Java语法赋予特定含义的单词

- 关键字都是合法的单词，**必须全部小写**



> 关键字有什么作用？

- 关键字对编译器有特殊意义（影响编译）
- 他们用来表示一种数据类型或者表示程序的结构



### 1.2 保留字（ReserveWord）

> 什么是保留字？保留字有什么作用

- 保留字是对当前版本的Java，并没有特殊含义的单词

- 但是以后的版本中，Java官方可能会将其变成具有特殊含义的单词，升级为关键字

- 即便以后也不打算升级为关键字，但是Java官方认为你不应该在Java代码中使用的单词，也会变成保留字

  

> 有哪些保留字？
>
> Java目前有且仅有两个保留字

- const
- goto



### 1.3 关键字和保留字的语法意义

> 关键字和保留字对Java程序有显著影响

- **关键字和保留字均不能用作变量名、方法名、类名、包名和参数**
- 由于大家使用比较高级的集成开发环境，关键字是有特殊颜色标记的



> 课堂抽奖

以下哪些是关键字（保留字）？

class，HelloWorld，public，static，Const，void，main，String，System，goto





### 1.4 Java关键字大全

| 关键字                       | 含义                                                         |
| ---------------------------- | ------------------------------------------------------------ |
| abstract                     | 表明类或者成员方法具有抽象属性                               |
| assert                       | 用来进行程序调试                                             |
| boolean                      | 基本数据类型之一，布尔类型                                   |
| break                        | 提前跳出一个块                                               |
| byte                         | 基本数据类型之一，字节类型                                   |
| case                         | 用在switch语句之中，表示其中的一个分支                       |
| catch                        | 用在异常处理中，用来捕捉异常                                 |
| char                         | 基本数据类型之一，字符类型                                   |
| class                        | 类                                                           |
| <font color=red>const</font> | 保留关键字，没有具体含义                                     |
| continue                     | 回到一个块的开始处                                           |
| default                      | 默认，例如，用在switch语句中，表明一个默认的分支             |
| do                           | 用在do-while循环结构中                                       |
| double                       | 基本数据类型之一，双精度浮点数类型                           |
| else                         | 用在条件语句中，表明当条件不成立时的分支                     |
| enum                         | 枚举                                                         |
| extends                      | 表明一个类型是另一个类型的子类型，这里常见的类型有类和接口   |
| final                        | 用来说明最终属性，表明一个类不能派生出子类，或者成员方法不能被覆盖，或者成员域的值不能被改变，用来定义常量 |
| finally                      | 用于处理异常情况，用来声明一个基本肯定会被执行到的语句块     |
| float                        | 基本数据类型之一，单精度浮点数类型                           |
| for                          | 一种循环结构的引导词                                         |
| <font color=red>goto</font>  | 保留关键字，没有具体含义                                     |
| if                           | 条件语句的引导词                                             |
| implements                   | 表明一个类实现了给定的接口                                   |
| import                       | 表明要访问指定的类或包                                       |
| instanceof                   | 用来测试一个对象是否是指定类型的实例对象                     |
| int                          | 基本数据类型之一，整数类型                                   |
| interface                    | 接口                                                         |
| long                         | 基本数据类型之一，长整数类型                                 |
| native                       | 用来声明一个方法是由与计算机相关的语言(如C/C++/FORTRAN语言)实现的 |
| new                          | 用来创建新实例对象                                           |
| package                      | 包                                                           |
| private                      | 一种访问控制方式：私用模式                                   |
| protected                    | 一种访问控制方式：保护模式                                   |
| public                       | 一种访问控制方式：共用模式                                   |
| return                       | 从成员方法中返回数据                                         |
| short                        | 基本数据类型之一，短整数类型                                 |
| static                       | 表明具有静态属性                                             |
| strictfp                     | 用来声明FP_strict(单精度或双精度浮点数)表达式遵循IEEE 754算术规范 |
| super                        | 表明当前对象的父类型的引用或者父类型的构造方法               |
| switch                       | 分支语句结构的引导词                                         |
| synchronized                 | 表明一段代码需要同步执行                                     |
| this                         | 指向当前实例对象的引用                                       |
| throw                        | 抛出一个异常                                                 |
| throws                       | 声明在当前定义的成员方法中所有需要抛出的异常                 |
| transient                    | 声明不用序列化的成员域                                       |
| try                          | 尝试一个可能抛出异常的程序块                                 |
| void                         | 声明当前成员方法没有返回值                                   |
| volatile                     | 表明两个或者多个变量必须同步地发生变化                       |
| while                        | 用在循环结构中                                               |



## 2. 标识符（Identifier）

> 什么是标识符？标识符有什么用？

- 标识符是给包，类，接口，方法，变量等起名字时使用的字符序列
- 标识符就是起名字时用的字符串



### 2.1 虚假的标识符命名规则（语法）

> 语法上要求的标识符的规则是什么？

- 标识符的组成
  - 数字（0~9）
  - 字母（A~Z 和 a~z）
  - 美元符号（$）
  - 下划线（_）
  - Unicode 字符集中符号大于0xC0的所有符号
- 标识符的开头
  - 字母（A~Z 和 a~z）
  - 下划线（_）
  - 美元符号（$）
  - Unicode 字符集中符号大于 0xC0 的所有符号
- 注意事项
  - 标识符不能以数字开头
  - 不能是Java中的关键字和保留字
  - 标识符区分大小写



> 课堂抽奖

以下标识符命名合法的有哪些？

HelloWorld，_985，$bS5_c7，class，长风，Class ，DataClass#，98.3，Hello  World，好きだ





### 2.2 真实的标识符组成规则（基于语法的约定）

以上只是语法范畴的标识符规则，但就像人可以起名叫“张三，李四”，但几乎没人这么做一样

<font color=red>在符合语法的前提下</font>，标识符还有一套约定俗成的命名规则，详见《阿里巴巴Java开发规范》

> 真实的标识符组成规则

- 符合语法
- **只能用英文字母、数字（下划线特殊场景使用并且不能作为开头，美元符号几乎不使用）**
- 包命名标识符
  - Java中的包类似操作系统中的文件夹
    - 包用来区分同名Java文件
    - 包用来区分访问权限
  - 包的命名，以反转公司域名为规范
  - 包名应该全部小写
  - 多级包名以点（.）分隔
- 类、接口等命名标识符
  - 大驼峰命名法
- 变量、方法的命名标识符
  - 小驼峰命名法
- 常量的命名标识符
  - 全部大写（建议）
  - 多个单词之间用下划线（_）隔开



> **为了方便大家后续看代码，我会给包名前加序号表示我们上课的顺序，但是大家开发中不要这么做**



> 给人起名字也追求好听吉祥，标识符起名也有自己的追求

- 核心追求是“见名知意”，应该赋予标识符一个有意义、有用途的名字
- 标识符的命名规范，可以从源码、大神的代码中学习，也是一个逐渐积累的过程





> 课堂抽奖
>
> 以下哪些标识符的命名规则符合规范

```java 
public class student{}
public class TestDemo{}
int Num;
String name;
public class Persondemo{}
包名 Test.Demo
包名 com.baidu
int nianling; 
String 名字;
```





### 2.3 驼峰命名法

#### 2.3.1 小驼峰式命名法（lower camel case）

- 多个单词组合成一个字符串
  - 第一个单词的首字母**小写**
  - 从第二个单词开始，首字母都要大写
- 例如：myName，myFirstJavaProgram



#### 2.3.2 大驼峰式命名法（upper camel case）

- 多个单词组合成一个字符串
  - 第一个单词的首字母**大写**
  - 从第二个单词开始，首字母都要大写
- 例如：MyName，MyFirstJavaProgram





## 3. 注释（comment）

> 什么是注释？

- 注释是可以嵌入到Java代码的任何位置的，一种解释说明性的文字

> 注释有什么作用？

- 方便自己写代码的时候，记录程序的信息
- 增加代码的可读性
  - 过段时间后，自己也能很快想起来，自己写的代码是干什么的
  - 最重要的，方便别人能看懂自己的代码
- 写注释可以增加自己写代码的逻辑性
  - 编码之前先用注释，标注好需要做的事情，先搞明白思路，再写代码
  - 编码实际上就是思想的体现
- 注释也可以作为一种比较简单但十分好用有效的，debug的方式
  - 将可能出错的代码注释掉，再运行程序，直到找出bug
  - 这种方式虽然看起来很笨，实际上用途很大，不要忘记它

> 注释的语法

Java支持三种注释的语法格式

- 单行注释

  ```Java
  //注释的文字
  ```

- 多行注释

  ```java 
  /*
  注释的文字
  */
  ```

- 文档注释

  ```java 
  /**
  注释的文字
  */
  ```

> 注释的使用注意事项

- 多行注释和文档注释不要嵌套使用
- 注释不参与编译，编译器会自动丢掉代码中的注释部分
- JDK中提供了**javadoc.exe**工具，用于将文档注释输出到一个HTML文件中





## 4. 常量与变量

> 程序运行中，内存中有很多数据参与运算
>
> - Java使用变量来存储这些数据
> - 程序运行中，值不变的变量就是常量



### 4.1 常量（constant）

>什么是常量？

- 在程序运行过程中，其值不会发生改变的量

>常量有哪些分类？

- 字面值常量（**literal**）
  - 字符串常量：双引号引起来的内容
    - “Hello World！”
  - 整数常量：所有的整数
    - 1，2，3
  - 小数常量：所有的小数
    - 1.1，1.2
  - 字符常量：单引号引起来的内容
    - 'W'，'E'，
  - 布尔常量
    - 只有true和false
  - 空常量，针对引用数据类型
    - 只有null
- 自定义常量（custom，面向对象详细讲）



### 4.2 变量（variable）

> 什么是变量？

- 程序运行期间，其值在某个范围内，可能会发生改变的量
- 需要强调的是，变量指的是该数据的值可能会发生变化的可能性，只要有可能改变，这个量就是变量

> 怎么定义一个能够使用的变量

- 两步走：先声明变量，再初始化变量（赋值）



#### 4.2.1 声明（declaration）变量

> 什么是声明变量？

- 告诉编译器，变量的数据类型，变量的名字

> 声明变量的语法

```Java
数据类型 变量名;
```

> 课堂抽奖

- 声明后的变量能够直接使用吗？

 



#### 4.2.2 初始化（initialization）变量

> 什么是初始化变量

- 就是给变量赋值，声明一个变量后，必须由程序员显式的进行赋值操作，这个变量才能够使用

> 初始化变量的语法

```Java
变量名 = 变量值;
```

声明和初始化可以合起来

```
数据类型 变量名 = 变量名;
```



#### 4.2.3 使用变量的注意事项

- 注意：Java当中的整数字面值常量，默认当作int处理
  - 如果你想要一个整数字面值常量数据类型为long，需要在后缀上加l或L，推荐L
- 注意：Java当中的浮点数，默认当作double处理
  - 如果你想要一个浮点数字面值常量数据类型为float，需要在后缀上加f或F，推荐
- 变量有效的范围，这个范围通常用{}来界定，同样一个{}不能有同名变量
- 变量必须显式初始化，只有声明的变量无法使用它
- 一行一个语句可以定义多个同数据类型的变量，用逗号隔开
  - 但是一行定义多个变量会影响代码的阅读性，一般不要一行定义多个变量
- 浮点型有精度问题，需要特别注意
  - 一般来说，开发中不会使用浮点类型进行计算，尤其是财务系统等对数值敏感的地方



## 5. 基本数据类型和引用数据类型

>  Java是强类型语言，每一个变量都必须有它的数据类型，并且变量之间不能随便转换数据类型

- 主流的语言大多都是强类型 C、C++、Java、Python

> 弱类型语言，变量之间转换类型比较方便

- PHP



> 什么是数据类型？

- 数据类型，表示的是一个数据集合和基于该数据集合的一组合法操作

> 数据类型怎么分类？

- 基本数据类型：JDK默认提供
- 引用数据类型
  - 类
  - 接口
  - ....



### 5.1 基本数据类型（base date type）

> 有哪些基本数据类型？

> 四类八种

- 整型
  - byte：字节，1个字节空间
  - short：短整型，占2个字节空间
  - int：整型，占4个字节空间
  - long：长整型，占8个字节空间
- 浮点型
  - float：单精度浮点型，占4个字节
  - double：双精度浮点型，占8个字节
- 字符类型
  - char：占2个字节，表示单个字符
- 布尔类型
  - boolean：具体占多少内存，了解即可
    - 根据JVM规范，在内存中boolean当作int处理，占4个字节
    - boolean数组当成byte数组处理，一个boolean元素占1个字节



#### 5.1.1 基本数值类型的取值范围

| 基本数据类型 | 字节长度 | 大小（位） | 最小值 | 最大值 | 取值范围                                                  |
| ------------ | -------- | ---------- | ------ | ------ | --------------------------------------------------------- |
| **byte**     | 1字节    | 8bit       | -2^7   | 2^7-1  | -128 ~ 127                                                |
| **short**    | 2字节    | 16bit      | -2^15  | 2^15-1 | -32768 ~ 32767                                            |
| **int**      | 4字节    | 32bit      | -2^31  | 2^31-1 | -2147483648 ~ 2147483647（21亿出头）                      |
| **long**     | 8字节    | 64bit      | -2^63  | 2^63-1 | -9223372036854774808 ~ 9223372036854774807（大概922亿亿） |
| **float**    | 4字节    | 32bit      | -      | -      | -3.403E38~3.404E38（有效位数7~8位）                       |
| **double**   | 8字节    | 64bit      | -      | -      | -1.798E308~1.798E308（有效数字16~17位）                   |



####  5.1.2 浮点型的精度问题（precision problem）

> 什么是精度问题？
>
> 计算的结果的数据类型，或者新的数据类型无法容纳全部的数据，导致部分信息被截断丢失，数据失真
>
> 专业名词就叫做“精度丢失”



> 经典的案例

- 计算10/3.0
- 计算1-0.9
- 二进制表示0.1

> - 正数十进制转换成二进制，除2直到商为0，取余数倒过来
>
> - 负数十进制转换成二进制，先算出正数的二进制数,取反+1
>
> - 正小数转换成二进制，用小数部分乘以2，取结果的整数部分(必然是1或者0)，
>   - 然后小数部分继续乘2
>   - 直到小数部分为0,或者已经达到了最大的位数
>   - 最终的结果（0.开头）正序排列

- 结论：

> float和double类型主要是为了科学计算和工程计算而设计的
>
> 它们执行的二进制浮点运算，是在广泛的数字范围上较为精确而快速的近似计算
>
> 所以直接使用float和double类型做浮点运算很容易出现误差，也就是精度损失
>
> 我们不应该把它们用于精确计算的场合，尤其不适合用于货币运算

- 最好的解决办法是用BigDecimal 替代float和double进行浮点数计算







### 5.2 引用数据类型（reference）

> 碍于知识点的限制，目前只要知道字符串（String）是一种引用数据类型即可
>
> String属于引用数据类型中的类





### 5.3 基本数据类型的数据类型转换（conversion）

> 什么是数据类型转换呢？

- Java是强类型语言，变量一旦声明后，数据类型不会轻易改变，但也并非完全不可能改变
- 我们将Java中变量的数据类型由某一种转换为另一种，这个过程叫做数据类型转换

> 数据类型转换的分类

- 自动类型转换，也叫向上转型
  - 向上转型只是自动类型转换的一种说法，这种说法只针对引用数据类型
- 强制类型转换，也叫向下转型
  - 向下转型只是自动类型转换的一种说法，这种说法只针对引用数据类型



#### 5.3.1 基本数据类型的自动类型转换（automatic）

> 什么是自动类型转换？

- 数据类型无需程序员操作，由编译器自动转换

> 基本数据类型的自动类型转换的规则
>
> “小取值范围”转换为“大取值范围”发生自动类型转换（浮点数都比long取值范围大）

- byte、short、char之间不互相转换，一旦之间发生运算，一律自动转换为int进行运算，结果是int
- byte、short、char任一数据类型与int进行计算，一律自动转换为int进行计算，结果是int
- byte、short、char、int任一数据类型与long进行计算，一律自动转换为long进行计算，结果是long
- byte、short、char、int、long任一数据类型与float进行计算，一律自动转换为float进行计算，结果是float
- byte、short、char、int、long、float任一数据类型与double进行计算，一律自动转换为double进行计算，结果是double

> 精度问题
>
> “小容量”不一定是“小取值范围”——所有浮点类型都比long取值范围大
>
> 但是由于浮点数本身的问题，整型的内存表示方式也和浮点型完全不同，很容易产生精度丢失

- 当int、long（4字节，8字节）自动转换成float（4字节）时，可能会有精度损失
- 当long自动转换成double（8字节）时，也可能产生精度损失
- 不要用浮点型计算小数，除非对精度十分不敏感



> 以下图中，实线虚线都表示可以发生自动类型转换
>
> - 实现表示不会有精度问题
> - 虚线表示可能会产生精度丢失

![image-20210101011533113](C:/Users/AnoxiC2010/Desktop/wdJava30th/SE/课程资料/md课件/课件附属图片/自动类型转换中的精度丢失-1610771799581.png)



#### 5.3.2 基本数据类型的强制类型转换（cast）

> 什么是强制类型转换

- 数据类型的转换需要程序员显式操作，否则编译器报错

> 什么时候需要强制类型转换

- 在特别有必要的情况下，把一个“大取值范围”的数据类型，转换成“小取值范围”的数据类型，比如int---->byte
- 如果不是特别必要，不要做这种操作，因为很容易丢失精度

> 语法

```java
目标数据类型 变量名 = (目标数据类型)(被转换的变量变量名);
```

> 精度问题

- 强制类型转换，大变小，精度损失是很常见的
- 强烈建议：除非是非强转不可，不要使用强制类型转换，稍有不慎会导致bug
- 进行强制类型转换，要严格考量，数据类型的取值范围，像(byte)200这种行为是很滑稽的

> 补充

- boolean类型和其他数据类型之间不能通过强制类型转换语法**直接转换**
  - 0 = false ，1 = true



> 基本数据类型的类型转换，可以总结出以下规律：

- 八种基本数据类型中，只有boolean类型不能直接进行类型转换，其他七种都可以互相转换
- byte、short、char使用的时候尤其注意取值范围，若参与运算都会自动提升到int
- ”小取值范围“--->“大取值范围”称之为自动类型转换，不需要写代码处理，排序是
  - byte < short（char） < int < long < float < double
- “大取值范围”--->“小取值范围”称之为强制类型转换，必须要显式处理，否则报错
  - 需要注意强制类型转换，很容易丢失精度，慎用
- 多种数据类型混合在一起进行运算，先全部提升为“最大取值范围”的数据类型，再进行计算



>小练习1
>
>哪句是编译失败的呢？为什么呢？

```Java
byte b1 = 1, b2 = 2, b;
b = b1+ b2;
b= 1 + 2;
```



>小练习2
>
>这句代码有没有问题？
>
>如有问题，咋整？

```Java
 byte b = 130;
```



> 小练习3
>
> 请写出下列程序结果

```Java
    System.out.println('a');
    System.out.println('a'+1);
    System.out.println("hello"+'a'+1);
    System.out.println('a'+1+"hello");
    System.out.println("5+5"+5+5);
    System.out.println(5+5+"=5+5");
    System.out.println(5 + 5.0);
    System.out.println(5+"5"+5.0);
```



> 几个启示

- 语句中1或者2都是字面值常量，字面值常量互相做运算仍然是常量。我们常说的1默认是int类型，是说可以用int类型的变量来接收它
- 强转会有精度损失，不要轻易做强转
- 运算式中会发生数据类型的自动转型，称之为“表达式的类型提升”
  - 结果必然是自动提升后的那个数据类型
  - String（字符串）在表达式中是最高的类型



## 6. 原码，反码与补码

> 有符号的数据表示法——原码，反码，补码

计算机中的数据是二进制的，不像生活中用符号表示负数一样那么简单，在计算机中，有符号数的表示分为三种

<font color=red>注意：所有的数据运算都是采用补码形式进行</font>

- 原码
  - 有效数字是其绝对值的二进制表示
  - 最高位负数是0，正数是1
  - 有效数字和最高位之间用0补充
  - 除了最高位符号位外，其余位置都是数值位
- 反码
  - 正数的反码与原码相同
  - 负数的反码是对其原码逐位取反，符号位除外
- 补码
  - 正数的补码与原码相同
  - 负数的补码是在其反码上加1
  - 反码+1=补码
  - 反码=补码-1



## 7. ASCII码表

> ASCII （（American Standard Code for Information Interchange）：美国信息交换标准代码）
>
> 是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他西欧语言

| ASCII值 | 控制字符 | ASCII值 | 控制字符 | ASCII值 | 控制字符 | ASCII值 | 控制字符 |
| :------ | :------- | :------ | :------- | :------ | :------- | :------ | :------- |
| 0       | NUT      | 32      | (space)  | 64      | @        | 96      | 、       |
| 1       | SOH      | 33      | !        | 65      | A        | 97      | a        |
| 2       | STX      | 34      | "        | 66      | B        | 98      | b        |
| 3       | ETX      | 35      | #        | 67      | C        | 99      | c        |
| 4       | EOT      | 36      | $        | 68      | D        | 100     | d        |
| 5       | ENQ      | 37      | %        | 69      | E        | 101     | e        |
| 6       | ACK      | 38      | &        | 70      | F        | 102     | f        |
| 7       | BEL      | 39      | ,        | 71      | G        | 103     | g        |
| 8       | BS       | 40      | (        | 72      | H        | 104     | h        |
| 9       | HT       | 41      | )        | 73      | I        | 105     | i        |
| 10      | LF       | 42      | *        | 74      | J        | 106     | j        |
| 11      | VT       | 43      | +        | 75      | K        | 107     | k        |
| 12      | FF       | 44      | ,        | 76      | L        | 108     | l        |
| 13      | CR       | 45      | -        | 77      | M        | 109     | m        |
| 14      | SO       | 46      | .        | 78      | N        | 110     | n        |
| 15      | SI       | 47      | /        | 79      | O        | 111     | o        |
| 16      | DLE      | 48      | 0        | 80      | P        | 112     | p        |
| 17      | DCI      | 49      | 1        | 81      | Q        | 113     | q        |
| 18      | DC2      | 50      | 2        | 82      | R        | 114     | r        |
| 19      | DC3      | 51      | 3        | 83      | S        | 115     | s        |
| 20      | DC4      | 52      | 4        | 84      | T        | 116     | t        |
| 21      | NAK      | 53      | 5        | 85      | U        | 117     | u        |
| 22      | SYN      | 54      | 6        | 86      | V        | 118     | v        |
| 23      | TB       | 55      | 7        | 87      | W        | 119     | w        |
| 24      | CAN      | 56      | 8        | 88      | X        | 120     | x        |
| 25      | EM       | 57      | 9        | 89      | Y        | 121     | y        |
| 26      | SUB      | 58      | :        | 90      | Z        | 122     | z        |
| 27      | ESC      | 59      | ;        | 91      | [        | 123     | {        |
| 28      | FS       | 60      | <        | 92      | /        | 124     | \|       |
| 29      | GS       | 61      | =        | 93      | ]        | 125     | }        |
| 30      | RS       | 62      | >        | 94      | ^        | 126     | `        |
| 31      | US       | 63      | ?        | 95      | _        | 127     | DEL      |



# 文件输入与输出 Scanner&PrintWriter

```java
package com.test;
import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Scanner;

public class Test {
    public static void main(String[] args) throws IOException {
        File file = new File("C:\\Users\\AnoxiC2010\\Desktop\\Test.txt");
        Path path = Paths.get("C:\\Users\\AnoxiC2010\\Desktop\\Test.txt");
        //文件输入的两种方式
        Scanner in = new Scanner(file, "UTF-8");
//      Scanner in = new Scanner(path, "UTF-8");
        String s = "";
        while (in.hasNextLine()) {
            s = in.nextLine();
            System.out.println(s);
        }
        //文件输出
        PrintWriter out = new PrintWriter("C:\\Users\\AnoxiC2010\\Desktop\\Test.txt", "UTF-8");
        out.println("第一行");
        out.println("第二行");
        out.close();//不close的话不会写入
        //查看是否写入
        in = new Scanner(path, "UTF-8");//不新建对象的话不读取新内容
        while (in.hasNextLine()) {
            s = in.nextLine();
            System.out.println(s);
        }
        in.close();//关不关到都能输出
    }
}
```

> java.util.Scanner 5.0
>
> * Scanner(File f)
>
>   构造一个从给定文件读取数据的Scanner
>
> * Scanner(String data)
>
>   构造一个从给定字符串读取数据的Scanner
>
> java.io.PrintWriter 1.1
>
> * PrintWriter(String fileName)
>
>   构造一个将数据写入文件的PrintWriter。文件名由参数指定
>
> java.nio.file.Paths 7
>
> * static Path get(String pathname)
>
>   根据给定的路径名构造一个Path

# 循环相关break lable

除了循环也可以将标签应用到任何语句中，甚至可以应用到if语句或者块语句中，像goto，但只能跳出语句块，不能跳入语句块，不提倡。

循环中continue也可以配合lable使用

```java
lable:{
    ...
    if(condition) break lable; //exit block
    ...
}
//jumps here when the break statement executes
```

# 大数值 BigInteger & Decimal

```java
//将普通数值转换为大数值，使用静态valueOf方法
BigInteger a = BigInteger.valueOf(100);
```

> java.math.BigInteger 1.1
>
> * BigInteger add(BigInter other)
>
> * BigInteger subtract(BigInteger other)
>
> * BigInteger multiply(BigInteger other)
>
> * BigInteger divide(BigInteger other)
>
> * BigInteger mod(BigInteger other)
>
>   返回这个大整数和另一个大整数other的和、差、积、商、余数。
>
> * int compareTo(BigInteger other)
>
>   如果此大整数与另一个大整数other相等，返回0；此大整数小于另一个大整数other，返回负数；否则返回正数。
>
> * static BigInteger valueOf(long x)
>
>   返回值等于x的大整数。
>
> java.math.BigInteger 1.1
>
> * BigDecimal add(BigDecimal other)
>
> * BigDecimal subtract(BigDecimal other)
>
> * BigDecimal multiply(BigDecimal other)
>
> * BigDecimal divide(BigDecimal other RoundingMode mode) 5.0
>
>   返回这个大实数与另一个大实数other的和、差、积、商。要想计算商，必须给出舍入方式（rounding mode）。RoundingMode.HALF_UP是在学校中学习的四舍五入方式。它适用于常规的计算。有关于其他的舍入方式可查看API文档。
>
> * int compareTo(BigDecimal other)
>
>   如果这个大实数与另一个大实数相等，返回0；小于另一个大实数，返回负数；否则，返回正数。
>
> * static BigDecimal valueOf(long x)
>
> * static BigDecimal valueOf(long x, int scale)
>
>   返回值为x或x/10(scale 上标)的一个大实数。

# 数组

```java
//无论哪种创建方式，都不会跳过默认初始化的过程
//for each增强循环
//定义一个变量variable用于暂存集合collection中的每一个元素
//这个变量相当于是拷贝的元素，fori循环中拿到的直接就是集合的元素
//collection必须是数组或者实现了Iterable接口的类对象
for(variable : collection) statement

//利用Arrays类的toString方法简单打印数组中的所有值
Arrays.tostring(collection)返回形如[xx,xx,xx]的字符串
 
//利用匿名数组再不创建新变量的情况下重新初始化一个数组
int smallPrimes = {2, 3, 5, 7};
smallPrimes = new int[]{17, 19, 23, 29};

//数组拷贝
//用Arrays类的copyOf方法把一个数组中的所有值拷贝到新的数组中去
int[] numbers = {1, 2, 3, 4, 5};
int[] copiedNumbers = Arrays.copyOf(numbers, numbers.length());
//第二个参数是新数组长度，通常可利用它来增加数组长度
//多余元素被赋初始值，相反长度小于原来，则只拷贝最前面的元素
int[] copiedNumbers = Arrays.copyOf(numbers, 2 * numbers.length());

//命令行参数
//main方法的参数args可以通过在命令行执行命令语句后加入参数以String数组形式传入
//如命令行执行Hello.class：java Hello xxx xxx xxx 后面几个为args数组的元素

//数组排序
int a = new int[1000];
...
Arrays.sort(a);//升序，优化的快速排序算法
//快速打印二维数组的数据元素列表[[...],[...],...]
System.out.println(Arrays.deepToString(arrs));
```

# 生成随机数

```java
//生成随机数
//Math.random()方法返回[0,1)的随机浮点数。
int r = (int)(Math.random() * n);//返回[0,n-1)之间的随机数
//Random类生成随机数
Random randomGenerator = new Random();
int r = randomGenerator.nextInt(1000);//[0,1000)随机
```

//Math.random()方法返回[0,1)的随机浮点数。
int r = (int)(Math.random() * n);//返回[0,n-1)之间的随机数

> java.util.Arrays 1.2
>
> * static String toString(type[] a) 5.0
>
>   返回包含a中数据元素的字符串，这些数据元素被放在括号内，并用逗号分隔。
>
>   参数：a 类型为int、long、short、char、byte、boolean、float或double的数组。
>
> * static type copyOf(type[] a, int length) 6
>
> * static type copyOfRange(type[] a, int start, int end) 6
>
>   返回与a类型相同的一个数组，其长度为length或者end-start，数组元素为a的值。
>
>   参数：a 类型为int、long、short、char、byte、boolean、float或double的数组。
>
>   start 起始下标（包含这个值）
>
>   end 终止下标（不包含这个值）。这个值可能大于a.length。在这种情况下，结果为0或false。
>
>   length 拷贝的数据元素长度。如果length值大于a.length，结果为0或false；否则，数组中只有前面length个数据元素的拷贝值
>
> * static void sort(type[] a)
>
>   采用优化的快速排序算法对数组进行排序。
>
>   参数：a 类型为int、long、short、char、byte、boolean、float或double的数组。
>
> * static int binarySearch(type[] a, type v)
>
> * static int binarySearch(type[] a, int start, int end, type v) 6
>
>   采用二分搜索算法查找值v。如果查找成功，则返回相应的下标值；否则，返回一个负数值r。-r-1是为了保持a有序v应插入的位置。
>
>   参数：a 类型为int、long、short、char、byte、boolean、float或double的***有序***数组。
>
>   start 起始下标（包含这个值）。
>
>   end 终止下标（不包含这个值）。
>
>   v 同a的数据元素类型相同的值。
>
> * static void fill(type[] a, type v)
>
>   将数组的所有数据元素值设置为v。
>
>   参数：a 类型为int、long、short、char、byte、boolean、float或double的数组。
>
>   v 与a数据元素类型相同的一个值。
>
> * static boolean equals(type[] a, type[] b)
>
>   如果两个数组大小相同，并且下标相同的元素都对应相等，返回true。
>
>   参数：a、b 类型为int、long、short、char、byte、boolean、float或double的两个数组。

# 对象与类

## 时间对象

```java
//Date类对象描述的是一个时间点，使用距离一个固定的时间点的毫秒数（可正可负）表示的，这个点就是纪元（epoch），是UTC时间1970年1月1日00:00:00。Date类提供的日期处理是Gregorian阳历表示法。
Date now = new Date();//构造对象时的日期
//LocalDate类用来表示大家熟悉的日历表示法，不能new，要用静态工厂方法调用构造器
LocalDate now = LocalDate.now();//构造对象时的日期
//LocalDate构造特定日期的对象
LocalDate oneday = LocalDate.of(1991, 1, 1);
//LocalDate对象分别获取年月日的方法
int year = oneday.getYear();//1991
int monthValue = oneday.getMonthValue();//1
int dayOfMonth = oneday.getDayOfMonth();//1
//获取指定天数之后的新日期
LocalDate aThousandDaysLater = oneday.plusDays(1000);
year = aThousandDaysLater.getYear();//1993
monthValue = aThousandDaysLater.getMonthValue();//09
dayOfMonth = aThousandDaysLater.getDayOfMonth();//27
//Date的getDate、getMonth、getYear已被标记为不推荐使用，Date类已被标记为废弃不用
```

> java.time.LocalDate 8
>
> * static LocalTime now()
>
>   构造一个表示当前日期的对象。
>
> * static LocalTime of(int year, int month, int day)
>
>   构造一个表示给定日期的对象
>
> * int getYear()
>
> * int getMonthValue()
>
> * int getDayOfMonth()
>
>   得到当前日期的年、月、日
>
> * DayOfWeek getDayOfWeek
>
>   得到当前日期是星期几，作为DayOfWeek类的一个实例返回。电泳getValue来得到1~7之间的一个数，表示这是星期几，1表示星期一，7表示星期日
>
> * LocalDate plusDays(int n)
>
> * LocalDate minusDays(int n)
>
>   生成当前日期之后或之前n天的日期

请不要在构造器中定义与实例域同名的变量

隐式参数与显示参数：

每个方法中，关键字this表示隐式参数，在方法中直接声明的叫做显式参数。某些程序员会偏好this.xxx的风格将实例域与局部变量明显的区分开

封装

需要获得或设置实例域的值，需要提供三项内容：

* 一个私有的数据域
* 一个公有的域访问器方法
* 一个公有的域更改器方法

这样做的好处是可以更改内部实现，除了该类的内部方法之外，不会影响其他代码。

注意不要编写返回引用可变对象的访问器方法。例如Date类是有一个更改器方法setTime，结果是返回的Date对象是可变的，就破坏了封装性。如果需要返回一个可变对象的引用，应该首先对它进行克隆（clone），这样我们将返回一个可变数据的拷贝。

> 一个方法可以访问所属类的所有对象的私有域

```java
class Employee {
   ...
    public boolean isSameAge(Employee anotherEmployee) {
        return this.age == anotherEmployee.age;
    }
}
```

## 默认域的初始化

> 如果在构造器中没有显示地给域赋初值，那么就会被自动地赋为默认值（数值为0、布尔值为false、对象引用为null）。如果不明确的对域进行初始化，就会影响程序代码的可读性,这不是良好的编程习惯。如通常我们不想的到一个null的引用。

## 关闭钩 & close方法

详见API文档

# 继承

## 子类对象的初始化（initialization）

> 子类继承了父类，子类中就包含了父类的成员
>
> 那么在创建初始化子类对象时，和之前相比也会有较大的不同



> 子类创建对象过程

- JVM仍然是创建谁的对象，就加载谁，先加载子类
- 但是很快，在子类还没有加载的时候，JVM发现子类有父类
  - 父类如果不存在，子类肯定也不可能存在
- 于是JVM调转枪头，开始加载父类
- 加载完父类，再加载子类
- 类加载都结束后，开始创建堆上的对象
- 堆上的对象中，会有一片空间，用来存放父类的成员
  - 子类对象就由两部分组成
  - 一部分是子类自己独特的成员
  - 另一部分是从父类继承过来的成员
- 现在堆上就真实存在了一个子类对象
  - 子类对象中存放父类成员的内存区域，可以近似的看成是一个父类对象
  - 所以子类的内存图，近似看成子类对象“装着”父类对象
  - 注意，**这个父类对象只是近似看作，不会真的创建了父类对象**
    - 创建子类对象，只会类加载父类，不会真的创建父类

> 仍然有一个棘手的问题

- 子类对象中的，父类成员变量和子类自身成员变量，谁先初始化默认初始值？
  - 答：先给父类成员变量默认初始化，再默认初始化子类
  - 为什么？答：先父后子，没毛病，首先要有父亲，才有儿子
  - 其次，子类成员变量的初始化，可以依赖父类成员变量
    - 这个时候如果子类先初始化，显然是要报错的



> 问题仍然没有结束

- 子父类的类加载顺序是由JVM去保证的，但是子父类的初始化先后顺序又是怎么保证的呢？
- 它的原理是什么呢？

> 我们已经知道了构造器是可以用来初始化成员变量，会由JVM自动调用
>
> 用构造器去保障这种先后顺序，怎么做呢？

- 答：只需要在子类的构造器的第一行，调用父类构造器就可以了

​	 

> 我们没有自己手动在子类构造器的第一行，调用父类构造器，但是仍然达成了先初始化父类
>
> 再初始化子类的效果，是什么原因呢？
>
> 显然这里存在了一个隐式调用，于是子类对象的初始化就有了两种方式

- 隐式的调用了父类构造方法（JVM保证）
- 程序员显式的调用父类构造方法（代码保证）

## 显隐式子类初始化

> 重点学习一下两种方式

### 子类对象的隐式初始化（implicit）

> 隐式初始化，JVM自动调用，无需我们手动操作
>
> 条件为

- **父类中有默认的构造方法**
  - 子类的构造器中没有显式调用父类的构造方法
- 达成上述两个条件，则JVM在初始化子类对象时进行隐式初始化

  - 永远先执行父类的构造方法，顺序为
    - 最上层的父类（Object）
    - 其他父类（继承链中越处于上流越先执行）
  - 所有父类的构造方法都执行完毕，开始执行子类构造方法

> 需要注意的是
>
> - 隐式初始化，JVM总是调用父类的无参构造，如果父类没有，就要报错
> - Object类也有默认无参
> - 隐式初始化总是不传参数，如果我们想要对参数进行赋值，就必须使用显式的子类初始化

### 子类对象的显式初始化（Explicit ）

> 显式初始化，需要程序员手动写代码，告诉JVM调用哪个父类构造器
>
> 如何使用？

- 必须在子类构造器的第一行，显式的调用父类构造方法，那么如何调用父类构造器？

  - 使用super关键字调用

  - 语法

    ```Java
    super(父类构造器参数);
    ```

> 什么是super关键字？

- super代表当前类的父类"对象"的引用
- this代表当前类的对象
- 两者的使用没有明显差别，只是
  - **this在当前类中不受访问权限控制，super访问父类成员，受访问权限控制**
  - 因为当前类中即便是private仍然可以访问，但是super就不在当前类中了

```
this VS super  

this关键字：表示当前对象的引用         super关键字：super代表父类对象的引用

this调用当前类中定义的构造方法：this(实参列表)          
super调用父类中定义的构造方法：super(实参列表)

this访问当前对象的成员变量值          super访问父类对象中，成员变量的值

this访问当前对象的成员方法            super访问父类对象，成员方法                            
```



**super与this关键字**

**this关键字概念：**

this代表所在类的对象引用。

**记住： 方法被哪个对象调用，this就代表哪个对象。**

**1.super可以在子类中 调用父类中名称相同的 成员方法和成员变量**

**2.this可以在方法中调用 类中的与方法内局部变量名称相同 的成员方法和成员变量**

**3.super和this的区别**

(a).this 代表**当前类的对象**

代表对象的内存空间标识（用来存储当前类定义的内容，成员变量、方法）

(b).super （代表父类对象） 可以这么理解，实际并不代表父类对象

代表对象的内存空间的标识（用来存储父类定义的内容，成员变量、方法）

**使用场景：**

当局部变量和成员变量名字相同时用this，子类变量和父类变量名字相同时用super

**super用法：（this和super均适用）**

**1.访问成员变量**

this.成员变量  super.成员变量    （局部变量直接调用不需要修饰符）

**2.访问构造方法**

 this(…)           super(…)        如果是有参方法，()里面写参数

**3.访问成员方法**

this.成员方法()  super.成员方法()



隐式子类对象创建：

​	条件： 

​		a. 当父类提供了默认的构造函数(无参构造方法)

​        b. 子类的构造方法中, 没有显式调用父类的其它构造方法

​	结果：

​		JVM自动在子类构造方法第一句加上  “ super() “

​		在执行子类的构造方法之前，JVM会自动执行父类

​	

显式子类对象创建：

​	程序员写代码告诉JVM在调用子类构造器之前调用父类构造方法

​	可以在子类构造器的第一行使用super关键字，调用父类的构造方法

​		

总结：

​	**1，无论是隐式还是显式，最终都是为了保证父类构造器先于子类执行**

​	2，若父类中不存在默认构造方法，则必须在子类构造方法中使用super关键字调用父类构造器

​	3，在子类构造方法中，super语句必须在第一行

​	4，在子类构造方法中，也可以用this调用自身构造，也必须在第一行

​	5，this和super不能共存

​	6，构造代码块和静态代码块也是“先父后子”



为什么this和super都必须在第一行？

​	因为子类构造器第一行永远都有一个super关键字调用，如果你自己的super和this不在第一行，会形成循环

## 子类的属性隐藏（field hidden）

> 子父类中能否拥有同名的属性呢？
>
> 如果可以，请尝试

- 创建子类对象，使用对象名点的形式访问同名变量，结果是什么？
- 创建子类对象，在子类中，编写方法，返回该属性
  - 用子类对象调用该方法，返回的结果是？
  - 方法的就近原则
- 创建子类对象，在父类中，编写方法，返回该属性
  - 用子类对象调用该方法，返回的结果是？
  - 方法的就近原则
- 最终我们发现，子类可以访问到父类的成员变量
  - 但是由于编译器检索机制的限制，好像父类的属性被隐藏了一样
  - 称之为子类的属性隐藏





> 如果我就想在子类方法中，访问父类的同名成员变量，怎么办？

- super关键字





> 对象名点成员变量名的，编译器检索机制

- 先从子类本身中去找---->子类中找不到再去父类中找----->再找不到就报错
- 但是一般来说，我们都是通过方法访问成员变量



> 注意事项

- 静态成员变量也可以被继承，但是静态成员变量如果是同名的，是一个全新的，会覆盖掉原先的静态成员
- 子类父类的同名静态成员各自独立属于自己的类，如果子类没有便完全继承父类的静态成员

## 子类的方法覆盖（override）

> 子父类中能否拥有同名的方法？
>

- 在父子类中声明两个个一模一样的方法，但是方法体输出不同
  - 创建子类对象，直接调用该方法，结果是什么？
- 再在父子类中定义两个方法，分别在方法体中调用自身方法名一样的方法
  - 创建子类对象，分别调用两个方法，结果是什么？
- 我们发现无论怎么操作，都只能访问子类中的同名方法，这就是方法的覆盖



> 如果想在子类的方法中，访问父类方法，应该怎么办？

- super关键字



> 对象名点方法访问的方式，编译器的检索机制

- 先从子类本身中去找---->子类中找不到再去父类中找----->再找不到就报错



> 什么时候使用方法的覆盖？

- 当我们需要在子类中，修改父类方法的实现的时候
- 使用方法的覆盖时，添加@Override注解来标记
- 例如：比如对于动物的叫，人类的吃



> 方法覆盖的注意事项

- 父类中私有方法不能被重写
- 子类重写父类方法时，访问权限不能更低
- 静态方法在使用现象上，很像是被重写了，但实际上静态方法不能被重写，而是直接是一个新的静态成员



- 重写 VS 重载

|              | 重载（overload） |                      重写（override）                       |
| :----------: | :--------------: | :---------------------------------------------------------: |
| 发生的类不同 |   发生在同类中   |               发生在子父类之间,肯定不是一个类               |
|    方法名    |     必须相同     |                          必须相同                           |
|   参数列表   |     必须不同     |                          必须相同                           |
|  权限修饰符  |      不影响      |            重写的方法访问权限必须大于等于原方法             |
|     异常     |      不影响      |                重写的方法不能抛出更多的异常                 |
|  返回值类型  |      不影响      | 重写的方法的返回值类型必须和原方法兼容,代表可以不是完全一致 |

- 被static、final、private修饰的父类方法无法被重写

## final和限制继承

> final是一个修饰符，可以用来修饰类、方法和变量（包括成员变量和局部变量）

### final修饰类

> 表示”最终的类“
>
> 当用final修饰一个类时，表明这个类不能被继承

- 除了这一点外，这个类照常使用，比如创建对象，比如访问方法，比如继承别的类
- 从设计角度来讲，一个final修饰的类应该是
  - 不需要复用成员
  - 功能已经特别强大，足够满足需求
  - 需要绝对的保证安全，以致于不让它被继承
- 常见的final类
  - String
  - System
  - Math
  - 所有基本数据类型的包装类和一个Void
    - Boolean，Character，Short，Integer，Long，Float，Double，Byte，Void
- 除非你十分确定这个类以后不会被用来继承 ，为了保证安全，可以设置一个类为final类
  - 不然一般情况下，尽量不要把一个类设置成final

### final修饰方法

> 表示”最终的方法“
>
> 当一个方法被final修饰后，可以被继承，但是无法被重写

- final修饰方法，就把方法锁住了，任何继承这个方法的类都无法覆盖该方法
- 如果一个方法已经能够满足需求，并且明确知道它不应该被修改，修改会产生问题
  - 可以将方法设置成final方法
  - 否则，正常情况下，不要随便使用final修饰方法

### final修饰变量

> 表示”最终的变量“，是一种自定义常量，普遍来说，命名应该采用全大写，下划线连接的方式
>
> 修饰变量是final用得最多的地方，也是可能混淆的地方
>
> 总体来说，final修饰变量后
>
> - 如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改
> - 如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象
>   - 因为final修饰的是引用，而引用中装的是地址
>   - 但是其引用的对象的状态是可以改变的

#### final修饰普通成员变量

- final修饰普通成员变量，表示常量，**在整个创建对象过程中它们的值，只能修改一次也必须显式赋值一次**
- 总结给普通成员变量赋值的方式
  - 显式初始化语句
  - 构造代码块
  - 构造器
  - 创建对象后，调set方法，或者直接赋值
  - 对于final修饰的普通成员变量，前三种必然要有一种
- 对于同一个类的同一个final修饰的变量，不同对象可能会有不同的值

#### final修饰静态成员变量（常用）

- final修饰静态成员变量，表示全局常量，**在整个静态成员赋值过程中，只能修改一次也必须显式赋值一次**
  - **访问一个类的基本数据类型和String类型的final静态全局常量不触发类加载**
  - 被所有对象共享，每个对象都必须有同一个值，且不可改变
- 给final静态成员变量赋值
  - 显式赋值语句
  - 静态代码块
- final static 还是static final？
  - 建议用static final
- 静态常量一般全部大写，用下划线隔开

#### final修饰局部变量

- 在方法体和方法参数列表中定义final常量，表示该常量不可更改
- 必须显式的赋值初始化，不然也没别的方式初始化了
- 在形参列表中声明final常量，表示该参数是一个常量，在接收后无法修改

#### 特别的final修饰引用数据类型

- 表示引用指向的对象不可变，但对象的状态可变
- 例如**final修饰Student类型的变量s，则s的地址值不能改变，**
- **也就是说s要始终指向同一个对象。  但是所指对象的属性值可以改变，只要对象的地址不变即可**



final修饰匿名对象 会咋样？

final new Student() 语法不允许



```
final修饰普通成员变量，表示常量，创建对象的时候，也只能初始化它的值一次，这个过程中也不能改了。创建对象以后，它们的值就不可改变了
```



- 对于一个final变量
  - 构建对象之后，它们的值就不可以被修改了
  - 如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改
  - 如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象
- 使用final修饰一个基本数据类型变量，该变量就变成了常量，只能被赋值初始的一次
  - 自定义常量，无法在程序执行时改变
  - 对于常量，我们最好static final一起使用
- 对于基本数据类型而言，final修饰后，值就不可变了
- 对于引用数据类型而言，final修饰后，引用的地址就不可变了，但引用对象的状态可以改变



> 注意：

- 常量必须显示初始化，即必须赋值一次，不用能默认值。
- 只能赋值一次，即使之后的赋值和原来的值一样也不行
- 在静态常量在常量池中，使用不需要类加载，静态常量需要创建对象赋初值的，使用需要类加载

# 多肽

## 多态的引入（polymorphism）

> 什么是多态？

- 某同一个事物，在不同的时刻表现出不同的状态

  - 对于Java而言，指的是同一个类型引用，在指向不同的具体对象时，运行时表现不同的行为

  - 其实就是父类引用指向了不同的子类对象

  - 例如

    - ```Java
      Animal a = new Cat();
      Animal a = new Dog();
      ```

- 多态的前提条件

  - 要有继承关系
  - 继承后发生子父类的方法重写
  - 父类的引用指向子类的对象

- 不能发生多态的情况

  - 不能够被继承，final类
  - 不能被方法覆盖
    - final方法
    - static方法
    - private方法
    - 构造方法无法被继承

- 当父类的引用，指向不同的实际对象时，调用方法，结果不同

- 写一个方法，参数列表为父类引用，可以传入具体的对象

  - 多态对程序的扩展性

## 多态的访问特征

> 发生多态后，通过引用调用成员的方式发生了改变
>
> 父类 引用 = new 子类();

- 对于成员变量而言
  - 编译时看左边，运行时看左边
  - 也就是说成员变量是没有“多态”的（因为多态的前提就是发生方法重写）
  - 多态现象是发生在方法之间，和成员变量没有关系
- 对于成员方法而言
  - 编译时看左边，运行时看右边

> 解释
>
> 父类 引用 = new 子类();

- 编译看左边
  - 编译看左边是说通过引用变量可以访问到的子类成员的范围
    - 是由引用类型来决定的，也就是说由父类中定义的成员决定
  - 我们只能通过引用去访问，堆上的对象，引用中必然装有该类型对象的成员信息
  - 只有通过引用变量，我才能访问到堆上的对象
    - 也就是说，对象的访问受限于引用变量本身的类型



> 解释方法的多态性，一个很贴切的例子

- 我家中的一台电视机，贼贵，功能很丰富
- 对于电视机而言，我们只能使用，遥控器去操作电视机
- 这也就是说，只有遥控器上提供的功能我们才能使用
  - 即便电视机本身功能多么强大，如果遥控器上只有音量键，那我们也毫无办法
  - 遥控器有啥功能，决定了我们能使用的功能
- 即使电视机本身功能再丰富，没有遥控器的支持，我们啥也用不了

> 把这个例子转换到Java程序中

- 电视机就相当于对象本身，而遥控器就是引用变量
- 实际对象的功能再强大，如果引用中没有这个功能，那也无法调用该功能
- 对象的行为，受限于引用变量，和对象本身没有直接关系
- 对象的引用类型决定了可以访问对象的成员范围
- 编译时看左边，运行时看右边



> 解释成员变量不具有多态性，一个例子

- 成员变量描述的是对象的“外貌特征”
- 把子类对象赋值给父类类型的引用，就相当于给子类对象披上了一个父类类型马甲
- 外貌特征上来看，这时候的子类就变成了父类
- 编译时看左边，运行时看左边

​	

## 多态的优缺点

- 多态的优点：
  - 要实现多态，必须要继承，提高了程序的可维护性（继承保证）
  - 发生多态后，同一个引用调用方法产生不同的行为
    - 提高了程序的简洁性和扩展性（多态保证）

- 多态的缺点：
  - 不能访问子类特有的功能

## 引用类型的类型转换

> 基本数据类型之间是可以发生数据类型转换的，引用数据类型也是可以的
>
> 但是引用数据类型发生转换的条件比较苛刻，出错后的问题也更严重
>
> 做引用数据类型的转换 小心小心再小心



引用数据类型要发生类型转换

- 前提：具有父子关系的两个类型之间
- 没有父子关系的两个类型之间不能发生类型转换，通过不了编译

### 自动类型转换

- 子类的引用转换成父类的引用，在继承链中属于向上，编译器默认允许

  - 称之为自动类型转换或者向上转型

  - 语法

  - ```java 
    父类 引用名 = new 子类();
    ```

  - 子类一定可以看成父类，所以能够自动转型

  - 向上转型是安全，可以放心使用

### 强制类型转换

- 父类的引用转换成子类的引用，在继承链中属于向下，编译器默认不允许，需要显式强行转换

  - 称之为强制类型转换或者向下转型

  - 语法

  - ```java
    子类 引用名 = (子类)父类引用;
    ```

  - 子类继承和扩展了父类，父类大多数情况下都不能看成子类，所以需要强制类型转换

  - **重要前提：强制类型转换若想成功，必须是该父类引用指向的对象本身就是一个要强转的子类对象**



- 强制类型转换是不安全的，要想转型成功，必须真实的对象和要转型的类型一致

  - 父类引用指向的不一定就是那个你要强转的子类的对象
  - 比如动物类的引用指向了一个猫对象，现在把引用强转成一个狗引用，能成功吗？

- 为了保障安全，向下转型推荐使用instanceof关键字校验

  - 语法

  - ```Java
    引用名 instanceof 类名
    ```

  - 这个表达式返回一个布尔类型的值

    - true代表该引用指向的对象，是一个后面类名的对象
    - null instanceof 任何类 结果都是false



### ClassCastException

> 强制类型转换一旦失败，就会抛出ClassCastException，程序报错终止

- 没有人会故意给自己找麻烦
- 不到万不得已，不要使用强制类型转换

## 子类实例化和多态案例

```java
public class Demo {
    public static void main(String[] args) {
        Father f1 = new Son(1000);//0
        Father f2 = new Father();//10
        Son s = new Son(1000);//0
    }
}

class Father {
static int f = 2;//父类静态成员
static {
    f = 3;//父类静态代码块
}
    int i = 10;//父类成员
    {
        i = 11;
    }
    public Father(int i) {

    }

    public Father() {

        System.out.println(getI());
    }

    public int getI() {
        return i;
    }
}

class Son extends Father {
    static int s = 5;//子类静态成员
    static {
        s = 6;//子类静态代码块
    }

    int i = 100;
    {
        i = 101;
    }
    public Son(int a) {
        this.i = a;
    }

    public int getI() {
        return i;
    }
    public Son() {

    }
}

```

# 抽象类（abstract）

> 抽象类定义
>
> 在继承体系中，从祖先类开始，随着一个个子类的定义，子类变得越来越具体
>
> 而祖先类则更具有一般性和抽象性
>
> 在这种情况下，为了体现祖先类在设计上的抽象性
>
> 我们只将该类作为派生其他类的父类，而不能创建对象实例
>
> 这个时候，这样的类，我们称之为抽象类

- 抽象类使用abstract关键字标记

  - ```Java
    [访问权限修饰符] abstract class 类名{
    }
    ```

- 表示该类是一个抽象类

- 抽象类无法被实例化，抽象类不能实例化，但是开发中会提供子类，可以用多态的方式访问

- 抽象方法使用abstract关键字标记

  - ```Java
    [权限修饰符] abstract 返回值类型 方法名();
    ```

  - 表示该方法是一个抽象方法

  - 抽象方法必须在一个抽象类中

  - 抽象方法没有方法体，只有方法声明，不要忘记写分号



> 接下来，我们重点来研究一个抽象类的特点和使用
>
> 我们从下面两个角度分析

- 抽象类的成员
  - 成员变量
  - 成员方法
  - 构造方法
- 抽象类的子类



> 抽象类的成员特点：

- 抽象类具有普通构造方法，成员变量和成员方法

- 抽象类具体普通类都可以有的成员变量，静态成员变量，常量
- 抽象类可以有抽象方法，也可以有普通方法
  - 抽象方法起着占位的作用，该方法必须在子类中实现
  - 抽象方法不能是private、static、final修饰的
  - 普通方法可以作为一个默认实现，子类可以使用这个方法，也可以自行重写
  - 抽象类中可以没有抽象方法，这样做的目的是不让创建对象
    - 但是一般不要这么做，抽象类是一个设计上的概念，应该从设计上正确的使用它
    - 如果仅仅是为了不让外界创建对象，私有化构造方法即可
    - 普遍来说，既然是抽象类就应该有抽象方法，不然没啥意义
- 抽象类虽然不能实例化，但仍然有构造方法
  - 抽象类中的构造方法是留给子类初始化时调用的
  - Java当中，只要是类都具有构造方法
- 总结抽象类成员
  - 构造方法：同普通类
  - 成员变量：同普通类
  - 成员方法：可以是抽象方法，也可以是非抽象方法



>  抽象类的子类的特点：

- 抽象类的子类可以是抽象类，也可以是具体类
- 只有当子类重写了，所有的继承自抽象类的方法，该子类才能被定义为具体类
- 反之，若任一抽象方法没有被重写，该类都必须定义为抽象类



> abstract关键字使用上的注意点（notice）

- 不能用来修饰构造器、属性、代码块等结构
- 不能用来修饰final类
  - 无法被继承的类
- 不能用来修饰私有方法、静态方法 、final方法
  - 无法被重写的方法
- 一个抽象类中可以没有抽象方法，但是意义不是很大

# 接口



- 一方面，我们有时需要从多个类中派生出一个类，继承它们所有的成员，Java语法不适用
  - Java不支持多继承
- 另一方面，我们有时候需要从几个类中抽取出共同的行为特征
  - 而它们之间并没有“is-a”关系，继承思想显得不适用

> 于是：

- 为了复用这些“特殊行为”，我们迫切需要一种新的数据格式
  - 和类相似，可以抽取出共性，定义成员
  - 不受Java多继承限制
- 这种新的数据格式就是接口



> 接口的定义

- 语法

  ```java 
  [访问权限修饰符] interface 接口名{}
  ```

- 接口不是类，而是一种独立的数据类型，和class并列

  - 一个类实现的接口，也称之为接口的子类

- 一个类继承接口，称之为实现接口，使用关键字implements

  - 语法

    ```Java
    class 类名 implements 接口名 {}
    ```

  - 当一个类继承另一个类的同时，又实现接口

    - 必须要将实现接口放在继承类后面



> 接口概述

- interface表示一种数据类型，和class同级别
  - 是一种引用数据类型
  - 区别是：
    -  类定义的是一个数据集合基于这个数据集的一组操作(行为)
       - 类所描述的这一组行为，它们是有关系的（间接），都可以访问同一个数据集合
    -  接口表示数据类型，侧重于描述一组具有特殊功能的行为，这些行为
       - 可以完全没有任何关系。接口中的方法，它们的关系比较的松散
  - 类实现接口本质上也是一种继承，接口的实现类是接口的子类
  - 接口不能实例化
  - 接口不受多继承限制，接口可以多实现



> 接口的声明特征

- 接口的声明中默认存在一个abstract，所以接口必然是抽象的
- 接口普遍声明为public 鼓励继承



> 接口的成员特征：
>
> - 成员变量
> - 成员方法
> - 构造方法

- 接口中的所有成员变量都默认是由public static final修饰的

  - 无法使用除public外的访问权限修饰符，修饰成员变量
  - 普遍来说，开发时在接口中定义成员变量省略public static final
  - 但是接口内部不支持用static代码块给成员变量初始化
    - 必须要提供显式的初始化

- 接口中的所有方法都默认是由public abstract修饰的

- （了解即可）在JDK8中引入了默认方法

  - 语法

    ```java 
    default 返回值类型 方法名{
    }
    ```

  - 默认是public修饰

  - 不能用static、abstract修饰

  - 和抽象类中的具体方法一样，接口中的方法是给子类提供了一个默认实现

    - 子类可以选择直接继承使用该方法，也可以重写
    - 可以用子类对象调用，包括多态形式

  - 抽象类中有普通方法是很正常的，但是接口中不应该有具体方法，除非

    - 为了代码的兼容考虑
    - 例如class A、B、C很多类都实现了接口ITest，现在给接口新增了一个方法
      - 但这个方法不是所有类都需要重写的
      - 如果这个方法是一个抽象方法，所有类都必须实现该方法，否则会报错
      - 为了省事，可以选择default方法
      - 实际上Java8之所以引入default方法就是为了做这种事情
      - 省事是Java开发者省事，你不要省事

- （了解即可）在JDK8中引入了静态方法

  - 语法

    ```Java
    static 返回值类型 方法名{
    }
    ```

  - 默认是public修饰

  - 不能用abstract、default修饰

  - 可以使用接口名点方法名访问

- 从技术角度来说，以上实现方法是完全合法的

  - 只是它看起来违反了接口作为一个抽象定义的理念
  - 除非特别有必要，不要使用

- 接口没有构造方法，接口中的成员变量都是常量，不需要子类调用构造方法来初始化



> 接口的子类特征：

- 如果是一个类实现了接口
  - 必须要重写接口中所有的抽象方法，除非该类是一个抽象类
  - 一个类实现了接口，就变成了接口的子类
  - 接口可以多实现，配合default方法可以实现真正意义上的多继承（最好不要这么干）
  - 如果一个类又继承类又实现接口，一定是先继承再实现，顺序不能互换
- 如果是一个抽象类实现了接口
  - 可以不重写接口中的抽象方法
  - 可以实现多个接口而不重写方法
  - 抽象类也可以继承普通类
- 如果一个接口继承了接口
  - 接口之间不能互相实现，但是可以继承
  - 接口可以多继承



> 接口使用注意事项：

- 定义Java类的语法格式：先写extends，后写implements

  - ```Java
    class SubClass extends SuperClass implements InterfaceA{
    } 
    ```

- 一个类可以实现多个接口，接口也可以继承其它接口，这就是Java当中的“多继承”

- 实现接口的类中必须提供接口中所有方法的具体实现内容，方可实例化。否则，仍为抽象类

- 接口的主要用途就是被实现类实现

  - 所以接口和接口的成员默认都是public修饰，鼓励继承，鼓励重写

- 与继承关系类似，接口与实现类之间存在多态性

- 接口和类是并列的数据类型



> 接口和抽象类的异同

| 编号 | **区别点** |                          **抽象类**                          |                 **接口**                  |
| :--: | :--------: | :----------------------------------------------------------: | :---------------------------------------: |
|  1   |    定义    |                       包含抽象方法的类                       |         抽象方法和全局常量的集合          |
|  2   |    组成    |           构造方法、抽象方法、普通方法、常量、变量           | 常量、抽象方法、(jdk8:默认方法、静态方法) |
|  3   |    使用    |                   子类继承抽象类(extends)                    |         子类实现接口(implements)          |
|  4   |    关系    |                    抽象类可以实现多个接口                    |  接口不能继承抽象类，但允许继承多个接口   |
|  5   |    对象    |                 不能创建对象，但是有构造方法                 |       不能创建对象，也没有构造方法        |
|  6   |    局限    |                      抽象类不能被多继承                      |       接口之间能多继承，能被多实现        |
|  7   |    思想    |                  作为模板或对共性抽象，is-a                  |     作为标准或对共性能力抽象，like-a      |
|  8   |    选择    | 如果抽象类和接口都可以使用的话，优先使用接口，因为避免单继承的局限 |                                           |



Java提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于：

- 接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。
- 类可以实现很多个接口，但是只能继承一个抽象类
- 类如果要实现一个接口，它必须要实现接口声明的所有方法。但是，类可以不实现抽象类声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。
- 抽象类可以在不提供接口方法实现的情况下实现接口。
- Java接口中声明的变量默认都是final的。抽象类可以包含非final的变量。
- Java接口中的成员方法默认是public的。抽象类的成员方法可以是private，protected或者是public。



​	接口就是这样的一种规范，它抽取了事物的相似行为，而不关心事物有什么关系

​		1，相比于继承抽象类的“is-a”关系，体现的是“是XX”思想，而实现接口体现的是“能够XX”的思想

​		2，接口允许多实现。实现多个接口，继承它们所有的属性和方法

​		3，**接口的本质是契约、规范、标准**



> 接口和抽象类形式参数和返回值问题

****

> 方法的形式参数（formal）在传值的时候

**1.基本类型：**对于基本数据类型的方法传参，存在自动类型提升

**2.引用类型：** 对于引用数据类型的方法传参，存在自动向上转型

- 类：调用方法时需要传入的是该类的对象或者该类的子类对象
- 抽象类：调用方法时需要传入的是该抽象类的子类对象
- 接口：调用方法时需要传入的是该接口的子类对象



> 方法的返回值类型

> 父子类方法重写中，方法声明中返回值类型的书写

**1.基本类型：**必须保持一模一样，不存在类型提升

**2.引用类型：**不必保持一模一样，存在自动向上转型

- 类：父类中的方法返回一个普通类类型
  - 子类方法中可以返回该类型
  - 也可以返回该类的子类类型
- 抽象类：父类中的方法返回一个抽象类类型
  - 子类方法可以返回该类型
  - 也可以返回抽象类的实现类类型
- 接口：父类中的方法返回一个接口类型
  - 子类方法可以返回该类型
  - 也可以返回接口的实现类类型

> 在方法中书写一个具体的返回值

**1.基本类型：**方法体中，返回一个具体的值的时候，存在自动类型提升

**2.引用类型：**方法体中，返回一个具体对象的时候，存在自动向上转型

- 类：返回该类的对象或者该类的子类对象
- 抽象类：返回抽象类的（具体）子类对象
- 接口：返回接口的（具体）子类对象

​	

**C.链式调用**（chain calls）

```java 
StudentDemo sd = new StudentDemo();
Student s = sd.getStudent();
s.show();
//类似这种形式的代码，可以写成链式调用的形式，就变成了
new StudentDemo().getStudent().show();
//结果是一样的
```

> 在Java API中，会看到很多接口都有相应的伴随类，这个伴随类中实现了相应接口的部分或所有方法，如Collection/AbstractCollection或MouseListener/MouseAdapter。在Java SE 8中，这个技术已经过时。现在可以直接在接口中实现方法。
>
> Java SE 8中，允许在接口中定义静态方法和默认方法。

> 默认方法冲突
>
> 如果先在一个接口中将一个方法定义为默认方法，然后又在超类或另一个接口中定义了同样的方法，规则如下：
>
> 1. 超类优先。如果超类提供了一个具体方法，同名而且有相同参数类型的默认方法会被忽略。确保了Java SE 7的兼容性。
> 2. 接口冲突。如果一个接口提供了一个默认方法，另一个接口提供了一个同名而且参数类型（不论是否是默认参数）相同的方法，必须覆盖这个方法来解决冲突。

> 警告：不要让一个默认方法重新定义Object类中的某个方法，如为toString或equals定义默认方法。由于“类优先”规则，这样的方法绝对无法超越Object.toString或Objects.equals。

## 接口与回调

> javax.swing.JOptionPane 1.2
>
> * static void showMessageDialog(Componenet parent, Object message)
>
>   显示一个包含一条消息和OK按钮的对话框。这个对话框将位于parent组件的中央。如果parent为null，对话框江西那是在屏幕的中央。
>
> javax.swing.Timer 1.2
>
> * Timer(int interval, ActionListener listener)
>
>   构造一个定时器，每个interval毫秒通告listener一次。
>
> * void start()
>
>   启动定时器。一旦启动成功，定时器将调用监听器的actionPerformed。
>
> * void stop()
>
>   停止定时器。一旦停止成功，定时器将不再调用监听器的actionPerformed。
>
> java.awt.Toolkit 1.0
>
> * static Toolkit getDefaultToolkit()
>
>   获得默认的工具箱。工具箱包含有关GUI环境的信息。
>
> * void beep()
>
>   发出一声铃声。

## Comparable<T>和Comparator<T>接口

> Comparable<T> 是一个功能接口，里面有个compareTo方法，实现了这个功能接口的类可以用Arrays.sort(Object o)或者Collections.sort(Object o)进行自然排序
>
> 但是别人已经写好的类要我们自然排序的话需要改别人的源代码实现接口，实现Comparable<T>接口还要同时重写保证equals方法的一致性，因为某些集合的操作用compartTo判断不相等但用equals判断相等的话也不能插入。
>
> 所以还可里利用Comparator<T>接口不用修改原有代码的情况下实现自然排序：
>
> `Arrays.sort(T[] a, Comparable<? super T> c)`直接用Lambda表达式或者匿名内部类写法
>
> 比较功能代码量多的话可用Lambda表达式指向某个已经实现的方法写法简便
>
> java.lang.Comparable<T> 1.0
>
> * int compareTo(T other)
>
>   用着个对象与other进行比较。如果这个对象小于other则返回负值；如果相等则返回0；否则返回正值。
>
> java.util.Arrays 1.2
>
> * static void sort(Object[] a)
>
>   使用mergesort算法对数组a中的元素惊醒排序。要求数组中的元素必须属于实现了Comparable接口的类，并且元素之间必须是可比较的。
>
> java.lang.Integer 1.0
>
> * static int compare(int x, int y) 7
>
>   如果x<y返回一个负整数；如果x和y相等，则返回0；否则返回一个负整数。
>
> java.lang.Double 1.0
>
> * static int compare(double x, double y) 1.4
>
>   如果x<y返回一个负数；如果x和y相等则返回0；否则返回一个负数。

比如String类实现了Comparable<String>，而且String.compareTo方法可以按字典顺序比较字符串。当我们希望按长度递增的顺序对字符串进行排序，而不是按字典顺序，肯定不能让String类用两种不同的方式实现compareTo方法。何况String 类不应该有我们来修改。

于是用Arrays.sort(T[] a, Comparable<? super T> c)，该版本需要一个数组和一个比较器为参数，比较器就是实现了Comparator接口的类的实例。

> Comparator接口包含许多静态方法来创建比较器，这些方法可以用于lambda表达式或方法引用。但我目前看不懂

# 内部类



[TOC]

> 我们现在做一个应用程序，需要描述一台电脑（Computer）中的CPU，对于电脑而言
>
> 该怎么去描述这个CPU呢？

- 它有存储设备，IO设备等等很多硬件资源组件
- CPU是电脑中最重要的组件



> 这个CPU具有以下特点：

- CPU可以调控计算中的所有硬件资源
  - CPU应该设计成一个类，并且是作为一个私有成员存在于计算机内部
- CPU需要被隐藏起来，不能直接暴露在外部，也不能独立于计算机存在
  - 根据我们现在的知识，无法实现这一点
  - 因为声明一个普通类，无法声明为private修饰
- 这个时候就想到能不能直接把CPU类丢到Computer类的内部呢？
  - 这样，有一层壳子，就能够很好的保护CPU
  - 这种嵌套定义的类，就是内部类



> 内部类的定义

- 在Java语言中类可以嵌套定义，内部类（inner class）是定义在另一类当中的类



> 内部类的概述

- 按照内部类在类中定义的位置不同：
  - 定义在成员位置的内部类，称之为成员内部类，普通成员内部类，静态内部类
  - 定义在局部位置的内部类，局部内部类，匿名内部类
- 内部类是典型的，Java从C++中拿过来但是没有经过简化的特性
  - 也就是说Java几乎照搬了C++中的内部类
  - 通过内部类可以稍微感受一下C++的语法复杂性

- 为了上课方便，我们需要统一口径，在内部类课程当中，我们统一规定
  - 像Cpu这种类我们称之为内部类（inner class）
  - Computer这种类我们称之为外围类（enclosed class）
  - Demo这种类我们称之为外部类（outside class）



## 成员内部类

> 成员内部类概述

- 成员内部类是最普通的内部类，它定义在另一个类的成员位置， 可以看成该类的一个成员

- 语法

- ```java 
  [访问权限修饰符] class EnclosedClazz{ //外围（普通）类的访问权限修饰符，只有两个，public和缺省
  	[访问权限修饰符] class InnerClazz{//内部类访问权限修饰符，有四个，和普通成员一样
      }
  }
  ```






### 成员内部类自身特点

> 成员内部类自身的特点
>
> 1，访问权限修饰符
>
> 2，成员特点
>
> 3，继承和实现



#### 权限修饰符

> 成员内部类的访问权限修饰符可以是

- public
- protected
- （default）缺省
- private



#### 成员特点

> 成员内部类的成员特点
>
> 成员变量
>
> 成员方法
>
> 构造器

- 可以定义普通成员变量，成员方法
  - 不能定义静态方法、静态成员、静态代码块
  - 可以定义全局常量（因为全局常量是编译时就加入了常量池，不触发类加载）
- 可以定义构造方法，和普通类并无差别



> 成员内部类类加载机制（重要）

- 成员内部类的类加载机制（重要）
- 成员内部类的类加载要靠创建内部类对象触发，因为成员内部类没有静态成员
  - 一个外围类中定义了成员内部类后，并不代表每个外围类对象中都会自动初始化一个内部类对象
  - 只有在外围类对象的基础上，创建内部类的对象，才会触发成员内部类的类加载
  - 也就是说，成员内部类对象依赖于外围类的对象（即成员内部类实例化是在外围类实例的基础上）
    - 任何时候都是这样，即便是反射，也没办法不创建外围类对象而创建成员内部类对象
- 成员内部类对象依赖于外围类对象而存在



#### 继承和实现

> （了解）成员内部类的继承和实现

- 内部类可以继承和实现外部的类和接口
- 甚至可以在类中定义多个普通类、抽象内部类和接口用来自己继承和实现



### 成员内部类的访问特点

> 成员内部类的访问特点
>
> - 成员内部类内部访问外围类
> - 外围类访问成员内部类成员
> - 外部类访问成员内部类成员
> - 成员内部类访问外部类成员（了解）



#### 成员内部类内部访问外围类

> 需要理解的是，成员内部类相当于外围类的成员
>
> 并且内部类对象依赖外围类，在外围类内部访问时，一定存在一个外围类对象（重要）
>
> 理解这一点，就好理解下面的现象了

- 成员内部类可以无条件访问外围类的所有成员属性和成员方法（包括private成员和静态成员）

  - 需要注意的是，当外围类中有同名的属性或者方法时，都会发生类似“隐藏”的现象

    - 即默认情况下访问的都是成员内部类的成员

  - 如果要访问外围类的同名成员，需要以下面的形式进行访问：

    - ```Java
      EnclosedClazz.this.成员变量
      EnclosedClazz.this.成员方法
      ```

- 这里有一个类似this、super一样的隐式引用，默认传给成员内部类的所有成员方法

  - 即EnclosedClazz.this
  - 该引用指向了外围类的对象



#### 外围类访问成员内部类成员

> 虽然成员内部类可以无条件地访问外围类的成员，而外围类想访问成员内部类的成员却不是这么随心所欲了
>
> 原因在于内部类访问外围类时，内部类对象和外围类对象一定都已经存在；
>
> 但外围类访问内部类时，内部类对象还不存在，所以必须手动创建内部类对象
>
> 当然如果想要访问内部类中的全局常量，直接内部类名点常量名即可

- 在外围类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象

- 再通过这个内部类的引用去访问内部类的成员

- 在外围类中创建内部类语法：最容易理解，最万能的形式如下：

  - ```Java
    EnclosedClazz oz = new EnclosedClazz();
    InnerClazz ic = oz.new InnerClazz();//该形式适合在外围类中创建内部类
    //或者
    InnerClazz ic2 = new EnclosedClazz().new InnerClazz();//该形式适合在外围类中创建内部类
    ```

  - 如果访问内部类的方法是静态的，则只能使用上述格式，因为静态方法中外围类对象可能不存在

  - 如果访问内部类的方法是普通成员方法，则可以省略创建外围类对象的过程，其语法如下

  - ```java
    InnerClazz ic = new InnerClazz();
    ```

- 在外围类中一旦创建内部类对象，使用该对象可以访问内部类的所有成员，包括私有



#### 外部类访问成员内部类成员

> 外部类要访问内部类成员，条件要苛刻的多
>
> 由于内部类属于外围类的一个成员，所以内部类受访问权限的限制

- 如果该内部类是private修饰，那么显然在任何外部类中都无法访问该内部类成员

- 如果外部类拥有内部类的访问权限，可以创建该内部类对象，来访问该内部类的成员

- 语法

- ```Java
  //该方式最全面，适合任何位置
  EnclosedClazz.InnerClazz ic3 = new EnclosedClazz().new InnerClazz();
  ```

- 和外围类创建内部类对象不同，在外部类中创建内部类对象，不能够访问内部类的私有成员



#### 成员内部类访问外部类成员（了解）

> 在成员内部类中访问外部类成员，和在普通类中访问其它类成员别无二致

- 静态成员直接类名点访问

- 普通成员需创建外部类对象
- 受访问权限控制



> 下述访问，在成员内部类的情况下，能否进行，怎么进行

- 内部类的成员方法中，去访问外围类的成员（普通或静态、私有成员）
  - 直接访问 不受访问权限限制 外围类名.this 外围类类名点.静态成员
- 内部类的成员方法中，去访问外部类的成员（普通或静态、私有成员）
  - 和普通的类访问别的类成员 一模一样 受访问权限控制
- 外围类的普通成员方法，访问内部类的成员（普通和全局常量、私有成员）
  - 直接创建内部类对象即可,然后对象名点访问 对于静态成员,直接内部类类名点访问即可 不受访问权限限制
- 外围类的静态成员方法，访问内部类的成员（普通和全局常量、私有成员）
  - 必须先创建外围类对象,然后创建内部类对象 这样才能访问内部类成员 如果是静态的 直接类名访问即可 不受访问权限限制
- 外部类的普通成员方法，访问内部类的成员（普通和全局常量、私有成员）
  - 必须创建两个对象 受访问权限限制
- 外部类的静态成员方法，访问内部类的成员（普通和全局常量、私有成员）
  - 必须创建两个对象 受访问权限限制



## 静态内部类

> 思考：怎么把一个普通成员变成一个静态成员？

- 静态内部类也是处在外围类成员位置的内部类，不同的是它需要使用static修饰

- 语法：

- ```Java
  [访问权限修饰符] class EnclosedClazz{ //外围（普通）类的访问权限修饰符，只有两个，public和缺省
  	[访问权限修饰符] static class InnerClazz{//内部类访问权限修饰符，有四个，和普通成员一样
      }
  }
  ```



### 静态内部类自身特点

> 静态内部类自身的特点
>
> 1，访问权限修饰符
>
> 2，成员特点
>
> 3，继承和实现

- 静态内部类和成员内部类的最大区别就是static关键字

- Oracle公司官网有一段文字解释静态内部类和成员内部类的区别

  - ```Java
    Nested classes that are declared static are called static nested classes. Non-static nested classes are called inner classes.
    ```

- 嵌套的static类就是静态内部类 然后不用static修饰的嵌套类 就是成员内部类

- 什么意思呢？解释一下

  - 字面意思上看，它在说静态内部类叫做嵌套类，非静态内部类（成员内部类）叫做内部类
  - 什么叫nested呢？
    - 就是直接把一个类丢到另一个类中，本来我和你没有太多的关系，我完全有能力独立的自己做一个类
    - 但是我偏做一个”寄居蟹、啃老族“，借外围类的壳子用一用，来隐藏和保护自己(猥琐)
  - 什么叫inner呢？
    - 就是我处在你的内部，是你的一部分，我了解你，我知道你的全部，没有你就没有我
    - 比如心脏和人，CPU和计算机



- 静态内部类的类加载机制（重要）
  - 静态内部类是独立存在于外围类中的
    - 创建外围类对象，不会触发静态内部类加载
    - 创建静态内部类对象，也不会触发外围类的类加载
    - 静态内部类创建对象不依赖于外围类
  - 类加载的过程对于内部类和外围类是完全独立的



#### 访问权限修饰符

> 静态内部类的访问权限修饰符可以是

- public
- protected
- （default）缺省
- private



#### 成员特点

> 静态内部类的成员特点
>
> 成员变量
>
> 成员方法
>
> 构造器

- 静态内部类可以创建普通类可以创建的所有成员，包括静态
- 体现了静态内部类的独立性



#### 继承和实现（了解）

- 静态内部类的继承与实现和成员内部类并没有太大不同
- 区别在于，静态内部类只能继承一个静态内部类，而不能继承普通类



### 静态内部类的访问特点

> 静态内部类的访问特点
>
> - 静态内部类内部访问外围类
> - 外围类访问静态内部类成员
> - 外部类访问静态内部类成员（了解）
> - 静态内部类访问外部类成员（了解）



#### 静态内部类内部访问外围类

> 静态内部类创建对象的时候，完全可能没有外围类对象
>
> 理解这一点和成员内部类的不同，就好理解下述现象了

- 静态内部类只能直接访问外围类的静态成员，包括私有
- 静态内部类如果想要访问外围类的普通成员，需要创建对象
  - 和一般类创建对象访问成员不同的是，静态内部类中创建外围类不受访问权限限制
- 静态内部类中不存在一个外围类对象的引用，该对象完全可能不存在
- 如果想要调用外围类中，和静态内部类同名的静态成员，只需要外围类名点成员即可
- 如果想要调用外围类中，和静态内部类同名的普通成员，只需要创建外围类对象，对象点即可



#### 外围类访问静态内部类成员

> 静态内部类是相对外围类独立的类，在外围类中访问静态内部类成员
>
> 除了不受访问权限限制外，和访问其他一般类并无差别

- 如果访问静态内部类中的静态成员，可以直接内部类名点，不受访问权限限制

- 如果访问静态内部类中的普通成员，需要创建内部类对象，不受访问权限限制

  - 在外围类的任何地方创建静态内部类对象，都可以用以下语法

  - 最大的区别是不需要创建外围类对象，因为是相互独立的

  - ```Java
    InnerClazz ic = new InnerClazz();
    ```



#### 外部类访问静态内部类成员

> 静态内部类在外部创建对象，可以完全独立于外围类对象，不会触发外围类的类加载

- 创建静态内部类对象

  - 语法

  - ```Java
    EnclosedClazz.InnerStaticClazz ecisc = new EnclosedClazz.InnerStaticClazz();
    ```

  - 和普通类对象访问成员一样，受访问权限限制

- 访问静态成员，无需创建对象，直接

  - ```Java
    EnclosedClazz.InnerStaticClazz.静态成员名
    ```

  - 受访问权限限制



#### 静态内部类访问外部类成员（了解）

> 在静态内部类中，访问外部类成员，和在普通类中访问其他类成员别无二致

- 静态成员，类名点直接访问
- 普通成员需创建对象访问
- 受访问权限控制



> 下述访问，在静态内部类的情况下，能否进行，怎么进行

- 内部类的成员方法中，去访问外围类的普通成员（包括私有）
  - 能，但是要通过创建对象访问，并且不受访问权限控制
- 内部类的成员方法中，去访问外围类的静态成员（包括私有）
  - 能，直接类名点访问，如果没有同名的情况下，可以直接访问，当然也不受访问权限控制
- 外围类的普通成员方法，访问内部类的成员（属性和方法包括私有成员）
  - 创建内部类对象，然后对象名访问，如果是静态的，类名直接访问，不受访问权限控制
- 外围类的静态成员方法，访问内部类的成员（属性和方法包括私有成员）
  - 创建内部类对象，然后对象名访问，如果是静态的，类名直接访问，不受访问权限控制

> 注：
>
> 当内部类不需要方位外围类对象的时候，应该使用静态内部类。
>
> 声明在接口中的内部类自动成为static和public类，（默认没有abstract 和 final）。



## 局部内部类

> 局部内部类是定义在一个方法或者一个作用域里面的类
>
> 它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内
>
> 将局部内部类看成是局部变量即可



### 局部内部类自身特点

> 静态内部类自身的特点
>
> 1，访问权限修饰符
>
> 2，成员特点
>
> 3，定义位置
>
> 4，继承和实现



#### 访问权限修饰符

- 局部内部类和局部变量一样，没有访问修饰权限，因为毫无意义，大括号已经限制了它的访问范围

- 局部内部类不能用static关键字修饰，原因和局部变量一样

  

#### 成员特点

- 局部内部类内部无法定义静态成员，局部内部类中也没有静态的概念
  - 其余变量和方法都是可以创建的
- 构造方法和普通类一致，用来给自身成员赋值



#### 定义位置

> 几乎所有的局部位置都可以使用局部内部类
>
> 包括但不限于

- 方法
- 代码块
- if分支
- for循环内部

- 局部内部类的作用：当我们在局部位置，碰到了一个麻烦的问题，需要使用类来解决
  - 但是又不希望这个类被外界知道，这种情况需要使用局部内部类
- 局部内部类在使用前要有合适的理由，不然会自找麻烦





### 局部内部类的访问特点

> 前提：
>
> - 局部内部类相当于方法的局部变量，只在方法内部生效
>
> - 要想触发局部内部类的类加载，必须在该方法内部创建该内部类对象才可以

- 若该方法是普通成员方法
  - 该局部内部类，可以无条件访问，外围类的所有成员 (原因是普通成员方法隐含this 已经有外围类对象了)
  - 局部内部类和局部变量一样，出了作用域就失效了
  - 在外围类中无法创建对象，外部类更不行，只能在方法内部创建实例
- 若该方法时静态成员方法
  - 该局部内部类，可以无条件访问，外围类的所有成员，但是需要创建外围类对象（原因是没有this）
  - 局部内部类和局部变量一样，出了作用域就失效了
  - 在外围类中无法创建对象，外部类更不行，只能在方法内部创建实例

- 要想使用局部内部类的功能，必须在该方法内部创建内部类对象，然后调用方法



### 局部内部类注意事项

- 值得注意的是：
  - Java8之前的版本中，局部内部类只能访问方法中加了final的局部变量
    - 局部内部类对象的生命周期和局部变量的生命周期是有冲突的（life cycle）
      - 局部内部类对象的有可能比局部变量存活更久
    - 为了解决冲突，JVM偷偷的帮我们把局部变量塞到了局部内部类对象的成员中了
    - 但是问题仍然存在，将局部变量复制为内部类的成员变量时，必须保证这两个变量是一样的
      - 也就是如果我们在内部类中修改了成员变量，方法中的局部变量也得跟着改变
      - 最终Java开发者选择了妥协，使用final标记局部变量，这样就不能够改变它的值了
  - Java8以后的版本，仍然也是这么做的，但是将final关键字隐藏在底层代码中了
    - 也就是说，底层代码仍然会给局部变量加final
    - 拥有局部内部类的方法的局部变量仍然是final修饰的
    - 只不过从显式变成了隐式
- 局部内部类最大的优势是对方法外部完全隐藏，除了方法本身，即便是当前类也不知道它，不能访问它
  - 这是一种极致的封装思想的体现

>  如果一定要在局部内部类中使用方法的参数且使它可变，比如一个计数器counter。补救的方法是使用一个长度为1的数组，这样既保证引用为final，又有可以操作的空间。如方法中`int[] counter = new int[1]`，内部类中可以操作`counter[0]++`。



### 局部内部类的经典使用

> 写方法返回接口或者抽象类的具体子类

```Java
class Enclosed3Clazz{
    public A getA(){
        class AImpl implements A{
            @Override
            public void test() {
            }
        }
        return new AImpl();
    }
}
interface A{
    void test();
}
```



> 补全程序，使得可以输出三个num

```Java
class Outer {
    public int num = 10;
    class Inner {
        public int num = 20;
        public void show() {
            int num = 30;
            System.out.println();
            System.out.println();
            System.out.println();
        }
    }
}
```







## 内部类的优缺点和使用场景

> Java 1.1版本就引入了内部类（原属于C++）的概念，虽然很多人觉得内部类的引入让Java程序的扩展性提升了
>
> 但也有很多人觉得内部类的引入违背了Java简化C++的初衷，因为内部类的语法过于复杂
>
> 以至于让人提不起兴趣去使用，那么这样看似精致巧秒、实则复杂没必要的设计，到底有什么意义呢？
>
> 思考，接下来几个内部类的使用场景以及内部类的缺点

- 场景一：无条件地访问外围类的所有元素（优点）
  - 无论是成员内部类、静态内部类、局部内部类还是匿名内部类都可以无条件访问
- 场景二：隐藏类
  - 可以用private、protected修饰类
  - private修饰成员内部类、提供public的创建对象方法
- 场景三：实现多继承
  - 可以创建多个成员内部类继承外部多个类
  - 然后创建内部类对象，实际上就是外围类继承了多个类的成员
- 场景四：通过匿名内部类来优化简单的接口实现
  - 重点：内部类要说使用频率 最高的肯定是匿名内部类

> 内部类的缺点

- 内部类的缺点也是显而易见，语法很复杂，在类中定义内部类也会导致类的结构变复杂，影响代码可读性
  - 除此之外，不合理使用内部类还可能导致内存泄漏（了解）
    - 如果当内部类的对象被外围类以外的其他类引用时，就会造成内部类和外围类无法被GC回收的情况



# 匿名内部类（对象）

> 以往当需要一个子类对象的时候，我们需要分两步走
>

- 定义子类继承（实现）父类（接口）
- 创建子类对象
- 那么有没有一步直达的方式呢？
  - 我们可以通过局部内部类得到一个实现子类
  - 如果把局部内部类更进一步，变成匿名（局部）内部类呢？

​	

## 匿名内部类的创建

- 首先明确两点使用匿名内部类的前提

  - 匿名内部类是特殊的局部内部类，所以匿名内部类必须定义在局部位置
    - 匿名内部类是局部内部类的更进一步
    - 匿名内部类的成员特征、访问特征和局部内部类没有区别
    - 匿名内部类访问方法的局部变量时，该变量仍然是常量
  - 存在一个已定义类或者接口，这里的类可以是具体类也可以是抽象类

- 语法：

- ```Java
  new 类名或者接口名(){
      //重写方法
  };
  ```

- 注意右大括号的结尾分号，不可省略

- 匿名内部类的本质是继承了一个（抽象）类或者实现了接口





## 匿名内部类对象的使用

- 直接使用对象去调方法即可
  - 也可以用父类接收，但是父类接收无法调用子类独有方法
- 当我们只使用一次某类或者某接口的，子类对象，此时用匿名内部类对象，会稍微方便一点
- 但是，如果要多次访问，匿名内部类对象中的成员，就比较麻烦了
  - 因为每一次访问都得创建一次匿名内部类对象
- 通常，在只使用一次类、接口的子类对象的情况下，比较适合使用匿名内部类对象来完成
- 本质：是一个继承了类或者实现了接口的子类匿名对象



## 开发中的匿名内部类

- 作为方法的实际参数
  - 学习多态的时候我们曾经讲过，可以将父类作为形式参数，而将子类作为实际参数在方法调用的时候传入
  - 匿名内部类的匿名对象就是一个子类匿名对象，所以，可以使用匿名内部类改进以前的做法
- 在方法体中，作为方法的返回值
  - 方法体中，return 返回值只会执行一次，如果方法返回一个接口类型的对象，我们也可以使用匿名内部类





## 匿名内部类的使用优缺点

- 当我们只使用一次某类或者某接口的子类对象时，使用匿名内部类，会方便一点，简洁一点
- 如果需要多次访问子类对象的成员，必须要接收这个匿名内部类对象，否则会更麻烦
  - 需要用匿名内部类对象的父类接收
  - 无法访问匿名内部类中的独有方法
- 如果访问匿名子类中的独有方法，必须用匿名对象去访问，就无法用引用去接收了



> 内部类是一种编译器现象，与虚拟机无关。编译器会把内部类翻译成用$分隔外部类名与内部类名的常规类文件，而虚拟机则对此一无所知。

> 匿名内部类可用于生成日志时获取当前类名。`System.out.println(getClass());`对于静态方法不奏效，`System.out.println(new Object(){}.getClass().getEnclosingClass());`在静态方法中也有效。



## lambda表达式

> Lambda 表达式是 JDK8 的一个新特性，可以取代接口的匿名内部类，写出更优雅的 Java 代码
>
> 匿名内部类实际上是局部内部类的更进一步，简化了局部内部类
>
> 那么lambda就是匿名内部类更进一步，语法上更简洁了
>



> lambda表达式基本使用：

- 若想使用lambda简化接口的匿名内部类，需要该接口是一个功能接口
  - 有且仅有一个抽象方法的接口称之为功能接口（**FunctionInterface**）
    - 功能接口有一个专门的注解标记它，写在接口声明的上面，就叫**@FunctionInterface**
    - 这个注解可以用来验证该接口是不是功能接口
  - Java8以后接口中可以使用静态方法和默认方法，所以严格来说功能接口可以允许不止一个方法
    - 但是普遍来说，功能接口应该仅有一个方法，就是那个抽象方法
- 下面给出六个接口，都是常见的功能接口形式

```java
//无返回值无参数的功能接口
@FunctionalInterface
interface INoReturnNoParam {
    void test();
}

//无返回值有一个参数的功能接口
@FunctionalInterface
interface INoReturnOneParam {
    void test(int a);
}

//无返回值两个参数的功能接口
@FunctionalInterface
interface INoReturnTwoParam {
    void test(int a, int b);
}

//有返回值无参数的功能接口
@FunctionalInterface
interface IHasReturnNoParam {
    int test();
}

//有返回值一个参数的功能接口
@FunctionalInterface
interface IHasReturnOneParam {
    int method(int a);
}

//有返回值两个参数的功能接口
@FunctionalInterface
interface IHasReturnTwoParam {
    int test(int a, int b);
}
```

- 接口准备完毕后，就可以开始使用lambda表达式了

- lambda基础语法

  ```java
  (接口中那个抽象方法的形参列表) -> {
  	//这里面重写这个抽象方法,也就是方法体
  }
  ```

- 基础语法解释

  - () 小括号中要写接口中抽象方法的形参
  - -> 是lambda运算符，读作“goes to”
  - {}表示重写的方法的方法体
  - {}只有一对，只能重写一个方法；()参数列表也只有一个，所以要求功能接口必须只有一个抽象方法
  - **注意：整个lambda表示式表示功能接口的一个实现类对象**

- **重要：lambda表达式的类型推断**

  - 按照以上语法，直接写完代码，肯定是要报错的
  - 因为编译器无法仅仅通过这个基础语法，就判断出这个lambda表达式究竟创建的是哪个接口实现类对象
  - 由于Java是强类型语言，所以必须在编译时期就确定该对象的数据类型
    - **编译器去确定lambda表达式（对象）的数据类型的过程称之为lambda表达式的类型推断**
  - **实际上编译器是通过，lambda表达式所处的上下文代码去判断其类型的**
  - **最简单的方式就是直接用目标功能接口接收这个lambda表达式，让编译器直接明确其数据类型**

- 至此就完成了lambda表达式的基本使用



> lambda表达式继续简写
>
> lambda表达式的目标接口，有且仅有一个抽象方法，这是lambda表达式继续简化的前提

- ()里的参数列表肯定是固定的，于是可以省略形参中的数据类型，仅写形参名
  - 在上面的基础上，如果抽象方法的形参只有一个，小括号()也可以省略
- 如果{}中的方法体仅有一句，大括号可以省略
  - 在上面的基础上，如果方法有返回值，且返回值return语句仅有一条，那么连return都可以省略




> lambda表达式去引用一个已经实现的方法
>
> 有时候功能接口中的方法已经有实现了，如果不想自己再去重写这个方法
>
> 可以利用 lambda表达式的接口快速指向一个已经被实现的方法

- 语法

  - ```Java
    (接口中那个抽象方法的形参列表) -> 已实现的某个方法
    ```

- 更进一步简写

  - ```Java
    方法归属者::方法名 
    ```

  - **静态方法的归属者为类名，普通方法归属者为对象名**



> lambda表达式的优缺点

- 优点：
  - 极大得简化了代码，使代码变得更加优雅
  - 函数式编程的代表，可能是未来高端的编程趋势
- 缺点：
  - 过于简单的lambda表达式，显然可读性很低

> 注意不能把Lambda表达式赋值给Object的变量，Object不是一个函数式接口。

> Java API在java.util.function包中定义了很多非常通用的函数式接口。不过对于Java程序员而言，想要用lambda表达式做某些处理，还是要谨记表达式的用途，为它建立一个特定的函数式接口。
>
> java.util.function包中有一个尤其有用的接口Predicate。
>
> public interface Predicate<T>{
>
> ​	boolean test(T t);
>
> //Additional default and static methods
>
> }
>
> 这个接口专门用来传递lambda表达式。例如ArrayList类有一个removeIf方法的参数就是一个Predicate。
>
> list.removeIf(e -> e == null);//从一个数组列表删除所有null值。

lambda表达式内作用域在方法中，可以使用所在方法中已经定义的变量，但是和内部类同样受到限制，即方法中的局部变量已经lambda表达式使用，该变量便隐式成为一个effectively final（最终变量），就常量，无论在lambda表达式内，还是lambda表达式后的方法体内该变量的值都不允许改变，否则不允许捕获该变量。

同上原因，lambda表达式中this关键字是指创建这个lambda表达式的方法的this参数，而不是函数式接口的实例。

最好参考基本类型的函数式规范来减少自动装箱。

# Object引入

Application Programming Interface(API)：应用程序编程接口，在Java当中指的是一些预先定义好的类和方法

​	作用：开发者可以在不关注具体实现细节的前提下，使用这些已经预先定义好的类和方法实现自己的需求

​	分类：

​				1，JDK中自带的，可以通过官方API文档去学习

​				2，开发者编写的，依赖于开发者之间去沟通



Object类概述：

​	1，Object类是所有类继承层次的祖先类，所有类（包括数组）都直接或者间接的继承自该类，都实现了该类的方法

​	2，但是我们在自定义类时，并不需要特别标注extends Object

​	3，如果一个类没有明确的指出它的父类，Object类就默认被认为是这个类的父类，extends Object则被省略了



为什么所有类都有一个默认无参？

​		1，当一个类没有定义构造方法的时候，就会自动添加默认构造方法

​		2，一旦有默认构造方法，在创建子类对象的时候，就会执行子类对象的隐式初始化

​		3，隐式初始化，默认调用父类的无参构造

​		4，所以最终，一定能保证，调用到Object类的无参构造方法，先初始化Object这个父类

​	

Object的成员方法：

​	1，public final Class getClass()

​	2，public String toString()

​	3，public boolean equals(Object obj)

​	4，public int hashCode()

​	5，protected void finalize() (不重要)

​	6，protected Object clone()



Object数组可以装所有引用类型

讲string的时候，输出char数组名

# getClass()

> public final Class<?> getClass()
>
> getClass()概述

- 语法

  ```java
  对象名.getClass();
  ```

- 其作用是返回调用此方法的Object的运行时类（的Class对象）





> 什么是Class对象？

- 需要注意的是Class首字母大写，这是一个类的对象，和String一样
- JVM每加载一个类，都会在内存中创建唯一一个和该类对应的Class对象
  - 这个Class对象包含了这个类的全部信息
  - 帮助程序员在运行时期，了解该对象的属性和行为
  - Class对象处于堆上
  - **在运行时期程序员可以通过这个类，获取该类型的所有信息**
- 由于Class对象和类是一一对应的，所有Class对象很多时候被称为类对象
  - Class对象和方法区中加载的字节码文件，都是在触发类加载的时候生成的
  - 类加载只会触发一次，Class对象也只独一份
- 类的对象和类对象的区别
  - 一个类的Class对象叫做类对象，也称之为运行时类对象，**整个程序运行期间独一份**
  - 类的对象是类的一个实例，程序运行期间可以创建多个
- Class类对象是反射的基础
  - 反射实质就是Class类的API使用

​	

> Class类的常用API

- getName()
  - 获取类的全限定类名
- getSimpleName()
  - 获取类名

# toString()

>  public String toString()
>
>  toString()概述

- 语法

  ```Java
  对象名.toString()
  ```

- 返回该对象的字符串（String）表示

- 通常，toString 方法会返回一个“以文本方式表示”此对象的字符串

- 结果应是一个简明但易于读懂的信息表达式	

- 建议所有子类都重写此方法



> 总结来说

- toString()方法就是简洁明了的一句话告诉我们这个对象长啥样
- 建议在子类中都重写这个方法
- 对象的成员变量就是描述对象的外貌特征的
- 理想情况下，我们希望这个方法能够输出对象中所有成员变量的取值



> toString的使用
>
> 回想一下，我们之前直接打印数组名或者对象名，得到的是什么？

- 当我们直接打印数组名或者对象名时
  - 其实都默认隐含了调用toString()方法，输出toString()方法返回的字符串
- 这个时候我们并没有重写toString()方法，打印的是全限定类名加地址值

> Object类当中的toString()方法

- Object类的toString()方法返回一个字符串

  - 该字符串由类的全限定类名、at标记符“@”和此对象十六进制地址值组成

  - ```Java
    getClass().getName() + '@' + Integer.toHexString(hashCode()
    ```



> Object类的toString()方法往往不能满足我们的需求
>
> 我们需要自己重写toString()方法，这也是官方给我们的建议

- 常见的toString()方法的格式

  - ```Java
    对象所属类型{成员变量1 = '值1' ,成员变量2 = '值2'....}
    ```

- 一个类重写toString()后再打印对象名，就会自动调用该方法



> 注意事项

- 直接打印数组名或者对象名，默认调用toString()方法，然后打印该方法返回的字符串
- 用一个字符串和一个对象直接拼接，默认拼接该类的toString()方法字符串
- debug时下一步会打印toString()返回的字符串
  - 不要在toString()方法里对对象进行操作，避免造成奇怪的bug
- 如果类中有别的引用类型，可以在返回语句中调用该引用类型的toString()方法

> 数组的toString直接继承了Object的，修正的方式是调用静态方法Arrays.toString,多为数组调用Arrays.deepToString

> java.lang.Class 1.0
>
> * String getName()
>
>   返回这个类的名字。
>
> * Class getSuperclass()
>
>   以Class对象的形式返回这个类的超类信息。

# equals()

> public boolean equals(Object obj)
>
> equals() 概述

- 语法

  ```Java
  对象名.equals(其他对象名)
  ```

- 指示其他某个对象是否与此对象“相等”

  - 此对象：调用equals() 方法的对象
  - 其他某个对象：equals() 方法括号中的对象

- 对象相等的含义

  - 我们理想状态下的对象相等
    - 首先两个对象的类型要相同，如果类型都不想同，那就没有意义了
    - 类型相同的情况下，比较成员变量的取值是否相等，都相等则认为两个对象相等
  - Object类中的相等
    - 只有两个对象的内存地址相等，才叫相等
    - Object类中的equals()方法等价于”==“
    - 对象存在堆上没有办法直接拿出来比，于是”==“比较的是两个对象的引用
    - 两个引用变量是否相等，取决于它们是否指向了同一对象，也就是比较对象的内存地址
  - Object类中的equal()方法不能满足我们需求，需要自己手动重写该方法



> 设计equals() 方法的原则（常规协定）

- 自反性：对于任何非空引用值 x，x.equals(x) 都应返回 true
- 排他性：当比对的不是同种类型的对象或者是一个null时，默认返回false
- 对称性：对于任何非空引用值 x 和 y，当且仅当 y.equals(x) 返回 true 时，x.equals(y) 才应返回 true
- 传递性：对于任何非空引用值 x、y 和 z，如果 x.equals(y) 返回 true，并且 y.equals(z) 返回 true
  - 那么x.equals(z) 应返回 true
- 一致性：对于任何非空引用值 x 和 y，多次调用 x.equals(y) 始终返回 true 或始终返回 false
  - 前提是对象上equals 比较中所用的信息没有被修改
- 其实只要按照下述原则重写，就能够满足上面的常规协定
  - 若是不同类型的对象，直接认定不相等
  - 若是相同类型的对象，认为具有相同的成员变量的两个对象，才是相等的



判断是否是同种类型对象的两种方式：

当传入一个o作为被比较的对象时

```
1,if (!(o instanceof 这个类))
2，if (o == null || this.getClass() != o.getClass())
```



equals方法使用注意事项：

​		1，对于任何非空引用值 x，x.equals(null) 都应返回 false

​		2，不要使用一个null常量，调用方法，会引发程序错误

​				在方法中，我们只能对方法的参数进行校验，没办法校验调用者

​				应该在外部写代码，防止使用一个null去调用方法

​		3，如果类中有引用类型的成员变量，继续调用该引用类型的equal()方法判断



补充知识点：

Double类和Float类中的compare() 方法：

​	1，调用方式：Double.compare(doule d1,double d2)   Float.compare(float f1,float f2) 

​	2，作用：

​		如果这两个数字数学意义上相等，则返回 0

​		如果前者在数字上小于后者，则返回小于 0 的值

​		如果前者在数字上大学后者，则返回大于 0 的值



财务金额上使用的确保精度的数字类型：

​	如果使用double或者float作为金额的数据类型，会出现一些不可预知的精度问题。

​	推荐使用BigDecimal这个类

# hashCode()

> public int hashCode()
>
> hashCode() 概述

- 语法

  ```Java
  对象名.hashCode()
  ```

- 通过一个哈希（散列）函数，返回该对象的哈希（码）值

- 支持此方法是为了提高哈希表的性能（主要是集合体系中用）



> 映射的概念

- 设A和B是两个非空集合，并存在某种对应关系f
- 按照这种对应关系f，对于集合A中的任何一个元素a，在集合B中都存在唯一的一个元素素b与之对应
- 那么，这样的对应（包括集合A，B，以及集合A到集合B的对应关系f）叫做集合A到集合B的映射

> 总得来说

- 在映射的定义中，集合A中的任一元素都在集合B中有唯一元素对应
- 函数是特殊定义的映射
  - 在中学数学中，集合A和B都必须是数集，而在高等数学中，只有值域被限制为数集



> 通过映射的定义，我们引入hash相关概念

- 哈希函数
  - 把任意（不限制）大小的数据集合A中的元素a，唯一地映射到固定大小集合B中的元素b上
  - 这种对应关系，称之为哈希函数（方法）或者哈希算法
- hashCode()方法的哈希函数
  - 任意数据大小的集合就是对象的集合，固定大小的数据集合int
  - 不同的对象返回不同的整数

- 哈希值
  - 由哈希函数从集合A唯一映射到的集合B中的元素，被称之为哈希值

- 哈希冲突
  - 理想状态下的哈希函数，除了应该满足映射定义，唯一的将集合A中的元素映射到集合B中外
    - 我们还希望集合A和B中元素**最好能够**一一对应
  - 然而实际情况中，总是会存在两个集合A中的不同元素映射到了集合B中的同一个元素上
    - 这种现象，我们称之为：“hash冲突”

​		

> Object类中hashCode()方法

- 该方法是一个native方法，本地方法

- 通过将该对象的内部地址转换成一个整数来实现，但是不是通过Java语言去实现（C/C++）



> Object类中的hashCode()方法不能满足我们的需求

hashCode 的常规协定是： 

​		1，在 Java 应用程序执行期间，在对同一对象多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是将对

象进行 equals 比较时所用的信息没有被修改（哈希值是根据成员变量来计算的）。从某一应用程序的一次执行到同一应

用程序的另一次执行，该整数无需保持一致。 

​		2，如果根据 equals(Object) 方法，两个对象是相等的，那么对这两个对象中的每个对象调用 hashCode 方法都必须

生成相同的整数结果。 

​		3，如果根据 equals(java.lang.Object) 方法，两个对象不相等，那么对这两个对象中的任一对象上调用 hashCode 方

法不 要求一定生成不同的整数结果。但是，程序员应该意识到，为不相等的对象生成不同整数结果可以提高哈希表的性能。 



> 扩展
>
> hashCode()方法是会返回一个对应于当前对象的一个整数，为了将来在集合中更快捷的查找对象

- 集合类似于数组，但不同的是集合中只能装对象
- Java中的集合类 hashMap、hashSet 底层的实现都是哈希表，之所以采用哈希表
  - 是因为他能克服链表和二叉树等数据结构在查询上的低效率问题
  - 哈希表的存储，就是根据对象的哈希值，以此确定他的存储位置

# finalize()

> 方法的源代码

```java
protected void finalize()  throws Throwable {  }
```

- Object()类当中的finalize()方法是protected权限，并且是空的
- 完全可以看得出来，该方法需要子类自己重写去实现功能
- 这种方法比接口的抽象方法要自由，因为它不是强制的



> 该方法的调用时机和功能

- 当一个对象成为匿名对象，不存在任何引用指向它时

  - 它就成为了一个垃圾对象

- Java的垃圾回收器就开始准备回收该对象，释放内存空间

- 但是垃圾回收器只能回收Java相关的内存空间（new出来的对象）

  - 那些该对象获取的特殊内存空间（非Java的系统资源）垃圾回收器无法直接回收
  - 于是调用该方法去释放一些和Java没有关系的系统资源（需要子类重写）
    - 这里需要子类重写finalize()才能达到效果
    - JVM在回收new对象空间之前会自动调用finalize方法，并且只会调用一次
  - 比如说对象调用的IO资源，调用native方法开辟的空间等等
    - Scanner

- 整个垃圾回收期间，只会被调用一次

- 综上

  > 一旦垃圾收集器准备释放对象占用的存储空间，将首先调用其finalize()方法，进行一些必要的清理工作
  >
  > 在调用该finalize()方法释放其他资源后，jvm会再一次的执行检查该对象是否还存在其他引用
  >
  > 并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存（new出来的对象）
  >
  > 所以可以在子类中重写该方法，然后作为释放对象持有其他资源的手段



> 总结：

- finalize()方法是典型的Java拿来C++机制想要使用，但是失败的案例
  - C++析构函数是指对象在销毁前自动执行的方法，是为了给对象的销毁做最后的收尾工作
  - 比如释放系统资源（这里显然C++胜出）
- 但是Java的垃圾回收机制不是手动的，而是自动的。对象的销毁，垃圾回收具有不确定性
- 而只有在真正要销毁（new出来的）对象之前才会调用finalize()方法
- 所以使用finalize()给对象销毁做”善后“操作，也是不确定的，不安全的，低效率的
- 所以应该避免使用finalize()方法去释放系统资源，**而是在使用完毕后，手动去关闭这些资源**
- 这是自动垃圾回收便利的代价，你不得不放弃对系统资源释放的控制



> 这玩意没用，但是知道它可以增长见识

- thinking in java
- GC

# clone()

> 概述

- protected Object clone() 
- 语法：对象名点clone();
- 创建并返回此对象的一个副本（对象的引用）
- 该副本和原对象具有相同的属性



> 使用clone()方法注意事项

- protected权限问题
  - 在一个类中创建自身对象，然后调用clone()拷贝，无需重写clone() 方法
  - 在其他类中克隆一个类的对象，需要重写clone()方法权限
- 要想使用一个类的clone() 方法，这个类都必须实现Cloneable接口
  - 否则抛出CloneNotSupportedException异常

- 使用clone() 方法创建对象，和new创建对象属于同等级别的Java中创建对象的方式
  - clone()方法创建对象是调用native方法，不调用构造方法
- 返回值类型是一个Object对象，必要的时候要进行强转



> clone() 方法对该副本的要求：

​	对于任何对象 x，表达式： 

​		1，x.clone() != x 为 true（这一条是必须的）

​		2，x.clone().getClass() == x.getClass() 为true

​		3，x.clone().equals(x) 为true（一般情况下为true，但这并不是必须要满足的要求）



Cloneable接口：

​	1，该接口是一个标记接口，没有任何方法

​	2，空（标记）接口的意义：

​			a，实现空接口后，从成员角度，该类没有任何变化

​			b，但是在内存中，该类的数据类型已然发生了改变，成为了这个接口的一个实现类

​	3，空接口的作用：

​			a，空接口给该实现类打上了标记

​			b，使用 instanceOf 运算符，可以判断一个类是否是该空接口的实现类

​			c，如果判定是，可以进行一系列操作



浅拷贝和深拷贝：

​	1，浅拷贝：

​			a，被复制对象的，所有基本类型成员变量值，都与原来对象的相同，且独立

​			b，被复制对象的，所有引用类型的引用，仍然指向原来的对象，相当于复制了对象引用，而没有复制对象

​	2，深拷贝：

​			在浅拷贝的基础上，复制对象引用的同时，也复制了对象，并让复制的引用指向了复制的对象

​	3，Object类当中的clone() 方法只是浅拷贝

​	4，深拷贝基于浅拷贝实现，需要我们手动重写clone() 方法实现

​	

> 所有数组类型都有一个public的clone方法，而不是protected。可以用这个方法建立一个新数组，包括原数组所有元素的副本。

# Object类：所有类的超类

## equals方法

> Object a.equals(Object b)方法用于检测两个对象是否具有相同的引用。作为默认操作合乎情理，但对多数类来说完全没有意义。

例如需要比较Student类的两个对象是否相等，需要重写equals方法，比较id或者name是否相等才具有实际意义。

用超类属性进行相等校验可以使用instanceof先检查类型

用子类特有属性相等校验可以使用getClass()来检查类型

> Objects.equals(Object a, Object b)方法可以防止空指针

完美编写equals方法的建议：

```java
1 显示参数命名为otherObject，稍后需要将它转换成另一个叫做other的变量。
2 检测this与otherObject是否引用同一个对象：
if(this == otherObject) return true;
这条语句只是一个优化。实际上，这是一种经常采用的形式。因为计算这个等式要比一个一个地比较类中的域所付出的代价小得多。
3 检测otherObject是否为null，如果为null，返回false。这项检测是很有必要的。
if(otherObject == null) return false;
4 比较this与otherObject是否属于同一个类。如果equals的语义在每个子类中有所改变，就是用getClass检测：
if(getClass() != otherObject.getClass()) return false;
如果所有的子类都拥有统一的语义，就是用instanceof检测：
if(!(otherObject instanceof ClassName)) return false;
5 将otherObject转换为相应的类类型变量：
ClassName other = (ClassName) otherObject
6 现在开始对所有需要比较的域进行比较了。使用==比较基本类型域，使用equals比较对象域。如果所有的域都匹配，就返回true；否则返回false。
return field1 == other.field1 && Objects.equals(field2, other.field2) && ...
如果在子类中重新定义equals，就要在其中包含调用super.equals(other)。
//提示：对于数组类型的域，可以使用静态的Arrays.equals方法检测相应的数组元素是否相等。
//Double.compare(a,b)比较两个浮点数
```

> java.util.Objects 7
>
> * static boolean equals(Object a, Object b)
>
>   如果a和b都为null，返回true；如果只有其中之一为null，则返回false；否则返回a.equals(b)。
>
> java.util.Arrays 1.2
>
> * static Boolean equals(type[] a, type[] b) 5.0
>
> 如果两个数组长度相同，并且在对应位置上的数据元素也均相同，将返回true。数组的元素类型可以是Object、int、short、char、byte、boolean、float或double。

## hashCode方法

> 散列码（hash code）是由对象导出的一个整型值。散列码是没有规律的。如果x和y是两个不同的对象，x.hashCode()与y.hashCode()基本不会相同。
>
> 如果重新定义equals方法，就必须重新定义hashCode方法，一边用户可以将对象插入到散列中。
>
> hashCode方法应该返回一个整形数值（可以为负），并合理地组合实例域的散列码，以便能够让不同对象产生的散列码更均匀。
>
> 最好使用null安全的方法Objects.hashCode。如果其参数为null，该方法返回0，否则返回参数调用的hashCode的结果。另，使用静态方法Double.hashCode来避免创建Double对象：
>
> 写法：
>
> ```java
> public int hashCode() {
>     return 7 * Objects.hashCode(name)
>         + 11 * Double.hashCode(salary)
>         + 13 * Objects.hashCode(hireDay);
> }
> ```
>
> 比
>
> ```jade
> public int hashCode() {
> 	return 7 * name.hashCode()
> 	+ 11 * new Double(salary).hashCode()
> 	+ 13 * hireDay.hashCode();
> }
> ```
>
> 好
>
> 更好的，需要组合多个散列值时，可以调用Objects.hash并提供多个参数。这个方法会对各个参数调用Objects.hashCode，并组合这些散列值。这样就能简单地写为：
>
> ```java
> public int hashCode() {
>     return Objects.hash(name, salary, hireDay);
> }
> ```
>
> equals与hashCode的定义必须一致：如果x.equals(y)返回true，那么x.hashCode()就必须与y.hashCode()具有相同的值。
>
> 如果存在数组类型的域，那么可以使用静态的Arrays.hashCode方法计算一个散列码，这个散列码由数组元素的散列码组成。
>
> java.util.Object 1.0
>
> * int hashCode()
>
>   返回对象的散列码。散列码可以是任意的整数，包括正数或负数。两个相等的对象要求返回相等的散列码。
>
> java.util.Objects 7
>
> * static int hash(Object... objects)
>
>   返回一个散列码，由提供的所有对象的散列码组合而得到。
>
> * static int hashCode(object a)
>
>   如果a为null返回-，否则返回a.hashCode()。
>
> java.lang.(Integer|Long|Short|Byte|Double|Float|Character|Boolean) 1.0
>
> * static int hashCode((int|long|short|byet|double|float|char|boolean)) 8
>
>   返回给定的散列码。
>
> java.util.Arrays 1.2
>
> * static int hashCode(type[] a) 5.0
> * 计算数组a的散列码。组成这个数组的元素类型可以是object, int,long,short,char,byte,boolean,float或double。

# 泛型数组列表

语法

```java
ArrayList<Student> students = new ArrayList<Student>();
在Java SE7中，可以省去右边的类型参数；
ArrayList<Student> students = new ArrayList<>();
```

>  注：Java SE 5.0以前版本没提供泛型类，在5.0版本以后没有<...>然然可以使用ArrayList，它将被认为是一个删去了类型参数的“原始”类型。

> 注：Java的老版本中，程序员使用Vector类实现动态数组。不过，ArrayList类更加有效，没有任何理由一定要使用Vector类。

> 如果已经清楚或者能够估计出数组可能存储的元素数量，可在填充数组之前调用ensureCapacity方法或者直接在new的时候把初始容量传给ArrayList构造器
>
> 或者当一旦能够确认数组列表的大小不再发生变化，就可以调用trimToSize方法。此方法将存储区域的大小调整为当前元素数量所需要的存储空间数目。垃圾回收器将回收多余的存储空间。
>
> 一旦整理了数组列表的大小，添加新元素就要花时间再次移动存储块，所以应该再确认不会添加任何元素时，在调用trimToSize。

> java.util.ArrayList<E> 1.2
>
> * ArrayList<E>()
>
>   构造一个空数组列表
>
> * ArrayList<E>(int initialCapacity)
>
>   用指定容量构造一个空数组列表。
>
>   参数：initialCapacity 数组列表的最初容量
>
> * boolean add(E obj)
>
> * 在数组列表的尾端添加一个元素。永远返回true。
>
>   参数：obj 添加的元素
>
> * int size()
>
>   返回存储在数组列表中的当前元素数量。（这个值将小于或等于数组列表的容量。）
>
> * void ensureCapacity(int capacity)
>
>   确保数组列表在不重新分配存储空间的情况下就能够保存给定数量的元素。
>
>   参数：capacity 需要的存储容量
>
> * void trimToSize()
>
>   将数组列表的存储容量消减到当前尺寸。

> 原始的ArrayList存在一定危险性。其get方法别无选择只能返回Object，因此，get方法的调用者必须对返回值进行类型转换；它的add和set方法允许接受任意类型的对象，编译不会给出任何警告，只有在检索对象并试图对他进行类型转换时，才会发现有问题。如果使用ArrayList<Student>，编译器就会检测到这个错误。

> 对数组列表实施插入和删除元素的操作效率比较低。对于小型数组，不必担心。但如果存储的元素比较多，又经常需要在中间位置插入、删除元素，就应该考虑使用***链表***。

> java.util.ArrayList<T> 1.2
>
> * void set(int index, E obj)
>
>   设置数组里表指定位置的元素值，这个操作将覆盖这个位置的原有内容。
>
>   参数：index 位置（必须介于0~size()-1之间）obj 新的值
>
> * E get(int index)
>
>   获得指定位置的元素值。
>
>   参数：index 获得的元素位置（必须介于0~size()-1之间）
>
> * void add(int index, Eobj)
>
>   向后移动元素，以便插入元素。
>
>   参数：index 插入位置（必须介于0~size()-1之间） obj 新元素
>
> * E remove(int index)
>
>   删除一个元素，并将后面的元素向前移动。被删除的元素由返回值返回。
>
>   参数：index 被删除的元素位置（必须介于0~size()-1之间）

# 对象包装器与自动装箱

所有基本类型都有一个与之对应的包装器类。对象包装器类是不可变的，一旦构造了包装器，就不用交内需更改包装在其中的值。对象包装器类还是final，也不能定会一他们的子类。

数组列表的类型不能时基本类型但可以时包装器类型。但包装器数组列表效率远远低于基本类型的数组。但应该用它构造小型集合，给程序员操作的方便性比执行效率更重要。

包装对象的==运算检测的是对象是否指向同一个储存区域，因此比较两个包装器对象时应调用equals方法。因为自动装箱规范要求boolean、byte、char<=127，介于-128~127之间的short和int被包装到固定的对象中，所以在这之间的包装对象用==比较的结果才成立。

包装类型和基本数据类型的自动装箱和自动拆箱时编译器认可的，而不是虚拟机。编译器在生成类的字节码时插入必要的方法调用，虚拟机只是执行这些字节码。

包装类可以为null，要注意自动拆箱时的空指针异常。

注：包装类并不能改变Java的值传递，包装对象是不可变的。如果想要编写一个修改数值参数值的方法，可使用在org.omg.CORBA包中定义的持有者（holder）类型，包括IntHolder、BooleanHolder等。每个持有这类型都包含一个公由（！）域值，通过它可以访问存储在其中的值。（这和自己写个对象拷贝引用修改属性的原理一样）

> java.lang.Integer 1.0
>
> * int intValue()
>
>   以int的形式返回Integer对象的值（在Number类中覆盖了intValue方法）。
>
> * static String toString(int i)
>
>   以一个新String对象的形式返回给定数值i的十进制表示。
>
> * static String toString(int i, int radix)
>
>   返回数值i的基于给定radix参数进制的表示
>
> * static int parseInt(String s)
>
> * static int parseInt(String s, int radix)
>
>   返回字符串s表示的整形数值，给定字符串表示的是十进制的整数（第一种方法），或者是radix参数进制的整数（第二种方法）。
>
> * static Integer valueOf(String s)
>
> * static Integer valueOf(String s, int radix)
>
>   返回用s表示的整型数值进行进行初始化后的一个新Integer对象，给定字符串表示的是十进制的整数（第一种方法），或者是radix参数进制的整数（第二种方法）。
>
> java.text.NumberFormat 1.1
>
> * Number parse(String s)
>
>   返回数字值，假设给定的String表示了一个数值。

# 枚举

枚举的声明定义类型是一个类，{}里的每一个枚举常量实际上都是这个类的一个***实例***。比较两个枚举类型的值时，永远不需要调用equals，而是直接使用==就可以了。

需要的话可以在枚举类型中添加一些构造器、方法和域。当然，构造器只是在构造枚举常量的时候被调用。

> java.lang.Enum<E> 5.0
>
> * static Enum valueOf(Class enumClass, String name)
>
>   返回指定名字、给定类的枚举常量
>
> * String toString()
>
>   返回枚举常量名
>
> * int ordinal()
>
>   返回枚举常量在enum声明中的位置，位置从0开始计算。
>
> * int compareTo(E other)
>
>   如果枚举常量出现在other之前，则返回一个负值；如果this==other，则返回0；否则，返回正值。枚举常量的出现次序在enum声明中给出。



# String

> String概述

- 在Java语言中，所有类似“ABC”这样用双引号引起来的字符串，都是String类的对象
- String类位于java.lang包下，是Java语言的核心类
- String类提供了字符串表示、比较、查找、截取、大小写转换等各种针对字符串的操作



> 构造方法（constructor）

- 使用String尤其要注意导包问题，导错包会直接导致不能运行main方法

```Java
//创建空字符串对象，需要注意的是null != ""
public String()
//把字节数组中的元素转换成字符串，字节数组中可以是字符，也可以是ASCII码值
public String(byte[] bytes)
//同上，只不过指定了区间
public String(byte[] bytes,int offset,int length)
//同字节数组
public String(char[] value)
//同上
public String(char[] value,int offset,int count)
//套娃
public String(String original)
```



> String对象的最大特征
>
> 引例
>
> 键盘输入接收一个字符串s，并用一个temp字符串引用指向它
>
> 现在修改原先字符串s（拼接一个字符串），比较s和temp

- 字符串是常量，它的值在创建之后不能更改，也就是说String对象不可变
  - String对象不可变指的是对象的状态不可变，而不是引用中的地址不可变
  - 原因是String中的字符串都是由字符数组装着的，而该数组是final修饰的 

> 字符串常量池
>
> Java当中所有双引号引起来的字符串都是字符串对象

- 每一个字符串字面值都作为一个对象存储在堆上的字符串常量池中
  - 字面值常量编译时期，就能确定其取值，编译时期加入常量池
  - 当后续再使用字面值创建相同内容的字符串对象时，直接将该对象返回给引用 
  - 如果使用new关键字创建相同内容字符串对象，对象不共享，但是字符数组仍然共享 

> 字符串是JVM堆内存中最多的对象，字符串不可变后，就可以共享，节省了大量的堆内存空间
>
> 不可变后还变得更安全（多线程可以体现）
>
> 不可变后效率提升（简单举例：新建数组很快，但是移动拷贝数组很难）



> 三个获取数组的方法



- ```Java
//使用指定字符集，将字符编码成字节序列，并将结果存储到一个新的 byte 数组中
  getBytes(String charsetName) 
  ```
  
- ```Java
  //将字符从此字符串复制到目标字符数组
  getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)
  ```

- ```java 
  //将此字符串转换为一个新的字符数组。
  toCharArray()
  ```

> String类中重写了equals()方法，比较的是字符串的内容而不是地址



>  使用加号对字符串进行拼接操作，会有下述两种结果
>
>  - 直接在常量池中创建新的拼接对象=
>  - 在堆上创建新的拼接对象
>
>  经过测试我们发现
>
>  - 当参与字符串拼接的两个字符串中，至少有一个是以引用变量的形式出现时
>   - 必然会在堆上创建新的字符串对象
>     - 原因是变量参与了运算，无法在编译时期确定其值，就不能在编译时期加入常量池
>  - 只有参与字符串拼接运算的两个字符串，都是字符串字面值常量的时候
>   - 此时不会在堆上创建新的字符串对象，而是在常量池中直接拼接创建对象
>   - 如果已存在，则不创建新的对象

# String API

> String类的判断功能

```java 
//用来比较字符串的内容，注意区分大小写
boolean equals(Object obj)
    
//忽略字符串大小写比较字符串内容，常见用于比较网址URL
boolean equalsIgnoreCase(String str)
    
//判断当前字符串对象是否包含，目标字符串的字符序列，常见用于确定是否有盗链行为
boolean contains(String str)
    
//判断当前字符串对象，是否已目标字符串的字符序列开头
boolean startsWith(String str)
    
//判断当前字符串，是否以目标字符串对象的字符序列结尾，常用于确定文件后缀名格式
boolean endsWith(String str)
    
//判断一个字符串，是不是空字符串
boolean isEmpty()
```



> String类的获取功能

```Java
// 获取当前字符串对象中，包含的字符个数
int  length()  
    
//获取字符串对象代表字符序列中，指定位置的字符
char charAt(int index) 
    
//在当前字符串对象中查找指定的字符，如果找到就返回字符，首次出现的位置，如果没找到返回-1
//也可以填字符
int indexOf(int ch) 
    
//指定从当前字符串对象的指定位置开始，查找首次出现的指定字符的位置，(如果没找到返回-1)
//可以填入字符
int indexOf(int ch,int fromIndex) 
    
//查找当前字符串中，目标字符串首次出现的位置(如果包含)，找不到，返回-1
//这里的位置是指目标字符串的第一个字符,在当前字符串对象中的位置
int indexOf(String str)

//指定，从当前字符串对象的指定位置开始,查找首次出现的指定字符串的位置(如果没找到返回-1)
//这里的位置是指目标字符串的第一个字符,在当前字符串对象中的位置
int indexOf(String str,int fromIndex) ，

//返回字符串，该字符串只包含当前字符串中，从指定位置开始(包含指定位置字符)到结束的那部分字符串
String substring(int start) 
    
//返回字符串，只包含当前字符串中，从start位置开始(包含)，到end(不包含)指定的位置的字符串
String substring(int start,int end) 
```



> String类的转换功能

```Java
//获取一个用来表示字符串对象字符序列的，字节数组
byte[] getBytes()
    
//获取的是用来表示字符串对象字符序列的，字符数组
char[] toCharArray() 

//把字符数组转换成字符串
static String valueOf(char[] chs)

//把各种基本数据类型转换成字符串
static String valueOf(int i/double...)

//把字符串全部转化为小写
String toLowerCase() 
    
//把字符串全部转换为大写
String toUpperCase()

//字符串拼接，作用等价于 + 实现的字符串拼接
String concat(String str) 
```



> String类的其他功能



- 替换功能

  - ```Java
    // 在新的字符串中，用新(new)字符，替换旧(old)字符
    String replace(char old,char new)
        
    //在新的字符串中，用新的字符串(new), 替换旧(old)字符串
    String replace(String old,String new)
    ```

  - 需要注意的是，替换不是在原对象上替换，而是创建了新的对象

  - ```java
    //使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。
    String replaceAll(String regex, String replacement)
    //使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。
    String replaceFirst(String regex, String replacement)
    ```

    

- 去除空格字符

  - ```Java
    //在新的字符串中，去掉开头和结尾的空格字符
    String trim() 
    ```



- 比较功能

  - ```Java
    String类的比较功能
    int compareTo(String str)
    int compareToIgnoreCase(String str)
    ```



>  字符串的大小如何比较？
>        按照字典序，比较字符串的大小。字典序原本的含义实质，英文单词在字典中出现的先后顺序
>       (在字典中，先出现的字符串小，后出现的字符串大)
>
>  具体到编程语言，是根据两个字符串字符串从左往右数
>
>  ​	第一个对应位置的不同字符，来决定两字符串的大小
>  ​        hello
>  ​        head
>
>  ​      compareTo几乎就是按照字典序，来比较两个字符串大小的
>
>  ​       字符串对象.compareTo(字符串对象)
>
>  compareTo方法返回值，如果是=0则表示对象相等，>0则表示左边对象大于右边对象
>
>  <0则表示右边对象大于左边对象



结合克隆方法和String 两部分知识

思考:

Object类中的clone方法是浅克隆,那么如果一个类中有String的引用数据类型 成员变量,需不需要做深度克隆?

不需要,深度克隆本质上因为引用的拷贝和原先的引用共用了同一个对象

String虽然是对象 但是它不可变 任何时候 你只要修改 就直接创建新对象



# 反射 没看懂

> java.lang.Class 1.0
>
> * static Class forName(String className)
>
>   返回描述类名为clasName的Class对象。
>
> * Object newInstance()
>
>   返回这个类的一个新实例。
>
> java.lang.reflect.Constructor 1.1
>
> * Object newInstance(Object[] args)
>
>   狗仔一个这个构造器所属类的新实例。
>
>   参数：args 这是提供给构造器的参数。
>
> java.lang.Throwable 1.0
>
> * void printStackTrace()
>
>   将Throwable对象和栈轨迹输出到标准错误流。

# 异常



[TOC]

## Java异常概述

> 异常，异常，即是程序运行出现了不正常的情况，报错，并导致程序终止

- 为什么学习异常？
  - 虽然程序员在写程序的时候，总是想把代码写得尽善尽美，充分考虑用户使用的各种情况
  - 但是程序在运行的过程中仍然会碰到非常多的问题
    - 即理想的情况：我们的程序永远不出bug，永远没有问题
    - 实际情况：程序总会出现各种问题
  - 为了描述和处理这些问题，Java就引入了异常体系
- Java当中一切皆对象，当程序产生异常，JVM会把这个异常信息封装成一个对象（类）
  - 类中封装着问题的名称，产生的原因、描述等多个属性信息存在
  - 以及对这些信息进行操作的一系列方法（属性+行为）
  - 这些类通过继承层次构成了Java的异常体系
- **学习异常之前，需要明确的一个重要点**
  - 异常的类和对象中只是存了异常的信息
  - 包括异常的原因，异常的种类等等
  - 但是何时抛出异常，怎么处理异常，不是由异常对象决定的



> Java程序运行时碰到了一系列的问题

- 编译时期，必须要检查处理的异常，不检查不能通过编译。即便发现了问题，仍然可以解决
- 运行期间，无法预料的问题，但是出现问题后，我们仍然能解决它
- 运行期间，无法预料的问题，但是出现问题后，无法解决它，是一个严重的错误



> 我们一般根据问题能不能处理，也就是问题的严重程度，来区分异常和错误

- Java程序运行时碰到了一系列的问题
  - 严重问题
    - 运行时，无法预料，且无法解决的错误
  - 一般问题
    - 编译时要检查处理的异常，出现问题，可以被解决
    - 运行时，无法预料，且能够被解决的问题



> Java异常体系确实就是这样划分的

- Throwable（祖先类）

  - Error
  - Exception
    - RuntimeException
    - 非RuntimeException

- Throwable是Java一切错误和异常的父类，是继承层次中的祖先类

  - 表示可以由程序显式或者JVM抛出的问题

- Error是严重问题，无法被解决 

  - Error描述了Java运行时虚拟机内部错误和资源耗尽错误
  - 对于Error，程序自己是无能为力的，仅靠程序本身是无法恢复和和预防
  - 于是程序只能尽量安全得保存数据， 然后终止程序，并通知用户去解决
  - 常见的Error是栈溢出，或者堆溢出这些错误

- Exception是一般问题，能够被解决

  - RuntimeException，指的是在程序运行期间，发生的一般问题，称之为**运行时异常**
    - 这种问题无法在编译时检查和预料，只有到程序运行后才能显现问题
    - 例如用null调用方法，数组使用错误的下标，错误的强制类型转换
    - RuntimeException可以写代码进行正常的处理，属于一般问题

  > 需要明确的是：
  >
  > 运行时异常绝大多数都是因为编码问题所导致的
  >
  > 也就是可以避免的异常，当程序抛出该异常后，最好能够重构代码，修正问题

  - 非RuntimeException，指的是在编译时期，就需要显式的检查并处理的异常，称之为**编译时异常**
    - 部分书籍也称其为，受检查的异常（Checked Exception）
    - 这种异常必须在编译期检查和处理
    - 例如打开一个文件夹（要考虑该文件夹存不存在）
    - 克隆一个对象（要检查该类是否实现Cloneable接口）
    - Exception的子类中，只要不是RuntimeException的子类，那必然是非RuntimeException



> Error和Exception的异同

- 两者都继承自Throwable类，共同构成了Java的异常体系
- Error类一般是指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢出等
  - 对于这类错误的导致的应用程序中断，仅靠程序本身无法恢复和和预防
  - 遇到这样的错误，只好尽量安全得保存数据， 然后终止程序，并通知用户去解决
  - Error一般都不由程序显式的抛出，而是由JVM抛出
- Exception类表示程序可以处理的异常，可以捕获且可能恢复
  - 遇到这类异常，应该尽可能处理异常，使程序恢复运行，而不应该随意地终止程序
  - Exception又分为RuntimeException（运行时异常）和非RuntimeException（编译时异常）
    - 运行时异常不受编译器检查，在程序运行期间发生，一旦发生，若不处理就会导致程序终止
      - 运行时异常包括所有RuntimeException的子类
    - 编译时异常受编译器检查，必须显式地处理该异常，才能够通过编译
      - 编译时异常包括所有Exception的子类中，非RuntimeException的子类的类



> Java设计异常体系的原则

- 尽量把一切错误，摒弃在程序运行之前，最好在编译时期就发现程序潜在的问题（通过编译器）
- 确实，Java把相当一部分异常定义为编译时异常，让程序员在编译时期就显式的处理它们
- 但仍然有很多问题，必须要Java程序运行起来，才可能产生，被发现，是编译器检查不到的
  - 这就是运行时异常

# 异常的处理

> Java程序的异常处理分为两种方式
>
> - 自己处理
> - 向上抛出

- 某个方法发生了异常

  - 自己解决
  - 抛给该方法的调用者

- 调用者（方法）拿到了异常

  - 自己解决
  - 抛给该方法的调用者

- 这个过程可以将异常一直向方法的调用者抛出，但不可能是无限的

  .........

- 最终main方法，程序的入口方法拿到了该异常，它可以选择

  - 自己解决
  - 继续抛出

- 这个时候，能接收main方法抛出的异常的，就只有JVM

  - JVM必须自己处理该异常



## Java默认的异常处理机制

> 如果我们在程序中，不写任何和异常处理相关的代码，Java程序仍然能够对异常进行处理

- 如果错误产生在main方法中
  - 当我们的代码执行到错误行数之前，代码是正常执行的
  - 当我们的代码执行到错误行数时，JVM会终止程序的执行，抛出一个该异常信息封装成的对象
  - 将该对象中的异常信息，打印到控制台上，告诉程序员发生了什么问题
  - 发生错误之后的语句，都不执行了
- 如果错误产生在main方法当中的另一个方法中
  - 当程序执行到该方法的错误行数时，JVM会终止程序的执行
    - 向上给方法的调用者抛出一个该异常信息封装成的对象
  - 一直向上抛出，直到抛给main方法，main方法最终抛给JVM
  - 发生异常之前的语句正常执行，但是之后的语句都不执行了



## 自定义（手动）异常处理

> 显然，Java默认的异常处理机制，总会导致程序终止执行，这不能够满足我们的需求
>
> 我们需要手动显式的来处理异常，以达到自己的目的

### 捕获异常，自己处理

> Java提供了结构try....catch用来捕获并处理异常

#### 单分支try...catch

- 顾名思义，其语法为

  - ```Java
    try {
     //可能出现异常的，正常的代码逻辑
    } catch(要捕捉的异常对象) {
     //每一个catch分支对应一个异常处理器
     //在catch分支中处理具体类型的代码异常
    }
    ```

- 如果try代码块中发生了异常，那么JVM就会收集这个异常的信息，封装成对象

- catch语句中需要填入一个对象引用作为匹配，而不是使用类型来匹配

  - 这个引用接收（指向）JVM封装的对象

- **catch语句中可以填入多个对象来作为匹配**

  - ```java
    catch(要捕捉的异常类型1 | 要捕捉的异常对类型2 | 要捕捉的异常类型3 对象名...){
        
    }
    ```

  - 注意：无论你能够匹配多少种异常类型，始终都只有一个异常对象被接收，对象名只写一个

- catch当中填入要捕捉的异常类型，如果能够匹配这个对象，那么就会执行catch代码块中的代码

  - 怎么算匹配？
  - 可以就是这个类的对象
  - 也可以是这个类的子类对象
  - catch代码块中语句可以对该异常进行处理

- **一旦匹配成功，catch中写的异常对象就会接收JVM抛出的异常对象**

- 匹配失败，那么程序依然会自动向上抛出异常，直到JVM默认处理

- try代码块中发生了异常，在catch代码块中被处理了，那么程序仍然能够继续执行

> 单分支try...catch使用注意事项

- try...catch会显著的影响代码结构，严重影响代码可读性
  - 所以应该把尽量少的代码放入try中，最好是产生异常的那一行代码

- 如果catch不能匹配异常对象，那么不会执行catch代码块中的内容
- 只有当try代码块中产生了异常，catch才有机会执行，没有异常不执行，不匹配也不执行
- 当实在不清楚异常的种类时，可以使用Exception接收（但实际上这是偷懒程序员的借口）
- **try代码块中某个位置产生了异常，那么try中的代码就不继续执行了**
  - 也就是说try当中要么不产生异常，要么**只会产生一个异常**



#### 获取捕获异常对象中的异常信息

> 既然能捕获该异常对象，那么获取其中的异常信息也是势在必行的
>
> 使用捕获的异常对象，能够调用的常用API有

```Java
//获取异常信息，返回字符串。打印的实际上是异常产生的原因 
（不使用）String getMessage()
//获取异常类名和异常信息，返回字符串。 打印的是异常产生的原因和所在类
（不使用）String toString()
//获取异常类名和异常信息，以及异常出现在程序中的位置
（推荐使用）void printStackTrace()
//使用IO流，将异常内容保存在日志文件中，以便查阅，早已过时，了解即可
（过时的日志处理方式）printStackTrace(PrintStream s) 
```



#### 多分支try...catch

> 如果代码只会发生一个异常，那么单分支的try...catch就够用了，那么如果发生多个异常呢？

- 语法为

  - ```Java
    try {
     //可能出现异常的，正常的代码逻辑
    } catch(要捕捉的异常对象1) {
     //每一个catch分支对应一个异常处理器
     //在catch分支中处理具体类型的代码异常
    }catch(要捕捉的异常对象2) {
     //每一个catch分支对应一个异常处理器
     //在catch分支中处理具体类型的代码异常
    }
    ...
    ```

- 该格式和单分支try...catch并无实质不同，只是多个几个catch分支而已

- 多分支try...catch的匹配流程

  - 根据实际的异常对象的类型，和catch中声明的异常类型，从上到下一次做类型匹配
  - 一旦通过类型匹配，发现实际异常对象的类型和catch中的异常对象类型匹配
    - 就把该异常对象交给这个catch分支进行处理（异常处理器）
  - 没有相匹配catch代码块的异常，那么程序依然会自动向上抛出异常，直到JVM默认处理



> 多分支try...catch使用注意事项

- 多分支的异常处理的执行，有点类似于多分支if-else的执行，一次匹配，只会执行多个catch分支中的一个

- 如果多个catch中处理的是毫无关系的异常，那么catch的顺序并不需要特别注意

- 如果多个catch中处理的异常有父子关系，那么就必须要注意了

  - 如果父类异常写在了上面，那么子类异常的catch分支就永远没有机会执行了，并且会报错

- 所以，应该把具体子类放在catch分支的上面作类型匹配，父类放在后面作兜底

- catch()括号当中，尽量不要写Exception这种大而宽泛的异常

  - 而是应该写具体的异常，越具体越好
  - 这样对处理异常有帮助，能够清晰定位异常的类型

- 两种运行时异常

  - ```
    NullPointerException： 运行时异常，空指针异常，用一个等于null的引用调用了方法和成员变量
    IndexOutOfBoundsException：运行时异常，数组下标越界异常。调用了超过数组最大下标的位置
    ```



### 抛出异常，上层处理

> 程序总会有在异常发生处不想处理该异常的情况，Java提供了向上层抛出异常的解决方案



#### throws关键字

> throws关键字表示在方法上抛出异常

- 在方法声明时使用，声明该方法可能抛出的**异常类型**

**语法:**

```java 
方法名(形参列表) throws 异常列表{
}
```

**注意事项:**

- 运行时异常会自动向上抛出，不用我们手动throws
  - 我们只需要手动throws编译时异常
- 如果方法抛出一个编译时异常，可以在语法层面，强制要求方法调用者处理该异常

- 异常列表可以是多个异常类，但是注意用逗号隔开
- 列表中出现的异常如果有父子关系，那么编译器只会强制要求处理父类
  - 所以尽量抛出同级别的异常



**方法覆盖中的异常列表匹配问题**

>  首先，异常说明属于方法声明的一部分，紧跟在形式参数列表之后
>
>  方法的声明中加了throws关键字表示所有要抛出的潜在异常类型后
>
>  方法在重写的时候也会发生一些变化

- 总体上的原则是：子类中的覆盖方法，不能比父类中的方法抛出更多异常
  - 因为Java中存在多态现象，当用父类引用调用方法时
  - 如果允许子类重写后有更多的异常，那么就没有办法处理
  - 运行时异常显式抛出对程序并无影响，那么子类重写方法可以多抛出运行时异常
- 如果子父类方法，完全抛出相同的异常，允许进行方法的重写
- 如果父类方法没有抛出异常，子类重写方法，要么也不抛出异常
  - 要么就只能抛出运行时异常（本身就是自动的，不算多）
- 如果父类方法抛了异常，那么
  - 子类重写方法可以选择完全不抛出异常
  - 如果父类方法抛出的是RuntimeException，那么子类重写方法也只能抛出RuntimeException
    - 种类不限制，允许类型不同
    - 父类方法抛出一个RuntimeException子类，子类方法重写可以是RuntimeException
  - 如果父类方法抛出的是编译时异常，那么子类重写方法
    - 可以抛出相同的编译时异常，但不能抛出不同的编译时异常
    - 抛出所有运行时异常
    - 不可以抛出Exception
  - 如果父类方法直接抛出Exception
    - 那么子类重写方法就可以抛出任何异常了



> 我们其实并不需要特别记忆这些规则，实际开发中，我们并不是像老师上课一样，需要一点不能出错。我们可以不断的尝试，然后最终提交出一份正确的代码。这样，我们仍然是一名优秀的**Java**开发工程师。如果面试中被问到，建议直接说子类中的覆盖方法，不能比父类中的方法抛出更多异常即可。

- 建议在开发中，子父类重写方法拥有一致的抛出异常列表
- 避免自找麻烦



#### throw

> 在很多时候，我们不满于在方法声明中声明要抛出的异常的类型，我们想要直接在方法内部抛出异常

**概述：**

​	  1.在方法体中使用，主动在方法中抛出异常

​	  2.每次只能抛出确定的某一个异常对象

**基本语法：**

```Java
  throw 异常对象;
```

**注意：**

- 每次只能抛出一个异常对象
- 一旦程序运行到该throw代码，必然会抛出一个异常对象
- 在方法中抛出一个异常，相当于使用了return关键字
  - 方法立刻结束，后面也不能有其它代码了
  - throw必须位于方法的最后一行
- 每个异常类的构造方法都可以显式得传入一个字符串，表示异常信息（原因）的说明
- 如果在方法中显式地抛了一个编译时异常
  - 那么会和产生编译时异常的代码一样，需要显式处理
  - 最好和throws一起使用（如果try...catch就没有意义）
- 一旦主动使用throw关键字，就代表在当前方法中，必然不会处理该异常，此时直接抛给方法调用者去处理
- 举例：
  - 结合成员变量的封装和set方法，判断输入的参数是否合法（IllegalArgumentException）
  - 空接口（Cloneable）

```Java
private static void testThrowCheckableDemo() throws CloneNotSupportedException {

    throw new CloneNotSupportedException("发生了禁止克隆异常");

}

private static void testThrowRuntimeDemo() throws NullPointerException{

    throw new NullPointerException("发生了空指针异常");

}
```



牛刀小试

> **编译期异常和运行期异常的区别?**

- 必须要显式处理的，否则编译不通过
- 无需显示处理，编译就能通过
  - 可以不处理，也可以处理
  - 不推荐使用异常处理，而应该修改代码逻辑



#### throws和throw的区别

​	throws

```
1.用在方法声明后面，跟的是异常类名

2.可以跟多个异常类名，用逗号隔开

3.表示抛出异常，由该方法的调用者来处理

4.throws表示出现异常的一种可能性，并不一定会发生这些异常
```

throw

```
1.用在方法体内，跟的是异常对象名

2.只能抛出一个异常对象

3.表示抛出异常，可以由方法体内的语句处理（多此一举） 最常见的是结合throws抛给调用者去处理

4.throw则是抛出了异常，执行throw则一定抛出了某种异常
```



##### 到底是该try还是该抛出

总结一下，目前为止，我们所学习过的异常的处理策略主要有两种：

  1.捕获并处理 try -catch

  2.向上抛出。

 运行时异常会自动上抛，直到抛给JVM

 编译时异常需要用throws关键字向上抛出

**那么究竟，在遇到异常时我们该如何选择处理策略呢？**

原则：

```
 对于运行时异常，我们不应该写出产生这种异常的代码，应该在代码的测试阶段修正代码。
 对于编译时异常，功能内部能够处理的就处理，如果不能够或者没有必要处理，就抛出。
```

#### finally

finally的特点

1.无论try中是否发生异常，都会执行

2.try-catch代码中有return也不能阻止它

3.特殊情况：在执行到finally之前jvm退出了

  System.exit(0)

finally的作用

用于释放资源，在IO流操作和数据库操作中会见到

```java
private static void method() {
    try {
        System.out.println(10/0);
    }
    catch (ArithmeticException e){
        e.printStackTrace();
        System.exit(0);
    }
    finally {
        System.out.println("finally");
    }
}
```

**2:如果在try里面有return,请问finally还执行吗?如果执行,在return前还是后**

**会。 前面。return是最后一步，返回结果**



 **注意事项：**

**如果try中遇到了return，那么暂时不执行这个return**

**先去执行finally中的语句**

**1.如果finally中没有return，那么执行完finally后再回到try中执行return语句。**

**2.如果finally中也有return，那么执行完finally语句中的return后，不会再回到try中了！**

**3.执行完return语句后，返回值无论怎么修改，都不会改变打印结果。**

**4.如果没catch到，但是finally中有return,会直接执行finally中的return，异常的抛出就无法执行到了**

try...catch变形

```
		try...catch...finally
		try...catch...
		try...catch...catch...
		try...catch...catch...fianlly
		try...finally
```

try...finally在IO操作中比较常见，异常抛给上层，但必须释放资源。

#### final，finally和finalize的区别

```
  final:  最终的
	可以修饰类 成员变量 成员方法
       类:类不能被继承
       成员变量:常量
       成员方法: 不能被重写
   finally: 异常处理体系当中,用于资源释放.最大的特点 不发生特殊情况 必然会执行
   finalize: Object()类中的成员方法,垃圾回收。但是注意jvm有自己的垃圾回收机制，并不会因为你调用这个方法就立刻回收对象。
```

# 自定义异常

自定义异常

  继承自Exception：编译时要检查

  继承自RuntimeException：编译不需要检查

通过已有异常类的构造方法添加message也可以实现输出不同的信息，那么为什么还要去实现我们自己的自定义异常呢？

因为用已有异常添加message的方法虽然在抛出时，和自定义异常是一样的。但是无法单独catch，单独处理。

# File类

> File类概述

- 在操作系统中，数据都是以文件的形式，永久保存在外部储存设备上的
- 做开发的时候，难免需要对文件进行操作，比如检查作业，上传作业
- 根据Java当中一切皆对象的思想，这个时候我们需要一个对象用来操作文件
- 于是Java引入了File类用来描述文件或者文件夹（目录）
- File类位于java.io包下，是Java进行IO操作的核心类
- File是文件和目录（文件夹）路径名的抽象表达形式



> 绝对路径和相对路径

- 绝对路径
  - 绝对路径名是完整的路径名，根据绝对路径可以唯一确认文件和目录
  - 例如：E:\demo\first\a.txt
- 相对路径
  - 相对路径是不完整的路径名，只依赖相对路径不能唯一确认文件和目录
  - 相对路径名必须使用其他路径名的信息进行解释，也就是常说地相对于“某个路径”
  - 相对路径是不跟盘符和路径分隔符的
  - 例如相对于（E:\demo）下的first\a.txt文件







> 绝对路径可以唯一确认一个文件，相对路径却不可以
>
> 那么在IDEA中写代码，如果使用一个相对路径来表示文件
>
> 那这个相对路径又是相对于谁呢？

- 默认情况下，java.io包中的类总是根据当前用户目录来解析相对路径名

- 此目录由系统属性user.dir指定，通常是 Java虚拟机的调用目录

- 可以使用以下代码获取

  - ```Java
    System.getProperty("user.dir")
    ```

- 这个属性默认是project的根目录

- 可以在run configuration中修改

- 一般情况下默认就好了

- 普遍来说，在Java程序中应该优先使用绝对路径，因为相对路径会随着环境的改变而指向不同的文件



> 不同操作系统下路径名表示的符号其实是有区别的
>
> Microsoft Windows平台

- Windows操作系统下，包含盘符的路径名前缀由驱动器号和一个 ":" 组成

- 后面不同层级目录用“\”或者“\\\”表示

- 例如

  - ```
    绝对路径： e:\demo\a.txt
    相对路径： （相对于e:\）demo\a.txt
    ```



> 类Unix平台
>
> 包括Unix系统，Linux系统，macOS系统

- 这些系统是没有盘符标识的，而是用一个“/”表示根目录

- 绝对路径就是从根目录开始的，一个完整的目录，后面的每个层级都用“/”分隔

- 相对路径则不从根目录开始

- 例如

  - ```
    绝对路径：/home/demo/a.txt
    相对路径：（相对于/home/demo）a.txt
    根目录：/
    ```



> 转义字符 ‘\xxx’

- ```
  '\t'表示制表符
  ```

- ```
  '\r'表示回车
  ```

- ```
  '\n'表示换行
  ```

- ```
  '\\'表示字符串"\"
  ```




> 根据以上种种特征，那么我们怎么在Java程序中表示一个文件或者目录呢？
>
> 难道我们需要在用Windows写代码测试的时候用“\\\”，而在代码上线后用"/"吗？

- 当然不需要，Java早已是一门成熟的语言，跨平台性上，已经对路径符号作了优化
- 你可以自由选择以下一种方式书写路径名，都是可以的
  - 全部用“//”
  - 全部用“\\\”（推荐使用）
  - 全部用“/”
- 不要使用“\”，单独使用“\”，这是一个转义字符

# File类的使用

> 首先，在使用File之前，再明确一下File类的定义
>
> File是文件和目录（文件夹）路径名的抽象表达形式F

- File类是对文件、目录的抽象表示，**并不代表这个文件和目录就一定存在**

- 创建File类对象的时候，编译器也不会去检查这个File对应的文件和目录是否存在

- 用一个file对象调用以下方法，可判断该目录文件是否存在

  - ```java 
    public boolean exists()
    ```




> File类的构造方法

```java
//创建一个File对象，该方法一般使用绝对路径来创建对象，也可以使用相对路径
File (String pathname)
    
//和第一种方式类似，只不过把一个路径劈成了两半
//普遍来说，parent路径表示一个绝对路径。child路径跟一个相对路径
File (String parent, Sting child)
    
//和第二种方式一样，只不过，子路径用一个File对象表示
File (File parent, String child)
```



# File API

> 几个属性

```java 
//与系统有关的多个路径名的分隔符 “;”
static String pathSeparator 
//与系统有关的单个路径层级的分隔符 “\”
static String separator 
```

- 已经没有什么实用意义了，了解知道即可



## 创建功能

```Java
//只负责创建文件，目录路径如果不存在，会报错而不是帮你创建
public boolean createNewFile() 

//只负责创建目录，但只能创建单层目录，如果有多级目录不存在的话，创建失败
public boolean mkdir()
    
//只负责创建目录，但可以创建多级目录，如果多级目录不存在，则帮你全部创建
public boolean mkdirs()
```

- createNewFile()只能创建文件，不能创建目录，会报错
- mkdir()和mkdirs()的区别就在于能否创建多级目录
  - 需要注意的是，它两个都不能创建文件
  - 如果File对象路径中包括文件名，它会把文件名当成目录名处理



## 删除功能

```Java
public boolean delete()
```

- 删除此抽象路径名表示的文件或目录。如果此路径名表示一个目录，则该目录必须为空才能删除
- 该方法删除后不会到回收站



## 移动且重命名文件功能

```Java
public boolean renameTo(File dest)
```

- 当源文件和修改之后的目标文件，在同一目录的时候，效果只是重命名
- 当源文件和修改之后的目标文件，不在同一目录的时候，效果是移动且重命名
- 真正操作文件，应该使用（IO流操作）    



## 判断功能

```Java
//判断File对象是否表示的是一个文件
public boolean isFile()
    
//判断File对象是否表示的是一个目录
public boolean isDirectory()
    
//判断File对象表示的文件或目录，是否真实存在
public boolean exists()

//判断File对象表示的文件，是否可读
public boolean canRead()

//判断File对象表示的文件，是否可写
public boolean canWrite()

//判断File对象表示的文件是否是隐藏文件
public boolean isHidden()
```



## 获取功能

```Java
//获取File对象表示的抽象文件的绝对路径
public File getAbsolutePath()

//获取File对象表示的抽象路径名的字符串，简单来说，创建的时候给的是什么就输出什么
public String getPath()

//获取File对象表示的文件或者目录的文件名
public String getName()
    
//返回由此抽象路径名表示的文件的所占硬盘空间大小，以字节为单位
//但是需要注意的是，这个方法只能获取文件的大小，不能获取目录大小
public long length()

//返回此File对象表示的文件的最后一次修改的时间
public long lastModified()
```



## 高级获取功能

```Java
//返回一个字符串数组，这些字符串包括，此抽象的路径名表示的目录中的所有文件和文件夹的名字
//如果File对象表示的是一个文件，则返回null
//只能获取当前目录的下一层，并不是获取所有层级
//如果是一个空目录，返回一个长度为0的数组，而不是null
public String[] list() 
    
    
//返回指定File目录下的文件和文件夹的绝对路径形式的File对象数组
//如果File对象表示的是一个文件，则返回null
//只能获取当前目录的下一层，并不是获取所有层级
//如果是一个空目录，返回一个长度为0的数组，而不是null
public File[] listFiles()
```

以上可以用来判断是否为文件或文件夹，但是没有必要。



## 自定义获取功能

```java 
//获取这个文件夹下，满足filter过滤器的条件的文件
File[] listFiles(FileFilter filter) 
```

- 自定义获取功能是在高级获取功能的基础上，加了一个过滤器，所以高级功能的特点它都有

- FileFilter是一个接口，它只有下面一个方法

  - ```Java
    //测试指定抽象路径名是否应该包含在某个路径名列表中
    boolean accept(File pathname)
    ```

  - 这个方法相当于把高级功能中listFiles()获取的File数组中File对象遍历一遍，然后逐个判断

  - 符合条件的留下，不符合条件的干掉（丢弃）- 

- 常用匿名内部类来做实现

```Java
//留下所有txt文件
public class FileTest2 {
    public static void main(String[] args) {
        File file = new File("E:\\temp");
        //匿名内部类创建一个过滤器
        FileFilter fileFilter = new FileFilter() {
            @Override
            public boolean accept(File dir) {
                //条件是 dir对象是一个文件并且它的名字以txt结尾
                return dir.isFile() && dir.getName().endsWith("txt");
            }
        };
        //在有过滤器的情况下创建一个File[]数组，并且遍历
        File[] files = file.listFiles(fileFilter);
        for(File f : files){
            System.out.println(f);
        }
    }
```

- 补充Arrays.sort(files, new Comparator<File>())方法



> 递归删除目录的思路

- 获取目录的下的所有File对象（包括文件和文件夹）
- 判断，如果是一个空目录或者file对象不是一个目录而是文件
  - 直接删除
- 程序执行到这里，那么一定是一个目录，且不是空目录
  - 遍历获取的file数组
  - 如果这个file对象仍然是一个目录，递归删除该目录
  - 如果这个file对象是文件，直接删除
- 最后不要忘记删除已经是空目录的当前目录

# 基本数据类型对象包装类概述

**基本类型包装类的产生**  

  在实际程序使用中，程序界面上用户输入的数据都是以字符串类型进行  存储的。而程序开发中，我们需要把字符串数据，根据需求转换成指定的基本数  据类型，如年龄需要转换成int类型，考试成绩需要转换成double类型等  

基本数据类型，都有对应的引用数据类型。

* byte Byte
* short Short
* int Integer
* long Long
* char Character
* float Float
* double Double
* boolean Boolean

```java
//把字符串转化为int,Integer类parseInt方法
int i = Integer.parseInt("12");
System.out.println(i/2);//6

//Integer或int转成字符串
//使用+与字符串拼接
int i = 3;
String s = i+"";
System.out.println(s+1);//"31"
//toString(int ,int 进制),任意进制整数转成任意进制的字符串 (了解)
String s1 = Integer.toString(5,2);//二进制字符串形式

/** Integer类构造方法
*   public Integer( int value)
* 	public Integer ( String s)
*   将数字格式的字符串,传递到Integer类的构造方法中
*   创建Integer对象,包装的是一个字符串
*   将构造方法中的字符串,转成基本数据类型,调用方法,非静态的
*	intValue()
*/
Integer ii =new  Integer(10);
Integer in = new Integer("100");
int i = in.intValue();

//Integer类常用方法
/** Integer类的3个静态方法
* 十进制转成二进制  toBinarString(int)
* 十进制转成八进制  toOctalString(int)
* 十进制转成十六进制 toHexString(int)
* 三个方法,返回值都是以String形式出现
*/
System.out.println(Integer.toBinaryString(99));
System.out.println(Integer.toOctalString(99));
System.out.println(Integer.toHexString(999));
/** 获取int的最大值和最小值
*   Integer类的静态成员变量
*   MAX_VALUE
*   MIN_VALUE
*/
System.out.println(Integer.MAX_VALUE);
System.out.println(Integer.MIN_VALUE);

//int类型和String类型的相互转换
//int -->String
//方式1：字符串拼接
String s1=""+number;
System.out.println(s1);
//推荐方式2
//方式2：String的方法:可以把任意类型的转换成字符串
String s2  =String.valueOf(number);
System.out.println("s2 = " +  s2);
//方式3
Integer i= new  Integer(number);
System.out.println(i.toString());
//方式4：
String s4=Integer.toString(number);
System.out.println(s4);
//String -->int
String s="100";
//方式1：
//String--Integer---int
Integer ii =new  Integer(s);//把String类型转成Integer类型
int  x=ii.intValue();//把Integer类型转成int类型
System.out.println(x);
//方式2：很重要，同理，类似float
//public static int parseInt(String s)
int  y=Integer.parseInt(s);
System.out.println(y);
```

**自动装箱和自动拆箱**  

自动装箱,拆箱的 好处: 基本类型和引用类直接运算  

自动装箱:  

使用Integer.valueOf(整数值)返回一个封装了该整数值的Integer对象，即把 基本类型转为引用类型  

自动拆箱:  

使用Integer对象.intValue()返回Integer对象中封装的整数值，把引用类型转为基本数据类型

```java

public  static  void  function(){
//引用类型  ,引用变量一定指向对象
//自动装箱,基本数据类型1,直接变成了对象
Integer  in  =  1; //  Integer  in  =  new  Integer(1)
//in是引用类型,不能和基本类型运算,自动拆箱,引用类型in,转换基本类型
//in+1  ==>  in.inValue()+1  = 2
//in  =  2自动装箱
in  =  in  + 1;
System.out.println(in);
```



# **StringBuffer**

1. 概述：表示一个字符串缓冲区，它的对象是可变的。也是线程安全的可变字符序列。
   底层为字符数组。初始容量为16，可以自动扩容。这个大小为16的初
   始空间不存储东西，作为预留空间；比如存储一个长度为13的字符串，容量就变为了29。
2. StringBuffer和String的区别?  
   * StringBuffer:  对象可变的字符序列，对象是变量，在堆上
   * String:  对象不可变的字符序列,对象是常量，在常量池
   * String 作为参数传递类似于基本数据类型作为参数传递  (对象的不可改变 性)。
   * StringBuffer 作为参数传递就是引用数据类型传递（对象可以改变）  

**String,StringBuffer,StringBuilder的区别**  

* String:  不可变的字符序列
* StringBuffer:  可变的字符序列，线程安全的，效率低.
* StringBuilder: 可变的字符序列，线程不安全的，效率高。

**StringBuffer和数组的区别** 

* StringBuffer和数组都可以看成是一个容器
* StringBuffer可以自动扩容，数组长度是固定的
* 数组只能存储一个数据类型，StringBuffer可以把任意数据类型转换  成字符来存储  

**StringBuffer的构造方法**

```java
//A.public StringBuffer()  
StringBuffer sb = new StringBuffer(); System.out.println(sb);  
System.out.println(sb.length()); //0  System.out.println(sb.capacity()); //默认值16  

//B.public StringBuffer(int  capacity)  
StringBuffer sb = new StringBuffer(4);
System.out.println(sb); System.out.println(sb.length()); // 0  System.out.println(sb.capacity()); //4  

//C.public  StringBuffer(String str)  
StringBuffer sb = new StringBuffer("Hello, wuhan!"); System.out.println(sb);  
System.out.println(sb.length()); //长度为13  
System.out.println(sb.capacity()); //容量为13+16 = 2
```

**StringBuffer的常见功能（成员方法）**

```java
//int capacity() 返回容量 (初始值为16，并且可以自动扩容)
//int length()   返回长度

//A:添加功能
//public StringBuffer append(String str) 可以把任意类型追加进StringBuffer并且在append之后，StringBuffer对象本身也会变化，所以可以直接返回该对象，不需要新建对象来接收。和String不同
StringBuffer  sb  =  new StringBuffer("Hello");
System.out.println(sb);  //输出Hello
StringBuffer  sb1  =  sb.append(", world!");
System.out.println(sb);  //  Hello  World
System.out.println(sb1);//  Hello  World
System.out.println(sb  ==  sb1);  // true

sb.append(",  world!");
System.out.println(sb);  //Hello  World
//可以链式编程
sb.append("world").append("wuhan").append("shenzhen");
System.out.println(sb);

StringBuffer  sb  =  new StringBuffer();
Date  date  =  new Date();
System.out.println(date);
char[]  chars  =  {'爱', '我',  '中',  '华'};
sb.append(100).append('中').append(true).append(3.14).append(date).append(chars);
System.out.println(sb);  //会把字符的原本形式拼接进来

//public StringBuffer insert(int offset,String str)  
//可以把任意数据类型，指定偏移位置插入字符串
StringBuffer  sb  =  new StringBuffer("abcd");
sb.insert(2,  '中');  //  ab中cd
sb.insert(sb.length(),  "中");  //在最后插入，自动扩容，abcd
sb.insert(0,  "中");  //中abcd

sb.insert(0,100).insert(0,3.14).insert(0,'中').insert(0, false).
insert(0,  new  Date());

//删除功能
//public StringBuffer deleteCharAt(int index) 删除指定索引的字符
StringBuffer  sb  =  new StringBuffer("abcd");
/sb.deleteCharAt(3);  //abc
sb.deleteCharAt(3).deleteCharAt(3);  //越界

//public StringBuffer delete(int start, int end)  （包左不包右）删除一段字符
sb.delete(2,  3)  //abd
sb.delete(2,  3).delete(0,0);  //bd
sb.delete(0,  sb.length());  //空

//替换功能
//public StringBuffer replace(int start,int end,String str)  // 包左不包右
StringBuffer  sb  =  new StringBuffer("abcd");
sb.replace(0,  3,  "XYZ,  now i  see...");
System.out.println(sb);  //d没有被替换掉

//反转功能
//public StringBuffer reverse()
StringBuffer  sb  = new  StringBuffer("abcd");
sb.reverse();
System.out.println(sb);  //dcba

//截取功能(注意这个返回值，原对象没有修改)
//public String substring(int start)
StringBuffer  sb  = new  StringBuffer("abcd");
String  s1  =  sb.substring(2);
System.out.println(s1);  //输出  cd
System.out.println(sb);  //输出  abcd

//public String substring(int start,int end)
String  s1  =  sb.substring(1, 3);
System.out.println(s1);  //输出bc
System.out.println(sb);  //输出abcd
```

  **String和StringBuffer作为参数的区别**

​	String作为参数传递  

​	StringBuffer作为参数传递 

* 总结：

  String作为参数传递类似于基本数据类型作为参数传递  (对象的不可改变性)。

  StringBuffer作为参数传递就是引用数据类型传递（对象可以改变）

**API应用示范**

* 判断一个字符串是否对称

  ```java
  //方法一：把字符串转为char[]数组，然后第一个和最后一个比较，第二个和倒数第二个比较
  //方法二：直接让StringBuffer的方法翻转字符串，若翻转后和原字符串相等，则是对称字符串
  ```

  

# Java日期类

> 严格来说，Java的日期类设计是比较曲折的，甚至是有些失败的，可谓是改了又改，始终不尽如人意
>
> java.util包下提供了 Date 类来封装当前的日期和时间，这个类中绝大多数方法已经过时了
>
> 但是作为Java日期类的基本类，仍然有学习的必要

- Date类表示一个特定的瞬间时间，精确到毫秒

- 构造方法：目前仍没有过时的只有两个

  - ```java
    //该构造函数使用当前日期和时间来初始化对象	
    Date()
    ```

  - ```java
    //第二个构造函数接收一个参数，该参数是从1970年1月1日起的毫秒数
    Date(long millisec)
    ```

  - 无参构造方法调用底层的native方法System.currentTimeMillis()方法

    - 该方法会根据操作系统来获取当前的时间戳

  - 时间戳：从格林威治时间（GMT）1970 年 1 月 1 日 00:00:00 到现在的毫秒数

    - 时间戳可以通过一些工具网站进行查询和转换时间

- 成员方法：了解两个即可

  - ```java
    //用自1970年1月1日00:00:00 GMT以后time毫秒数设置时间和日期。
    void setTime(long time)
    ```

  - ```java
    //返回自1970年1月1日00:00:00 GMT以来此Date对象表示的毫秒数。
    long getTime( )
    ```

- 中国处在东八区，格林威治时间1970 年 1 月 1 日 00:00:00是中国的1970 年 1 月 1 日 08:00:00



> 显然这种日期格式和我们生活中的日期格式，相去甚远
>
> 为了以更贴近生活中的方式去描述时间，实现直接把一个字符串转换成Date的需求
>
> 因此考虑使用别的日期类实现需求
>
> DateFormat是日期和时间格式化子类的抽象类，它能够以自定义的格式解析或者格式化日期和时间
>
> 由于其是一个抽象类，所以使用其子类SimpleDateFormat实现日期和字符串的相互转换。

- SimpleDateFormat的构造方法

  - ```Java
    //以传入的字符串格式进行解析或者格式化日期
    public SimpleDateFormat(String pattern)
    ```

  - pattern的书写格式

    - y：表示年，例如yyyy，表示千年年份
    - M：表示月份，例如MM，表示月份（最多12，两位数）
    - d：表示月份中的天数，例如dd，表示天数（最多31，两位数）
    - H：表示一天中的小时数，例如HH，表示小时数（最多24，两位数）
    - m：表示小时中的分钟数，例如mm，表示分钟数（最大59，两位数）
    - s：表示分钟里的秒数，例如ss，表示秒数（最大59，两位数）

  - 该对象仅仅只是描述日期的格式，并不代表时间

  - 想要表示时间，仍然要使用Date对象

- SimpleDateFormat的成员方法

  - ```Java
    //将传入的Date对象按照pattern格式，格式化成一个字符串
    public final String format(Date date)  
    ```

  - ```java
    //将传入的字符串按照pattern格式，解析成一个Date对象
    public Date parse(String source)
    ```

  - parse方法会抛出一个编译时异常ParseException，需要显式处理

    - 当传入的字符串和解析的格式不同，就会抛出该异常

  - format方法不会抛出编译时异常，不需要显式处理

    - 当pattern格式不正确，会抛出异常，非法参数

# IO概述

**什么是IO**

- I：Input 输入
- O：Output输出

为啥有IO？

-  在操作系统中，一切需要永久保存的数据都以文件的形式 存储。需要长久保存的文件数据，存储在外部设备。
   但是需要读入内存才能显示这些数据
   同时，内存的大小有限，因此常常需要在内存和外设之间交换数据，即I/O

**java当中如何实现IO功能**

- 我们通过java的IO流

- java流模型

  【  JVM内存  】                                   【 ↓ 】

  【输入流对象】<==read方法 读=== 【硬】

  【输出流对象】<==write方法 写=== 【盘】

  创建流对象之后，就建立起了内存和外设的数据通道，当数据从一端移动到另一端就完成了一次数据传输。



**流的分类**

- 按流向分（以内存为参照为）
  - 输入流   外设→内存
  - 输出流  内存→外设
- 按照数据类型分类
  - 字节流  以字节为单位，一连串的二进制  1B=8bit  0000 0000 
  - 字符流  以字符为单位，一连串的字符序列 ，理解成为一种文化符号  “你”  “abc”  “の” 

**抽象基类**

- 字节输出流 OutputStream
- 字节输入流 InputStream
- 字符输出流 Writer
- 字符输入流 Reader

注意：由这4个基类派生出的子类都是以其父类名字作为后缀的

eg：字节文件输出流：FileOutputStream

字节文件输入流：FileInputStream

# 字节流

## 字节输出流

### 抽象基类

**OutputStream**

- 继承关系

  ```
  [AutoCloseable]
  [<interface>]
  [close()]
       ↑
  [Closeable]          [Flushable]
  [<interface>]        [<interface>]
  [close()]			 [flush()]
       ↑                   ↑
  [OutputStream]→→→→→→→→→→→↑
  [abstract]
  ```

  

- 成员方法

  - | void           | close()        关闭此输出流并释放与此流有关的所有系统资源。  |
    | -------------- | ------------------------------------------------------------ |
    | void           | flush()        刷新此输出流并强制写出所有缓冲的输出字节。    |
    | void           | write(byte[] b)        将 b.length 个字节从指定的 byte 数组写入此输出流。 |
    | void           | write(byte[] b,  int off, int len)       将指定 byte 数组中从偏移量 off 开始的  len 个字节写入此输出流。 |
    | abstract  void | write(int b)        将指定的字节写入此输出流。               |

  - write(int b) 

    - write 的常规协定是：向输出流写入一个字节。要写入的字节是参数 b 的八个低位。b 的 24 个高位将被忽略。

  - write(byte[] b,  int off, int len)

  - 参数：
    b - 数据。
    off - 数据中的初始偏移量。
    len - 要写入的字节数。

### 具体子类

#### FileOutputSteam

- 构造方法

  - | FileOutputStream(File file)        创建一个向指定 File 对象表示的文件中写入数据的文件输出流。 |
    | ------------------------------------------------------------ |
    | FileOutputStream(File file,  boolean append)       创建一个向指定 File  对象表示的文件中写入数据的文件输出流。 |
    | FileOutputStream(String name)        创建一个向具有指定名称的文件中写入数据的输出文件流。 |
    | FileOutputStream(String name,  boolean append)       创建一个向具有指定 name 的文件中写入数据的输出文件流。 |

- 成员方法

| void | write(byte[] b)        将 b.length 个字节从指定 byte 数组写入此文件输出流中。 |
| ---- | ------------------------------------------------------------ |
| void | write(byte[] b,  int off, int len)       将指定 byte 数组中从偏移量 off 开始的  len 个字节写入此文件输出流。 |
| void | write(int b)        将指定字节写入此文件输出流。             |

Demo

```java
public class Demo2 {
    public static void main(String[] args) throws IOException {
        //   1.创建字节输出流对象
        FileOutputStream out = new FileOutputStream("a.txt");

        //    2.把我们的数据交给write方法
        // write(int b)
        //writeSingle(out);

        // 用字节数组方式
        //writeMuti(out);

        String s = "abcd";
        out.write(s.getBytes(),0,s.getBytes().length);


        //    3.close
        out.close();
    }

    private static void writeMuti(FileOutputStream out) throws IOException {
        String s = "abcd";
        out.write(s.getBytes());
    }

    private static void writeSingle(FileOutputStream out) throws IOException {
        out.write(97);
        out.write(98);
        out.write(99);
        out.write(100);
    }
}

```

**<font color=red>注意</font>**

- 创建字节输出流对象做了什么事情

  - 创建之前，jvm到操作系统找文件
    - 没找到，会帮我们创建文件
    - 找了，会清空文件内容 从头开始写
  - 创建输出流对象，建立起内存与外设的数据通道

- 怎么实现文件追加？

  - ```java
        public static void main(String[] args) throws IOException {
            FileOutputStream out = new FileOutputStream("a.txt", true);
            out.write("abcd".getBytes());
            out.close();
        }
    ```

- 如何实现换行

  - ```java
        public static void main(String[] args) throws IOException {
            FileOutputStream out = new FileOutputStream("a.txt",true);
            //out.write("\r\n".getBytes());
            //out.write(System.lineSeparator().getBytes());
            out.write("\n".getBytes());
    
            out.write("abcd".getBytes());
            out.close();
        }
    ```

- 为什么要close?

  - java 流底层使用操作系统的内核资源,io资源属于操作系统的.不像new出来的对象一样被垃圾回收机制给回收,所以只能释放资源,close显式的去释放资源.一般来说只有使用close方法 都是使用了jvm以外的资源,文件,端口.

- 异常处理

  - 方式一:

    - ```java
      /*传统的异常处理方式*/
      public class Demo {
          public static void main(String[] args) {
              String s = "hello";
              FileOutputStream out = null;
              try {
                  out = new FileOutputStream("a.txt");
                  out.write(s.getBytes());
      
              } catch (FileNotFoundException e) {
                  e.printStackTrace();
              } catch (IOException e) {
                  e.printStackTrace();
              }finally {
                  try {
                      //判断是否为null
                      if (out != null) {
      
                          out.close();
                      }
                  } catch (IOException e) {
                      e.printStackTrace();
                  }
              }
      
          }
      }
      ```

  - 方式二

  - ```
    //try-with-resources
    语法:
    try(需要释放的资源,实现了Closeable或者AutoCLoseable接口){
    //代码
    }catch(){
    
    }finally{
    
    }
    
    ```

    ```java
    public class Demo2 {
        public static void main(String[] args) {
            // try-with-resources
    
            try(FileOutputStream out =
                        new FileOutputStream("a.txt")){
                // 写数据操作
                out.write("world".getBytes());
    
            } catch (FileNotFoundException e) {
                e.printStackTrace();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
    ```

    Demo

    ```java
    // 实现AutoCloseable接口
    public class Demo3 {
        public static void main(String[] args) {
            try(A a=new A()) {
                // 调用test方法
                a.test();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
    
    class A implements AutoCloseable {
    
        @Override
        public void close() throws Exception {
            System.out.println("执行了close方法");
        }
    
        public void test() {
            System.out.println("执行了test方法");
        }
    }
    ```


#### BufferedOutputStream

该类实现缓冲的输出流。通过设置这种输出流，应用程序就可以将各个字节写入底层输出流中，而不必针对每次字节写入调用底层系统。

- 继承关系

  * ```
    <C> BufferedOutputStream
    	<C> FilterOutputStream
    		<C> OutputStream
    			<C> Object
    			<I> Closeable
    			<I> Flushable
    ```

  ​	

- 构造方法

  - | BufferedOutputStream(OutputStream out)        创建一个新的缓冲输出流，以将数据写入指定的底层输出流。 |
    | ------------------------------------------------------------ |
    | BufferedOutputStream(OutputStream out,  int size)       创建一个新的缓冲输出流，以将具有指定缓冲区大小的数据写入指定的底层输出流。 |

  - 这种需要传入底层基础流我们称为包装流(处理流),实际上在原有流的基础上进行了功能的扩展,参数是底层流,也叫作节点流

    ```
    【BufferedInputStream】		   【		】
    【  [InputStream]    】<==read===【	磁	】
    【  (缓冲区8192B)     】			 【		   】
    								 【		  】
    【BufferedOutputStream】			【		 】
    【   [OutputStream]   】==write==>【	盘    】
    【	(缓冲区8192B)     】		  【			】
    ```



简单使用:

```java
/*| BufferedOutputStream(OutputStream out)
     创建一个新的缓冲输出流，以将数据写入指定的底层输出流。 |
| ------------------------------------------------------------ |
| BufferedOutputStream(OutputStream out,  int size)
   创建一个新的缓冲输出流，以将具有指定缓冲区大小的数据写入指定的底层输出流。 |*/
public class Demo1 {
    public static void main(String[] args) throws IOException {
        FileOutputStream out = new FileOutputStream("a.txt");
        BufferedOutputStream bo = new BufferedOutputStream(out);

        //BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(
        //        new FileOutputStream(new File("a.txt")));

        // 写数据
        bo.write("hello".getBytes());
        // 刷新数据 
        //bo.flush();
        //close
        bo.close();
        // close方法会自动执行flush方法 
        // 关闭包装流 会去自动关闭底层流
    }
}
```





## 字节输入流

### 抽象基类

**InputStream**

- 继承关系

  * ```
    AutoCloseable<interface>
    +close()
    	↑
    Closeable<interface>
    +close
    	↑
    InputStream<abstract>
    +3个read方法
    ```

    

- 成员方法

  - | abstract  int | read()        从输入流中读取数据的下一个字节。               |
    | ------------- | ------------------------------------------------------------ |
    | int           | read(byte[] b)        从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。 |
    | int           | read(byte[] b,  int off, int len)       将输入流中最多 len 个数据字节读入 byte 数组。 |

  - read()   

    - 从输入流中读取数据的下一个字节。readData
    - 返回 0 到 255 范围内的 int 字节值。如果因为已经到达流末尾而没有可用的字节，则返回值 -1。在输入数据可用、检测到流末尾或者抛出异常前，此方法一直阻塞。

  - read(byte[] b,  int off, int len) 

  - 参数：
    b - 读入数据的缓冲区。
    off - 数组 b 中将写入数据的初始偏移量。
    len - 要读取的最大字节数




### 具体子类

#### FileInputStream

- 构造方法

- | FileInputStream(File file)        通过打开一个到实际文件的连接来创建一个 FileInputStream，该文件通过文件系统中的  File 对象 file 指定。 |
  | ------------------------------------------------------------ |
  | FileInputStream(String name)        通过打开一个到实际文件的连接来创建一个 FileInputStream，该文件通过文件系统中的路径名  name 指定。 |

- 成员方法

  - | int  | read()        从此输入流中读取一个数据字节。                 |
    | ---- | ------------------------------------------------------------ |
    | int  | read(byte[] b)        从此输入流中将最多 b.length 个字节的数据读入一个 byte 数组中。 |
    | int  | read(byte[] b,  int off, int len)       从此输入流中将最多 len 个字节的数据读入一个  byte 数组中。 |

**读取数据**

- read()

- ```java
  public class Demo1 {
      public static void main(String[] args) throws IOException {
          //FileInputStream in = new FileInputStream(new File("a.txt"));
          FileInputStream in = new FileInputStream("a.txt");
  
          // read()读取数据  返回的是字节值
          //readSingle(in);
  
          // read(byte[] b) 返回的是个数
          //readMuti(in);
  
          // read(byte[]b,int off,int len)
          byte[] bytes = new byte[4];
          int readCount = in.read(bytes, 0, bytes.length);
          System.out.println(readCount);
          System.out.println(new String(bytes,0,readCount));
  
  
          // close
          in.close();
      }
  
      private static void readMuti(FileInputStream in) throws IOException {
          byte[] bytes = new byte[4];
          int readCount = in.read(bytes);
          System.out.println(readCount);
          System.out.println(new String(bytes,0,readCount));
      }
  
      private static void readSingle(FileInputStream in) throws IOException {
          int readData = in.read();
          System.out.println(((char) readData));
  
          int readData2 = in.read();
          System.out.println(((char) readData2));
  
          int readData3 = in.read();
          System.out.println(((char) readData3));
  
          int readData4 = in.read();
          System.out.println(((char) readData4));
  
          int readData5 = in.read();
          System.out.println((readData5));
      }
  }
  
  ```

  注意:（写入长度）

- ```java
  public class Demo2 {
      public static void main(String[] args) throws IOException {
          FileInputStream in = new FileInputStream("a.txt");
          byte[] bytes = new byte[4];
          int readCount = in.read(bytes);
          System.out.println(readCount);
          System.out.println(new String(bytes,0,readCount));
  
          int readCount2 = in.read(bytes);
          System.out.println(readCount2);
          System.out.println(new String(bytes,0,readCount2));
  
          in.close();
      }
  }
  
  ```

  

**循环读取数据**

- ```java
  public class Demo3 {
      public static void main(String[] args) throws IOException {
          // 第一种方式
          FileInputStream in = new FileInputStream("a.txt");
          //readWhile1(in);
  
          // 第二种方式
          //readwhile2(in);
  
          // 第三种方式 :用字节数组的方式
          // readCount用来接收读取到的字节个数
          int readCount;
          byte[] bytes = new byte[1024];
          while ((readCount=in.read(bytes)) != -1) {
              System.out.println(new String(bytes,0,readCount));
          }
  
          // close
          in.close();
      }
  
      private static void readwhile2(FileInputStream in) throws IOException {
          int readData;
          while ((readData = in.read()) != -1) {
              System.out.print(((char) readData));
          }
      }
  
      private static void readWhile1(FileInputStream in) throws IOException {
          while (true) {
              int readData = in.read();
              System.out.println(readData);
              if (readData == -1) {
                  break;
              }
          }
      }
  }
  
  ```


读取单个字节与读取多个字节,哪个效率更好?

- 肯定是读取多个字节的效率更高

#### **文件复制练习**

- 文本文件

  - 单字节

  - 多字节

  - ```java
    public class Ex1 {
        public static void main(String[] args) throws IOException {
            // 创建字节输入流对象
            FileInputStream in = new FileInputStream("D:\\workspace2\\30th\\code\\day16_io02\\src\\com\\cskaoyan\\bytestream\\in\\Demo2.java");
    
            // 创建字节输出流对象
            FileOutputStream out = new FileOutputStream("D:\\copy2.txt");
    
            // 边读边写
            // 单个字节的形式
            //copy1(in, out);
    
            //字节数组 0ms
            long start = System.currentTimeMillis();
            byte[] bytes = new byte[1024];
            int readCount;
            while ((readCount = in.read(bytes)) != -1) {
                out.write(bytes,0,readCount);
            }
            long end = System.currentTimeMillis();
            System.out.println("耗时:" + (end - start) + "ms");
    
            // close
            in.close();
            out.close();
        }
        // 耗时:13ms
        private static void copy1(FileInputStream in, FileOutputStream out) throws IOException {
            long start = System.currentTimeMillis();
            int readData;
            while ((readData=in.read()) != -1) {
                out.write(readData);
            }
            long end = System.currentTimeMillis();
            System.out.println("耗时:" + (end - start) + "ms");
        }
    }
    
    ```

    

- 图片文件

  - 单字节

  - 多字节

  - ```java
    public class Ex2 {
        public static void main(String[] args) throws IOException {
            // 单字节
            FileInputStream in = new FileInputStream("D:\\mm.jpg");
            FileOutputStream out = new FileOutputStream("copy_mm2.jpg");
            //copy1(in, out);
    
            // 多字节  耗时:0ms
            long start = System.currentTimeMillis();
    
            byte[] bytes = new byte[1024];
            int readCount;
            while ((readCount = in.read(bytes)) != -1) {
                out.write(bytes,0,readCount);
            }
            long end = System.currentTimeMillis();
    
            System.out.println("耗时:" + (end - start) + "ms");
    
            //close
            in.close();
            out.close();
        }
    //耗时:97ms
        private static void copy1(FileInputStream in, FileOutputStream out) throws IOException {
            // 边读边写
            long start = System.currentTimeMillis();
            int readData;
            while ((readData = in.read()) != -1) {
                out.write(readData);
            }
            long end = System.currentTimeMillis();
    
            System.out.println("耗时:" + (end - start) + "ms");
        }
    }
    
    ```

    

- 视频文件

  - 单字节

  - 多字节

  - ```java
    public class Ex3 {
        public static void main(String[] args) throws IOException {
            // 单字节
            FileInputStream in = new FileInputStream("D:\\aa.mp4");
            FileOutputStream out = new FileOutputStream("copy_aa2.mp4");
            //long start = System.currentTimeMillis();
    
            //copy1(in, out, start);
    
            // 多字节 耗时:16ms
    
            long start = System.currentTimeMillis();
    
            byte[] bytes = new byte[1024];
            int readCount;
            while ((readCount = in.read(bytes)) != -1) {
                out.write(bytes,0,readCount);
            }
            long end = System.currentTimeMillis();
    
            System.out.println("耗时:" + (end - start) + "ms");
    
    
            in.close();
            out.close();
    
        }
        // 耗时:8700ms
        private static void copy1(FileInputStream in, FileOutputStream out, long start) throws IOException {
            int readData;
            while ((readData = in.read()) != -1) {
                out.write(readData);
            }
            long end = System.currentTimeMillis();
    
            System.out.println("耗时:" + (end - start) + "ms");
        }
    }
    ```

利用缓冲流复制文件

```java
public class Demo3 {
    public static void main(String[] args) throws IOException {
        // 创建缓冲输入流对象
        BufferedInputStream bi = new BufferedInputStream(
                new FileInputStream("D:\\aa.mp4"));
        // 创建缓冲输出流对象
        BufferedOutputStream bo = new BufferedOutputStream(
                new FileOutputStream("copy_aa4.mp4"));
        // 单个字节 复制  边读边写
        //copy1(bi, bo);

        // 字节数组  耗时:4ms
        long start = System.currentTimeMillis();

        int readCount;
        byte[] bytes = new byte[1024];
        while ((readCount = bi.read(bytes)) != -1) {
            bo.write(bytes,0,readCount);
        }
        long end = System.currentTimeMillis();
        System.out.println("耗时:" + (end - start) + "ms");

        // close
        bi.close();
        bo.close();
    }

    private static void copy1(BufferedInputStream bi, BufferedOutputStream bo) throws IOException {
        long start = System.currentTimeMillis();
        int readData;
        while ((readData=bi.read()) != -1) {
            bo.write(readData);
        }
        long end = System.currentTimeMillis();
        System.out.println("耗时:" + (end - start) + "ms");
    }
}

```





#### BufferedInputStream

`BufferedInputStream` 为另一个输入流添加一些功能

**构造方法**

| BufferedInputStream(InputStream in)        创建一个 BufferedInputStream 并保存其参数，即输入流  in，以便将来使用。 |
| ------------------------------------------------------------ |
| BufferedInputStream(InputStream in,  int size)       创建具有指定缓冲区大小的 BufferedInputStream  并保存其参数，即输入流 in，以便将来使用。 |

**继承关系**

```
<c> BufferedInputStream
	<c> FilterInputStream
		<c> InputStream
			<c> Object
			<I> Closeable
```



简单使用

```java
public class Demo2 {
    public static void main(String[] args) throws IOException {
        // 利用缓冲输入流读取数据
        BufferedInputStream bi = new BufferedInputStream(
                new FileInputStream("a.txt"));
        //int readData = bi.read();
        //System.out.println(((char) readData));
        byte[] bytes = new byte[1024];
        int readCount = bi.read(bytes);
        System.out.println(new String(bytes,0,readCount));
        bi.close();
    }
}

```



练习:

利用装饰器的设计模式,包装BufferedInputStream,扩展功能

要求:读取到的数据全部是小写的.

提示:重写read方法  继承FilterInputStream

```java
public class LowerCase extends FilterInputStream {
    /**
     * Creates a <code>FilterInputStream</code>
     * by assigning the  argument <code>in</code>
     * to the field <code>this.in</code> so as
     * to remember it for later use.
     *
     * @param in the underlying input stream, or <code>null</code> if
     *           this instance is to be created without an underlying stream.
     */
    protected LowerCase(InputStream in) {
        super(in);
    }
    // 重写read()
    @Override
    public int read() throws IOException {
        int readData = super.read();
        //if (readData == -1) {
        //    return readData;
        //} else {
        //    // 如果不=-1 把读到的数据转换成小写
        //    readData = Character.toLowerCase(((char) readData));
        //}
        //return readData;

        return (readData == -1 ? readData : Character.toLowerCase(((char) readData)));
    }
    // read(b, off, len)
    @Override
    public int read(byte[] b, int off, int len) throws IOException {
        int readCount = super.read(b, off, len);
        for (int i = off; i < off+readCount; i++) {
            b[i] = ((byte) Character.toLowerCase(((char) b[i])));
        }
        return readCount;
    }
}
```

单元测试

```java
public class LowerCaseTest {
    // 测试单个字节
    @Test
    public void read() throws IOException {
        LowerCase lowerCase = new LowerCase(
                new BufferedInputStream(new FileInputStream("a.txt")));
        int readData = lowerCase.read();
        assertEquals(97,readData);
    }
    // 测试字节数组
    @Test
    public void read1() throws Exception{
        LowerCase lowerCase = new LowerCase(
                new BufferedInputStream(new FileInputStream("a.txt")));
        byte[] bytes = new byte[1024];
        int readCount = lowerCase.read(bytes, 0, bytes.length);
        String s = new String(bytes, 0, readCount);
        assertEquals("abc",s);
    }
}
```



# 字符流





# 其他流

## 数据流



## 打印流



## 对象流



