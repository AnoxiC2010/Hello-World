# 文件输入与输出 Scanner&PrintWriter

```java
package com.test;
import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Scanner;

public class Test {
    public static void main(String[] args) throws IOException {
        File file = new File("C:\\Users\\AnoxiC2010\\Desktop\\Test.txt");
        Path path = Paths.get("C:\\Users\\AnoxiC2010\\Desktop\\Test.txt");
        //文件输入的两种方式
        Scanner in = new Scanner(file, "UTF-8");
//      Scanner in = new Scanner(path, "UTF-8");
        String s = "";
        while (in.hasNextLine()) {
            s = in.nextLine();
            System.out.println(s);
        }
        //文件输出
        PrintWriter out = new PrintWriter("C:\\Users\\AnoxiC2010\\Desktop\\Test.txt", "UTF-8");
        out.println("第一行");
        out.println("第二行");
        out.close();//不close的话不会写入
        //查看是否写入
        in = new Scanner(path, "UTF-8");//不新建对象的话不读取新内容
        while (in.hasNextLine()) {
            s = in.nextLine();
            System.out.println(s);
        }
        in.close();//关不关到都能输出
    }
}
```

> java.util.Scanner 5.0
>
> * Scanner(File f)
>
>   构造一个从给定文件读取数据的Scanner
>
> * Scanner(String data)
>
>   构造一个从给定字符串读取数据的Scanner
>
> java.io.PrintWriter 1.1
>
> * PrintWriter(String fileName)
>
>   构造一个将数据写入文件的PrintWriter。文件名由参数指定
>
> java.nio.file.Paths 7
>
> * static Path get(String pathname)
>
>   根据给定的路径名构造一个Path

# 循环相关break lable

除了循环也可以将标签应用到任何语句中，甚至可以应用到if语句或者块语句中，像goto，但只能跳出语句块，不能跳入语句块，不提倡。

循环中continue也可以配合lable使用

```java
lable:{
    ...
    if(condition) break lable; //exit block
    ...
}
//jumps here when the break statement executes
```

# 大数值 BigInteger & Decimal

```java
//将普通数值转换为大数值，使用静态valueOf方法
BigInteger a = BigInteger.valueOf(100);
```

> java.math.BigInteger 1.1
>
> * BigInteger add(BigInter other)
>
> * BigInteger subtract(BigInteger other)
>
> * BigInteger multiply(BigInteger other)
>
> * BigInteger divide(BigInteger other)
>
> * BigInteger mod(BigInteger other)
>
>   返回这个大整数和另一个大整数other的和、差、积、商、余数。
>
> * int compareTo(BigInteger other)
>
>   如果此大整数与另一个大整数other相等，返回0；此大整数小于另一个大整数other，返回负数；否则返回正数。
>
> * static BigInteger valueOf(long x)
>
>   返回值等于x的大整数。
>
> java.math.BigInteger 1.1
>
> * BigDecimal add(BigDecimal other)
>
> * BigDecimal subtract(BigDecimal other)
>
> * BigDecimal multiply(BigDecimal other)
>
> * BigDecimal divide(BigDecimal other RoundingMode mode) 5.0
>
>   返回这个大实数与另一个大实数other的和、差、积、商。要想计算商，必须给出舍入方式（rounding mode）。RoundingMode.HALF_UP是在学校中学习的四舍五入方式。它适用于常规的计算。有关于其他的舍入方式可查看API文档。
>
> * int compareTo(BigDecimal other)
>
>   如果这个大实数与另一个大实数相等，返回0；小于另一个大实数，返回负数；否则，返回正数。
>
> * static BigDecimal valueOf(long x)
>
> * static BigDecimal valueOf(long x, int scale)
>
>   返回值为x或x/10(scale 上标)的一个大实数。

# 数组

```java
//无论哪种创建方式，都不会跳过默认初始化的过程
//for each增强循环
//定义一个变量variable用于暂存集合collection中的每一个元素
//这个变量相当于是拷贝的元素，fori循环中拿到的直接就是集合的元素
//collection必须是数组或者实现了Iterable接口的类对象
for(variable : collection) statement

//利用Arrays类的toString方法简单打印数组中的所有值
Arrays.tostring(collection)返回形如[xx,xx,xx]的字符串
 
//利用匿名数组再不创建新变量的情况下重新初始化一个数组
int smallPrimes = {2, 3, 5, 7};
smallPrimes = new int[]{17, 19, 23, 29};

//数组拷贝
//用Arrays类的copyOf方法把一个数组中的所有值拷贝到新的数组中去
int[] numbers = {1, 2, 3, 4, 5};
int[] copiedNumbers = Arrays.copyOf(numbers, numbers.length());
//第二个参数是新数组长度，通常可利用它来增加数组长度
//多余元素被赋初始值，相反长度小于原来，则只拷贝最前面的元素
int[] copiedNumbers = Arrays.copyOf(numbers, 2 * numbers.length());

//命令行参数
//main方法的参数args可以通过在命令行执行命令语句后加入参数以String数组形式传入
//如命令行执行Hello.class：java Hello xxx xxx xxx 后面几个为args数组的元素

//数组排序
int a = new int[1000];
...
Arrays.sort(a);//升序，优化的快速排序算法
//生成随机数
//Math.random()方法返回[0,1)的随机浮点数。
int r = (int)(Math.random() * n);//返回[0,n-1)之间的随机数

//快速打印二维数组的数据元素列表[[...],[...],...]
System.out.println(Arrays.deepToString(arrs));
```

> java.util.Arrays 1.2
>
> * static String toString(type[] a) 5.0
>
>   返回包含a中数据元素的字符串，这些数据元素被放在括号内，并用逗号分隔。
>
>   参数：a 类型为int、long、short、char、byte、boolean、float或double的数组。
>
> * static type copyOf(type[] a, int length) 6
>
> * static type copyOfRange(type[] a, int start, int end) 6
>
>   返回与a类型相同的一个数组，其长度为length或者end-start，数组元素为a的值。
>
>   参数：a 类型为int、long、short、char、byte、boolean、float或double的数组。
>
>   start 起始下标（包含这个值）
>
>   end 终止下标（不包含这个值）。这个值可能大于a.length。在这种情况下，结果为0或false。
>
>   length 拷贝的数据元素长度。如果length值大于a.length，结果为0或false；否则，数组中只有前面length个数据元素的拷贝值
>
> * static void sort(type[] a)
>
>   采用优化的快速排序算法对数组进行排序。
>
>   参数：a 类型为int、long、short、char、byte、boolean、float或double的数组。
>
> * static int binarySearch(type[] a, type v)
>
> * static int binarySearch(type[] a, int start, int end, type v) 6
>
>   采用二分搜索算法查找值v。如果查找成功，则返回相应的下标值；否则，返回一个负数值r。-r-1是为了保持a有序v应插入的位置。
>
>   参数：a 类型为int、long、short、char、byte、boolean、float或double的***有序***数组。
>
>   start 起始下标（包含这个值）。
>
>   end 终止下标（不包含这个值）。
>
>   v 同a的数据元素类型相同的值。
>
> * static void fill(type[] a, type v)
>
>   将数组的所有数据元素值设置为v。
>
>   参数：a 类型为int、long、short、char、byte、boolean、float或double的数组。
>
>   v 与a数据元素类型相同的一个值。
>
> * static boolean equals(type[] a, type[] b)
>
>   如果两个数组大小相同，并且下标相同的元素都对应相等，返回true。
>
>   参数：a、b 类型为int、long、short、char、byte、boolean、float或double的两个数组。

# 对象与类

## 时间对象

```java
//Date类对象描述的是一个时间点，使用距离一个固定的时间点的毫秒数（可正可负）表示的，这个点就是纪元（epoch），是UTC时间1970年1月1日00:00:00。Date类提供的日期处理是Gregorian阳历表示法。
Date now = new Date();//构造对象时的日期
//LocalDate类用来表示大家熟悉的日历表示法，不能new，要用静态工厂方法调用构造器
LocalDate now = LocalDate.now();//构造对象时的日期
//LocalDate构造特定日期的对象
LocalDate oneday = LocalDate.of(1991, 1, 1);
//LocalDate对象分别获取年月日的方法
int year = oneday.getYear();//1991
int monthValue = oneday.getMonthValue();//1
int dayOfMonth = oneday.getDayOfMonth();//1
//获取指定天数之后的新日期
LocalDate aThousandDaysLater = oneday.plusDays(1000);
year = aThousandDaysLater.getYear();//1993
monthValue = aThousandDaysLater.getMonthValue();//09
dayOfMonth = aThousandDaysLater.getDayOfMonth();//27
//Date的getDate、getMonth、getYear已被标记为不推荐使用，Date类已被标记为废弃不用
```

> java.time.LocalDate 8
>
> * static LocalTime now()
>
>   构造一个表示当前日期的对象。
>
> * static LocalTime of(int year, int month, int day)
>
>   构造一个表示给定日期的对象
>
> * int getYear()
>
> * int getMonthValue()
>
> * int getDayOfMonth()
>
>   得到当前日期的年、月、日
>
> * DayOfWeek getDayOfWeek
>
>   得到当前日期是星期几，作为DayOfWeek类的一个实例返回。电泳getValue来得到1~7之间的一个数，表示这是星期几，1表示星期一，7表示星期日
>
> * LocalDate plusDays(int n)
>
> * LocalDate minusDays(int n)
>
>   生成当前日期之后或之前n天的日期

请不要在构造器中定义与实例域同名的变量

隐式参数与显示参数：

每个方法中，关键字this表示隐式参数，在方法中直接声明的叫做显式参数。某些程序员会偏好this.xxx的风格将实例域与局部变量明显的区分开

封装

需要获得或设置实例域的值，需要提供三项内容：

* 一个私有的数据域
* 一个公有的域访问器方法
* 一个公有的域更改器方法

这样做的好处是可以更改内部实现，除了该类的内部方法之外，不会影响其他代码。

注意不要编写返回引用可变对象的访问器方法。例如Date类是有一个更改器方法setTime，结果是返回的Date对象是可变的，就破坏了封装性。如果需要返回一个可变对象的引用，应该首先对它进行克隆（clone），这样我们将返回一个可变数据的拷贝。

> 一个方法可以访问所属类的所有对象的私有域

```java
class Employee {
   ...
    public boolean isSameAge(Employee anotherEmployee) {
        return this.age == anotherEmployee.age;
    }
}
```

## 默认域的初始化

> 如果在构造器中没有显示地给域赋初值，那么就会被自动地赋为默认值（数值为0、布尔值为false、对象引用为null）。如果不明确的对域进行初始化，就会影响程序代码的可读性,这不是良好的编程习惯。如通常我们不想的到一个null的引用。



# 继承

## 子类对象的初始化（initialization）

> 子类继承了父类，子类中就包含了父类的成员
>
> 那么在创建初始化子类对象时，和之前相比也会有较大的不同



> 子类创建对象过程

- JVM仍然是创建谁的对象，就加载谁，先加载子类
- 但是很快，在子类还没有加载的时候，JVM发现子类有父类
  - 父类如果不存在，子类肯定也不可能存在
- 于是JVM调转枪头，开始加载父类
- 加载完父类，再加载子类
- 类加载都结束后，开始创建堆上的对象
- 堆上的对象中，会有一片空间，用来存放父类的成员
  - 子类对象就由两部分组成
  - 一部分是子类自己独特的成员
  - 另一部分是从父类继承过来的成员
- 现在堆上就真实存在了一个子类对象
  - 子类对象中存放父类成员的内存区域，可以近似的看成是一个父类对象
  - 所以子类的内存图，近似看成子类对象“装着”父类对象
  - 注意，**这个父类对象只是近似看作，不会真的创建了父类对象**
    - 创建子类对象，只会类加载父类，不会真的创建父类

> 仍然有一个棘手的问题

- 子类对象中的，父类成员变量和子类自身成员变量，谁先初始化默认初始值？
  - 答：先给父类成员变量默认初始化，再默认初始化子类
  - 为什么？答：先父后子，没毛病，首先要有父亲，才有儿子
  - 其次，子类成员变量的初始化，可以依赖父类成员变量
    - 这个时候如果子类先初始化，显然是要报错的



> 问题仍然没有结束

- 子父类的类加载顺序是由JVM去保证的，但是子父类的初始化先后顺序又是怎么保证的呢？
- 它的原理是什么呢？

> 我们已经知道了构造器是可以用来初始化成员变量，会由JVM自动调用
>
> 用构造器去保障这种先后顺序，怎么做呢？

- 答：只需要在子类的构造器的第一行，调用父类构造器就可以了

​	 

> 我们没有自己手动在子类构造器的第一行，调用父类构造器，但是仍然达成了先初始化父类
>
> 再初始化子类的效果，是什么原因呢？
>
> 显然这里存在了一个隐式调用，于是子类对象的初始化就有了两种方式

- 隐式的调用了父类构造方法（JVM保证）
- 程序员显式的调用父类构造方法（代码保证）

## 显隐式子类初始化

> 重点学习一下两种方式

### 子类对象的隐式初始化（implicit）

> 隐式初始化，JVM自动调用，无需我们手动操作
>
> 条件为

- **父类中有默认的构造方法**
  - 子类的构造器中没有显式调用父类的构造方法
- 达成上述两个条件，则JVM在初始化子类对象时进行隐式初始化

  - 永远先执行父类的构造方法，顺序为
    - 最上层的父类（Object）
    - 其他父类（继承链中越处于上流越先执行）
  - 所有父类的构造方法都执行完毕，开始执行子类构造方法

> 需要注意的是
>
> - 隐式初始化，JVM总是调用父类的无参构造，如果父类没有，就要报错
> - Object类也有默认无参
> - 隐式初始化总是不传参数，如果我们想要对参数进行赋值，就必须使用显式的子类初始化

### 子类对象的显式初始化（Explicit ）

> 显式初始化，需要程序员手动写代码，告诉JVM调用哪个父类构造器
>
> 如何使用？

- 必须在子类构造器的第一行，显式的调用父类构造方法，那么如何调用父类构造器？

  - 使用super关键字调用

  - 语法

    ```Java
    super(父类构造器参数);
    ```

> 什么是super关键字？

- super代表当前类的父类"对象"的引用
- this代表当前类的对象
- 两者的使用没有明显差别，只是
  - **this在当前类中不受访问权限控制，super访问父类成员，受访问权限控制**
  - 因为当前类中即便是private仍然可以访问，但是super就不在当前类中了

```
this VS super  

this关键字：表示当前对象的引用         super关键字：super代表父类对象的引用

this调用当前类中定义的构造方法：this(实参列表)          
super调用父类中定义的构造方法：super(实参列表)

this访问当前对象的成员变量值          super访问父类对象中，成员变量的值

this访问当前对象的成员方法            super访问父类对象，成员方法                            
```



**super与this关键字**

**this关键字概念：**

this代表所在类的对象引用。

**记住： 方法被哪个对象调用，this就代表哪个对象。**

**1.super可以在子类中 调用父类中名称相同的 成员方法和成员变量**

**2.this可以在方法中调用 类中的与方法内局部变量名称相同 的成员方法和成员变量**

**3.super和this的区别**

(a).this 代表**当前类的对象**

代表对象的内存空间标识（用来存储当前类定义的内容，成员变量、方法）

(b).super （代表父类对象） 可以这么理解，实际并不代表父类对象

代表对象的内存空间的标识（用来存储父类定义的内容，成员变量、方法）

**使用场景：**

当局部变量和成员变量名字相同时用this，子类变量和父类变量名字相同时用super

**super用法：（this和super均适用）**

**1.访问成员变量**

this.成员变量  super.成员变量    （局部变量直接调用不需要修饰符）

**2.访问构造方法**

 this(…)           super(…)        如果是有参方法，()里面写参数

**3.访问成员方法**

this.成员方法()  super.成员方法()



隐式子类对象创建：

​	条件： 

​		a. 当父类提供了默认的构造函数(无参构造方法)

​        b. 子类的构造方法中, 没有显式调用父类的其它构造方法

​	结果：

​		JVM自动在子类构造方法第一句加上  “ super() “

​		在执行子类的构造方法之前，JVM会自动执行父类

​	

显式子类对象创建：

​	程序员写代码告诉JVM在调用子类构造器之前调用父类构造方法

​	可以在子类构造器的第一行使用super关键字，调用父类的构造方法

​		

总结：

​	**1，无论是隐式还是显式，最终都是为了保证父类构造器先于子类执行**

​	2，若父类中不存在默认构造方法，则必须在子类构造方法中使用super关键字调用父类构造器

​	3，在子类构造方法中，super语句必须在第一行

​	4，在子类构造方法中，也可以用this调用自身构造，也必须在第一行

​	5，this和super不能共存

​	6，构造代码块和静态代码块也是“先父后子”



为什么this和super都必须在第一行？

​	因为子类构造器第一行永远都有一个super关键字调用，如果你自己的super和this不在第一行，会形成循环

## 子类的属性隐藏（field hidden）

> 子父类中能否拥有同名的属性呢？
>
> 如果可以，请尝试

- 创建子类对象，使用对象名点的形式访问同名变量，结果是什么？
- 创建子类对象，在子类中，编写方法，返回该属性
  - 用子类对象调用该方法，返回的结果是？
  - 方法的就近原则
- 创建子类对象，在父类中，编写方法，返回该属性
  - 用子类对象调用该方法，返回的结果是？
  - 方法的就近原则
- 最终我们发现，子类可以访问到父类的成员变量
  - 但是由于编译器检索机制的限制，好像父类的属性被隐藏了一样
  - 称之为子类的属性隐藏





> 如果我就想在子类方法中，访问父类的同名成员变量，怎么办？

- super关键字





> 对象名点成员变量名的，编译器检索机制

- 先从子类本身中去找---->子类中找不到再去父类中找----->再找不到就报错
- 但是一般来说，我们都是通过方法访问成员变量



> 注意事项

- 静态成员变量也可以被继承，但是静态成员变量如果是同名的，是一个全新的，会覆盖掉原先的静态成员
- 子类父类的同名静态成员各自独立属于自己的类，如果子类没有便完全继承父类的静态成员

## 子类的方法覆盖（override）

> 子父类中能否拥有同名的方法？
>

- 在父子类中声明两个个一模一样的方法，但是方法体输出不同
  - 创建子类对象，直接调用该方法，结果是什么？
- 再在父子类中定义两个方法，分别在方法体中调用自身方法名一样的方法
  - 创建子类对象，分别调用两个方法，结果是什么？
- 我们发现无论怎么操作，都只能访问子类中的同名方法，这就是方法的覆盖



> 如果想在子类的方法中，访问父类方法，应该怎么办？

- super关键字



> 对象名点方法访问的方式，编译器的检索机制

- 先从子类本身中去找---->子类中找不到再去父类中找----->再找不到就报错



> 什么时候使用方法的覆盖？

- 当我们需要在子类中，修改父类方法的实现的时候
- 使用方法的覆盖时，添加@Override注解来标记
- 例如：比如对于动物的叫，人类的吃



> 方法覆盖的注意事项

- 父类中私有方法不能被重写
- 子类重写父类方法时，访问权限不能更低
- 静态方法在使用现象上，很像是被重写了，但实际上静态方法不能被重写，而是直接是一个新的静态成员



- 重写 VS 重载

|              | 重载（overload） |                      重写（override）                       |
| :----------: | :--------------: | :---------------------------------------------------------: |
| 发生的类不同 |   发生在同类中   |               发生在子父类之间,肯定不是一个类               |
|    方法名    |     必须相同     |                          必须相同                           |
|   参数列表   |     必须不同     |                          必须相同                           |
|  权限修饰符  |      不影响      |            重写的方法访问权限必须大于等于原方法             |
|     异常     |      不影响      |                重写的方法不能抛出更多的异常                 |
|  返回值类型  |      不影响      | 重写的方法的返回值类型必须和原方法兼容,代表可以不是完全一致 |

- 被static、final、private修饰的父类方法无法被重写

## final和限制继承

> final是一个修饰符，可以用来修饰类、方法和变量（包括成员变量和局部变量）

### final修饰类

> 表示”最终的类“
>
> 当用final修饰一个类时，表明这个类不能被继承

- 除了这一点外，这个类照常使用，比如创建对象，比如访问方法，比如继承别的类
- 从设计角度来讲，一个final修饰的类应该是
  - 不需要复用成员
  - 功能已经特别强大，足够满足需求
  - 需要绝对的保证安全，以致于不让它被继承
- 常见的final类
  - String
  - System
  - Math
  - 所有基本数据类型的包装类和一个Void
    - Boolean，Character，Short，Integer，Long，Float，Double，Byte，Void
- 除非你十分确定这个类以后不会被用来继承 ，为了保证安全，可以设置一个类为final类
  - 不然一般情况下，尽量不要把一个类设置成final

### final修饰方法

> 表示”最终的方法“
>
> 当一个方法被final修饰后，可以被继承，但是无法被重写

- final修饰方法，就把方法锁住了，任何继承这个方法的类都无法覆盖该方法
- 如果一个方法已经能够满足需求，并且明确知道它不应该被修改，修改会产生问题
  - 可以将方法设置成final方法
  - 否则，正常情况下，不要随便使用final修饰方法

### final修饰变量

> 表示”最终的变量“，是一种自定义常量，普遍来说，命名应该采用全大写，下划线连接的方式
>
> 修饰变量是final用得最多的地方，也是可能混淆的地方
>
> 总体来说，final修饰变量后
>
> - 如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改
> - 如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象
>   - 因为final修饰的是引用，而引用中装的是地址
>   - 但是其引用的对象的状态是可以改变的

#### final修饰普通成员变量

- final修饰普通成员变量，表示常量，**在整个创建对象过程中它们的值，只能修改一次也必须显式赋值一次**
- 总结给普通成员变量赋值的方式
  - 显式初始化语句
  - 构造代码块
  - 构造器
  - 创建对象后，调set方法，或者直接赋值
  - 对于final修饰的普通成员变量，前三种必然要有一种
- 对于同一个类的同一个final修饰的变量，不同对象可能会有不同的值

#### final修饰静态成员变量（常用）

- final修饰静态成员变量，表示全局常量，**在整个静态成员赋值过程中，只能修改一次也必须显式赋值一次**
  - **访问一个类的基本数据类型和String类型的final静态全局常量不触发类加载**
  - 被所有对象共享，每个对象都必须有同一个值，且不可改变
- 给final静态成员变量赋值
  - 显式赋值语句
  - 静态代码块
- final static 还是static final？
  - 建议用static final
- 静态常量一般全部大写，用下划线隔开

#### final修饰局部变量

- 在方法体和方法参数列表中定义final常量，表示该常量不可更改
- 必须显式的赋值初始化，不然也没别的方式初始化了
- 在形参列表中声明final常量，表示该参数是一个常量，在接收后无法修改

#### 特别的final修饰引用数据类型

- 表示引用指向的对象不可变，但对象的状态可变
- 例如**final修饰Student类型的变量s，则s的地址值不能改变，**
- **也就是说s要始终指向同一个对象。  但是所指对象的属性值可以改变，只要对象的地址不变即可**



final修饰匿名对象 会咋样？

final new Student() 语法不允许



```
final修饰普通成员变量，表示常量，创建对象的时候，也只能初始化它的值一次，这个过程中也不能改了。创建对象以后，它们的值就不可改变了
```



- 对于一个final变量
  - 构建对象之后，它们的值就不可以被修改了
  - 如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改
  - 如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象
- 使用final修饰一个基本数据类型变量，该变量就变成了常量，只能被赋值初始的一次
  - 自定义常量，无法在程序执行时改变
  - 对于常量，我们最好static final一起使用
- 对于基本数据类型而言，final修饰后，值就不可变了
- 对于引用数据类型而言，final修饰后，引用的地址就不可变了，但引用对象的状态可以改变



> 注意：

- 常量必须显示初始化，即必须赋值一次，不用能默认值。
- 只能赋值一次，即使之后的赋值和原来的值一样也不行
- 在静态常量在常量池中，使用不需要类加载，静态常量需要创建对象赋初值的，使用需要类加载

# 多肽

## 多态的引入（polymorphic）

> 什么是多态？

- 某同一个事物，在不同的时刻表现出不同的状态

  - 对于Java而言，指的是同一个类型引用，在指向不同的具体对象时，运行时表现不同的行为

  - 其实就是父类引用指向了不同的子类对象

  - 例如

    - ```Java
      Animal a = new Cat();
      Animal a = new Dog();
      ```

- 多态的前提条件

  - 要有继承关系
  - 继承后发生子父类的方法重写
  - 父类的引用指向子类的对象

- 不能发生多态的情况

  - 不能够被继承，final类
  - 不能被方法覆盖
    - final方法
    - static方法
    - private方法
    - 构造方法无法被继承

- 当父类的引用，指向不同的实际对象时，调用方法，结果不同

- 写一个方法，参数列表为父类引用，可以传入具体的对象

  - 多态对程序的扩展性

## 多态的访问特征

> 发生多态后，通过引用调用成员的方式发生了改变
>
> 父类 引用 = new 子类();

- 对于成员变量而言
  - 编译时看左边，运行时看左边
  - 也就是说成员变量是没有“多态”的（因为多态的前提就是发生方法重写）
  - 多态现象是发生在方法之间，和成员变量没有关系
- 对于成员方法而言
  - 编译时看左边，运行时看右边

> 解释
>
> 父类 引用 = new 子类();

- 编译看左边
  - 编译看左边是说通过引用变量可以访问到的子类成员的范围
    - 是由引用类型来决定的，也就是说由父类中定义的成员决定
  - 我们只能通过引用去访问，堆上的对象，引用中必然装有该类型对象的成员信息
  - 只有通过引用变量，我才能访问到堆上的对象
    - 也就是说，对象的访问受限于引用变量本身的类型



> 解释方法的多态性，一个很贴切的例子

- 我家中的一台电视机，贼贵，功能很丰富
- 对于电视机而言，我们只能使用，遥控器去操作电视机
- 这也就是说，只有遥控器上提供的功能我们才能使用
  - 即便电视机本身功能多么强大，如果遥控器上只有音量键，那我们也毫无办法
  - 遥控器有啥功能，决定了我们能使用的功能
- 即使电视机本身功能再丰富，没有遥控器的支持，我们啥也用不了

> 把这个例子转换到Java程序中

- 电视机就相当于对象本身，而遥控器就是引用变量
- 实际对象的功能再强大，如果引用中没有这个功能，那也无法调用该功能
- 对象的行为，受限于引用变量，和对象本身没有直接关系
- 对象的引用类型决定了可以访问对象的成员范围
- 编译时看左边，运行时看右边



> 解释成员变量不具有多态性，一个例子

- 成员变量描述的是对象的“外貌特征”
- 把子类对象赋值给父类类型的引用，就相当于给子类对象披上了一个父类类型马甲
- 外貌特征上来看，这时候的子类就变成了父类
- 编译时看左边，运行时看左边

​	

## 多态的优缺点

- 多态的优点：
  - 要实现多态，必须要继承，提高了程序的可维护性（继承保证）
  - 发生多态后，同一个引用调用方法产生不同的行为
    - 提高了程序的简洁性和扩展性（多态保证）

- 多态的缺点：
  - 不能访问子类特有的功能

## 引用类型的类型转换

> 基本数据类型之间是可以发生数据类型转换的，引用数据类型也是可以的
>
> 但是引用数据类型发生转换的条件比较苛刻，出错后的问题也更严重
>
> 做引用数据类型的转换 小心小心再小心



引用数据类型要发生类型转换

- 前提：具有父子关系的两个类型之间
- 没有父子关系的两个类型之间不能发生类型转换，通过不了编译

### 自动类型转换

- 子类的引用转换成父类的引用，在继承链中属于向上，编译器默认允许

  - 称之为自动类型转换或者向上转型

  - 语法

  - ```java 
    父类 引用名 = new 子类();
    ```

  - 子类一定可以看成父类，所以能够自动转型

  - 向上转型是安全，可以放心使用

### 强制类型转换

- 父类的引用转换成子类的引用，在继承链中属于向下，编译器默认不允许，需要显式强行转换

  - 称之为强制类型转换或者向下转型

  - 语法

  - ```java
    子类 引用名 = (子类)父类引用;
    ```

  - 子类继承和扩展了父类，父类大多数情况下都不能看成子类，所以需要强制类型转换

  - **重要前提：强制类型转换若想成功，必须是该父类引用指向的对象本身就是一个要强转的子类对象**



- 强制类型转换是不安全的，要想转型成功，必须真实的对象和要转型的类型一致

  - 父类引用指向的不一定就是那个你要强转的子类的对象
  - 比如动物类的引用指向了一个猫对象，现在把引用强转成一个狗引用，能成功吗？

- 为了保障安全，向下转型推荐使用instanceof关键字校验

  - 语法

  - ```Java
    引用名 instanceof 类名
    ```

  - 这个表达式返回一个布尔类型的值

    - true代表该引用指向的对象，是一个后面类名的对象
    - null instanceof 任何类 结果都是false



### ClassCastException

> 强制类型转换一旦失败，就会抛出ClassCastException，程序报错终止

- 没有人会故意给自己找麻烦
- 不到万不得已，不要使用强制类型转换

## 子类实例化和多态案例

```java
public class Demo {
    public static void main(String[] args) {
        Father f1 = new Son(1000);//0
        Father f2 = new Father();//10
        Son s = new Son(1000);//0
    }
}

class Father {
static int f = 2;//父类静态成员
static {
    f = 3;//父类静态代码块
}
    int i = 10;//父类成员
    {
        i = 11;
    }
    public Father(int i) {

    }

    public Father() {

        System.out.println(getI());
    }

    public int getI() {
        return i;
    }
}

class Son extends Father {
    static int s = 5;//子类静态成员
    static {
        s = 6;//子类静态代码块
    }

    int i = 100;
    {
        i = 101;
    }
    public Son(int a) {
        this.i = a;
    }

    public int getI() {
        return i;
    }
    public Son() {

    }
}

```

# 抽象类（abstract）

> 抽象类定义
>
> 在继承体系中，从祖先类开始，随着一个个子类的定义，子类变得越来越具体
>
> 而祖先类则更具有一般性和抽象性
>
> 在这种情况下，为了体现祖先类在设计上的抽象性
>
> 我们只将该类作为派生其他类的父类，而不能创建对象实例
>
> 这个时候，这样的类，我们称之为抽象类

- 抽象类使用abstract关键字标记

  - ```Java
    [访问权限修饰符] abstract class 类名{
    }
    ```

- 表示该类是一个抽象类

- 抽象类无法被实例化，抽象类不能实例化，但是开发中会提供子类，可以用多态的方式访问

- 抽象方法使用abstract关键字标记

  - ```Java
    [权限修饰符] abstract 返回值类型 方法名();
    ```

  - 表示该方法是一个抽象方法

  - 抽象方法必须在一个抽象类中

  - 抽象方法没有方法体，只有方法声明，不要忘记写分号



> 接下来，我们重点来研究一个抽象类的特点和使用
>
> 我们从下面两个角度分析

- 抽象类的成员
  - 成员变量
  - 成员方法
  - 构造方法
- 抽象类的子类



> 抽象类的成员特点：

- 抽象类具有普通构造方法，成员变量和成员方法

- 抽象类具体普通类都可以有的成员变量，静态成员变量，常量
- 抽象类可以有抽象方法，也可以有普通方法
  - 抽象方法起着占位的作用，该方法必须在子类中实现
  - 抽象方法不能是private、static、final修饰的
  - 普通方法可以作为一个默认实现，子类可以使用这个方法，也可以自行重写
  - 抽象类中可以没有抽象方法，这样做的目的是不让创建对象
    - 但是一般不要这么做，抽象类是一个设计上的概念，应该从设计上正确的使用它
    - 如果仅仅是为了不让外界创建对象，私有化构造方法即可
    - 普遍来说，既然是抽象类就应该有抽象方法，不然没啥意义
- 抽象类虽然不能实例化，但仍然有构造方法
  - 抽象类中的构造方法是留给子类初始化时调用的
  - Java当中，只要是类都具有构造方法
- 总结抽象类成员
  - 构造方法：同普通类
  - 成员变量：同普通类
  - 成员方法：可以是抽象方法，也可以是非抽象方法



>  抽象类的子类的特点：

- 抽象类的子类可以是抽象类，也可以是具体类
- 只有当子类重写了，所有的继承自抽象类的方法，该子类才能被定义为具体类
- 反之，若任一抽象方法没有被重写，该类都必须定义为抽象类



> abstract关键字使用上的注意点（notice）

- 不能用来修饰构造器、属性、代码块等结构
- 不能用来修饰final类
  - 无法被继承的类
- 不能用来修饰私有方法、静态方法 、final方法
  - 无法被重写的方法
- 一个抽象类中可以没有抽象方法，但是意义不是很大

# 接口

- 一方面，我们有时需要从多个类中派生出一个类，继承它们所有的成员，Java语法不适用
  - Java不支持多继承
- 另一方面，我们有时候需要从几个类中抽取出共同的行为特征
  - 而它们之间并没有“is-a”关系，继承思想显得不适用

> 于是：

- 为了复用这些“特殊行为”，我们迫切需要一种新的数据格式
  - 和类相似，可以抽取出共性，定义成员
  - 不受Java多继承限制
- 这种新的数据格式就是接口



> 接口的定义

- 语法

  ```java 
  [访问权限修饰符] interface 接口名{}
  ```

- 接口不是类，而是一种独立的数据类型，和class并列

  - 一个类实现的接口，也称之为接口的子类

- 一个类继承接口，称之为实现接口，使用关键字implements

  - 语法

    ```Java
    class 类名 implements 接口名 {}
    ```

  - 当一个类继承另一个类的同时，又实现接口

    - 必须要将实现接口放在继承类后面



> 接口概述

- interface表示一种数据类型，和class同级别
  - 是一种引用数据类型
  - 区别是：
    -  类定义的是一个数据集合基于这个数据集的一组操作(行为)
       - 类所描述的这一组行为，它们是有关系的（间接），都可以访问同一个数据集合
    -  接口表示数据类型，侧重于描述一组具有特殊功能的行为，这些行为
       - 可以完全没有任何关系。接口中的方法，它们的关系比较的松散
  - 类实现接口本质上也是一种继承，接口的实现类是接口的子类
  - 接口不能实例化
  - 接口不受多继承限制，接口可以多实现



> 接口的声明特征

- 接口的声明中默认存在一个abstract，所以接口必然是抽象的
- 接口普遍声明为public 鼓励继承



> 接口的成员特征：
>
> - 成员变量
> - 成员方法
> - 构造方法

- 接口中的所有成员变量都默认是由public static final修饰的

  - 无法使用除public外的访问权限修饰符，修饰成员变量
  - 普遍来说，开发时在接口中定义成员变量省略public static final
  - 但是接口内部不支持用static代码块给成员变量初始化
    - 必须要提供显式的初始化

- 接口中的所有方法都默认是由public abstract修饰的

- （了解即可）在JDK8中引入了默认方法

  - 语法

    ```java 
    default 返回值类型 方法名{
    }
    ```

  - 默认是public修饰

  - 不能用static、abstract修饰

  - 和抽象类中的具体方法一样，接口中的方法是给子类提供了一个默认实现

    - 子类可以选择直接继承使用该方法，也可以重写
    - 可以用子类对象调用，包括多态形式

  - 抽象类中有普通方法是很正常的，但是接口中不应该有具体方法，除非

    - 为了代码的兼容考虑
    - 例如class A、B、C很多类都实现了接口ITest，现在给接口新增了一个方法
      - 但这个方法不是所有类都需要重写的
      - 如果这个方法是一个抽象方法，所有类都必须实现该方法，否则会报错
      - 为了省事，可以选择default方法
      - 实际上Java8之所以引入default方法就是为了做这种事情
      - 省事是Java开发者省事，你不要省事

- （了解即可）在JDK8中引入了静态方法

  - 语法

    ```Java
    static 返回值类型 方法名{
    }
    ```

  - 默认是public修饰

  - 不能用abstract、default修饰

  - 可以使用接口名点方法名访问

- 从技术角度来说，以上实现方法是完全合法的

  - 只是它看起来违反了接口作为一个抽象定义的理念
  - 除非特别有必要，不要使用

- 接口没有构造方法，接口中的成员变量都是常量，不需要子类调用构造方法来初始化



> 接口的子类特征：

- 如果是一个类实现了接口
  - 必须要重写接口中所有的抽象方法，除非该类是一个抽象类
  - 一个类实现了接口，就变成了接口的子类
  - 接口可以多实现，配合default方法可以实现真正意义上的多继承（最好不要这么干）
  - 如果一个类又继承类又实现接口，一定是先继承再实现，顺序不能互换
- 如果是一个抽象类实现了接口
  - 可以不重写接口中的抽象方法
  - 可以实现多个接口而不重写方法
  - 抽象类也可以继承普通类
- 如果一个接口继承了接口
  - 接口之间不能互相实现，但是可以继承
  - 接口可以多继承



> 接口使用注意事项：

- 定义Java类的语法格式：先写extends，后写implements

  - ```Java
    class SubClass extends SuperClass implements InterfaceA{
    } 
    ```

- 一个类可以实现多个接口，接口也可以继承其它接口，这就是Java当中的“多继承”

- 实现接口的类中必须提供接口中所有方法的具体实现内容，方可实例化。否则，仍为抽象类

- 接口的主要用途就是被实现类实现

  - 所以接口和接口的成员默认都是public修饰，鼓励继承，鼓励重写

- 与继承关系类似，接口与实现类之间存在多态性

- 接口和类是并列的数据类型



> 接口和抽象类的异同

| 编号 | **区别点** |                          **抽象类**                          |                 **接口**                  |
| :--: | :--------: | :----------------------------------------------------------: | :---------------------------------------: |
|  1   |    定义    |                       包含抽象方法的类                       |         抽象方法和全局常量的集合          |
|  2   |    组成    |           构造方法、抽象方法、普通方法、常量、变量           | 常量、抽象方法、(jdk8:默认方法、静态方法) |
|  3   |    使用    |                   子类继承抽象类(extends)                    |         子类实现接口(implements)          |
|  4   |    关系    |                    抽象类可以实现多个接口                    |  接口不能继承抽象类，但允许继承多个接口   |
|  5   |    对象    |                 不能创建对象，但是有构造方法                 |       不能创建对象，也没有构造方法        |
|  6   |    局限    |                      抽象类不能被多继承                      |       接口之间能多继承，能被多实现        |
|  7   |    思想    |                  作为模板或对共性抽象，is-a                  |     作为标准或对共性能力抽象，like-a      |
|  8   |    选择    | 如果抽象类和接口都可以使用的话，优先使用接口，因为避免单继承的局限 |                                           |



Java提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于：

- 接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。
- 类可以实现很多个接口，但是只能继承一个抽象类
- 类如果要实现一个接口，它必须要实现接口声明的所有方法。但是，类可以不实现抽象类声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。
- 抽象类可以在不提供接口方法实现的情况下实现接口。
- Java接口中声明的变量默认都是final的。抽象类可以包含非final的变量。
- Java接口中的成员方法默认是public的。抽象类的成员方法可以是private，protected或者是public。



​	接口就是这样的一种规范，它抽取了事物的相似行为，而不关心事物有什么关系

​		1，相比于继承抽象类的“is-a”关系，体现的是“是XX”思想，而实现接口体现的是“能够XX”的思想

​		2，接口允许多实现。实现多个接口，继承它们所有的属性和方法

​		3，**接口的本质是契约、规范、标准**



> 接口和抽象类形式参数和返回值问题

****

> 方法的形式参数（formal）在传值的时候

**1.基本类型：**对于基本数据类型的方法传参，存在自动类型提升

**2.引用类型：** 对于引用数据类型的方法传参，存在自动向上转型

- 类：调用方法时需要传入的是该类的对象或者该类的子类对象
- 抽象类：调用方法时需要传入的是该抽象类的子类对象
- 接口：调用方法时需要传入的是该接口的子类对象



> 方法的返回值类型

> 父子类方法重写中，方法声明中返回值类型的书写

**1.基本类型：**必须保持一模一样，不存在类型提升

**2.引用类型：**不必保持一模一样，存在自动向上转型

- 类：父类中的方法返回一个普通类类型
  - 子类方法中可以返回该类型
  - 也可以返回该类的子类类型
- 抽象类：父类中的方法返回一个抽象类类型
  - 子类方法可以返回该类型
  - 也可以返回抽象类的实现类类型
- 接口：父类中的方法返回一个接口类型
  - 子类方法可以返回该类型
  - 也可以返回接口的实现类类型

> 在方法中书写一个具体的返回值

**1.基本类型：**方法体中，返回一个具体的值的时候，存在自动类型提升

**2.引用类型：**方法体中，返回一个具体对象的时候，存在自动向上转型

- 类：返回该类的对象或者该类的子类对象
- 抽象类：返回抽象类的（具体）子类对象
- 接口：返回接口的（具体）子类对象

​	

**C.链式调用**（chain calls）

```java 
StudentDemo sd = new StudentDemo();
Student s = sd.getStudent();
s.show();
//类似这种形式的代码，可以写成链式调用的形式，就变成了
new StudentDemo().getStudent().show();
//结果是一样的
```





